{"version":3,"sources":["App.tsx","images/dome.jpg","index.tsx"],"names":["canvas","scene","listMaterialsNeedUpdateTime","time","Date","now","models","current","meshPicked","mesh","console","log","nextMesh","node","getNodeByName","dispose","length","SceneLoader","LoadAssetContainerAsync","then","container","processContainer","meshes","forEach","material","metadata","gltf","extras","isShaderMaterial","materialInfo","uniforms","indexOf","push","samplers","sampler","name","vertexSource","i","fragmentSource","Effect","ShadersStore","myShaderMaterial","ShaderMaterial","vertex","fragment","attributes","needAlphaBlending","needsAlphaBlending","needAlphaTesting","textures","pointers","j","pointer","setTexture","backFaceCulling","addAllToScene","onSceneMount","e","ShowLoadingScreen","GLTFFileLoader","IncrementalLoading","clearColor","Color4","PhotoDome","dome_path","HemisphericLight","Vector3","camera","ArcRotateCamera","Math","PI","speed","minZ","activeCameras","attachControl","getEngine","runRenderLoop","render","mat","setFloat","App","useState","setFontsReady","faLoaded","useRef","document","fonts","check","load","className","style","position","top","bottom","onClick","flex","display","antialias","adaptToDeviceRatio","canvasId","children","onMeshPicked","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.8299876b.chunk.js","sourcesContent":["import React, { useRef, useState } from 'react'\nimport { Engine, Scene as SceneComponent, SceneEventArgs } from 'react-babylonjs'\nimport { SceneLoader, Vector3, ArcRotateCamera, AbstractMesh, Scene, Color4, ShaderMaterial, Effect, BaseTexture, HemisphericLight, AssetContainer, PhotoDome, TransformNode } from '@babylonjs/core'\nimport '@babylonjs/loaders'\nimport './App.css'\nimport { GLTFFileLoader } from '@babylonjs/loaders'\n\nimport type { MaterialExtension } from './extras/material'\n\nimport dome_path from './images/dome.jpg'\n\nlet canvas: HTMLCanvasElement | null;\nlet scene: Scene | null;\nlet listMaterialsNeedUpdateTime: ShaderMaterial[] = [];\nlet time = Date.now();\nconst models = ['object_1.glb', 'object_1_net.glb'];\nlet current = 0;\n\nfunction meshPicked (mesh: AbstractMesh, scene: Scene) {\n  console.log('mesh picked:', mesh)\n}\n\n// function setDragAndDropUp() {\n//   if (canvas) {\n//     canvas.addEventListener('dragenter', handlerFunction, false);\n//     canvas.addEventListener('dragleave', handlerFunction, false);\n//     canvas.addEventListener('dragover', handlerFunction, false);\n//     canvas.addEventListener('drop', handlerFunction, false);\n//   }\n// }\n\n// function handlerFunction() {\n//   ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {\n//     canvas && canvas.addEventListener(eventName, preventDefaults, false)\n//   });\n  \n//   function preventDefaults (e: Event) {\n//     e.preventDefault()\n//     e.stopPropagation()\n//   }\n\n//   canvas && canvas.addEventListener('drop', handleDrop, false);\n//   function handleDrop(e: DragEvent) {\n//     let dt = e.dataTransfer;\n//     let files = dt && dt.files;\n//     files && handleFiles(files);\n//   }\n// }\n\n// async function handleFiles(files: FileList) {\n//   for (let i = 0; i < files.length; i++) {\n//     const file = files.item(i);\n//     if (file) {\n//       const toBase64 = (f: File) =>\n//       new Promise((resolve, reject) => {\n//         const reader = new FileReader();\n//         reader.readAsDataURL(f);\n//         reader.onload = () => resolve(reader.result);\n//         reader.onerror = error => reject(error);\n//       });\n//       const data = await toBase64(file);\n//     }\n//   }\n// }\n\nfunction nextMesh() {\n  if (scene) {\n    const node = scene.getNodeByName('__root__');\n    node && node.dispose();\n    current = (current + 1) % models.length;\n    SceneLoader.LoadAssetContainerAsync(\"\", \"./\" + models[current], scene).then(container => {processContainer(container)});\n  }\n}\n\nfunction processContainer (container: AssetContainer) {\n  container.meshes.forEach(mesh => {\n    if (mesh.material && mesh.material.metadata.gltf.extras && mesh.material.metadata.gltf.extras.isShaderMaterial) {\n      const materialInfo = mesh.material?.metadata.gltf.extras as MaterialExtension;\n      if (!materialInfo.uniforms) {\n        materialInfo.uniforms = [\"worldViewProjection\"];\n      } else if(materialInfo.uniforms.indexOf(\"worldViewProjection\") === -1) {\n        materialInfo.uniforms.push(\"worldViewProjection\");\n      }\n      const samplers: string[] = [];\n      if (materialInfo.samplers) {\n        materialInfo.samplers.forEach(sampler => samplers.push(sampler.name))\n      }\n      \n      let vertexSource = \"\";\n      for (let i = 0; i < materialInfo.vertexSource.length; i++) {\n        vertexSource += materialInfo.vertexSource[i];\n      }\n      let fragmentSource = \"\";\n      for (let i = 0; i < materialInfo.fragmentSource.length; i++) {\n        fragmentSource += materialInfo.fragmentSource[i];\n      }\n      Effect.ShadersStore[mesh.material.name + current + \"_customVertexShader\"] = vertexSource;\n      Effect.ShadersStore[mesh.material.name + current + \"_customFragmentShader\"] = fragmentSource;\n      var myShaderMaterial = new ShaderMaterial(mesh.material.name + current + \"_custom\", scene!, \n        {\n          vertex: mesh.material.name + current + \"_custom\",\n          fragment: mesh.material.name + current + \"_custom\",\n        }, \n        {\n          attributes: materialInfo.attributes,\n          uniforms: materialInfo.uniforms,\n          samplers: samplers,\n          needAlphaBlending: materialInfo.needsAlphaBlending ? materialInfo.needsAlphaBlending : false,\n          needAlphaTesting: true,\n          \n        }\n      );\n      materialInfo.samplers?.forEach(sampler => {\n        for (let i = 0; i < container.textures.length; i++) {\n          const pointers = container.textures[i].metadata.gltf.pointers as string[];\n          for (let j = 0; j < pointers.length; j++) {\n            if (sampler.pointer === pointers[j]) {\n              myShaderMaterial.setTexture(sampler.name, container.textures[i]);\n            }\n          }\n        }\n      });\n      \n      myShaderMaterial.backFaceCulling = mesh.material.backFaceCulling;\n      mesh.material = myShaderMaterial;\n\n      if(materialInfo.uniforms && materialInfo.uniforms.indexOf(\"time\") > -1) {\n        listMaterialsNeedUpdateTime.push(myShaderMaterial);\n      }\n    }\n  });\n  container.addAllToScene();\n}\n\nfunction onSceneMount (e: SceneEventArgs) {\n  canvas = e.canvas;\n  scene = e.scene;\n  //setDragAndDropUp();\n  SceneLoader.ShowLoadingScreen = false;\n  GLTFFileLoader.IncrementalLoading = false;\n  SceneLoader.LoadAssetContainerAsync(\"\", \"./\" + models[current], scene).then(container => {processContainer(container)});\n  //SceneLoader.LoadAssetContainerAsync(\"\", \"./clownman.glb\", scene).then(container => {processContainer(container)});\n  //SceneLoader.LoadAssetContainerAsync(\"\", \"./fireball_final.glb\", scene).then(container => {processContainer(container)});\n  //SceneLoader.LoadAssetContainerAsync(\"\", \"./hat_final.glb\", scene).then(container => {processContainer(container)});\n\n  scene.clearColor = new Color4(0.5, 0.0, 0.5, 0.4);\n  const photoDome = new PhotoDome(\"testdome\", dome_path, {}, scene);\n  const light = new HemisphericLight('sun', new Vector3(-1, -1, 0), scene);\n  var camera = new ArcRotateCamera('BGCamera', Math.PI / 2 + Math.PI / 7, Math.PI / 2, 1,\n    new Vector3(0, 0, 0),\n    scene);\n  camera.speed = 0.01\n  camera.minZ = 0.001\n  scene.activeCameras?.push(camera);\n  camera.attachControl(canvas, true);\n  scene.getEngine().runRenderLoop(() => {\n    if (scene) {\n      scene.render();\n      listMaterialsNeedUpdateTime.forEach(mat => mat.setFloat('time', (Date.now() - time) / 1000));\n    }\n  })\n}\n\nconst App: React.FC = () => {\n\n  const [fontsReady, setFontsReady] = useState(false);\n  const faLoaded = useRef(false);\n  if (document.fonts.check(\"16px FontAwesome\") === false) {\n    document.fonts.load(\"16px FontAwesome\").then(() => {\n      if (faLoaded.current !== true) {\n        faLoaded.current = true;\n        setFontsReady(true);\n      }\n    });\n  } else if (faLoaded.current !== true) {\n    faLoaded.current = true;\n    setFontsReady(true);\n  }\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n      <button style={{position:'absolute', top:'10px', bottom:'10px'}} onClick={nextMesh}>Next</button>\n        <div style={{ flex: 1, display: 'flex' }}>\n        <Engine antialias adaptToDeviceRatio canvasId='babylonJS'>\n          <SceneComponent children={null} onMeshPicked={meshPicked} onSceneMount={onSceneMount} />\n        </Engine>\n      </div>\n      </header>\n    </div>\n  );\n}\nexport default App;","export default __webpack_public_path__ + \"static/media/dome.225b30b8.jpg\";","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}