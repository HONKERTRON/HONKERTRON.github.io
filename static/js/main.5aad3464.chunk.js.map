{"version":3,"sources":["App.tsx","images/dome.jpg","index.tsx"],"names":["canvas","scene","listMaterialsNeedUpdateTime","time","Date","now","meshPicked","mesh","console","log","onSceneMount","e","SceneLoader","ShowLoadingScreen","GLTFFileLoader","IncrementalLoading","LoadAssetContainerAsync","then","container","meshes","forEach","material","metadata","gltf","extras","isShaderMaterial","materialInfo","uniforms","indexOf","push","samplers","sampler","name","vertexSource","i","length","fragmentSource","Effect","ShadersStore","myShaderMaterial","ShaderMaterial","vertex","fragment","attributes","needAlphaBlending","needsAlphaBlending","needAlphaTesting","textures","pointers","j","pointer","setTexture","backFaceCulling","addAllToScene","processContainer","clearColor","Color4","PhotoDome","dome_path","HemisphericLight","Vector3","camera","ArcRotateCamera","Math","PI","speed","minZ","activeCameras","attachControl","getEngine","runRenderLoop","render","mat","setFloat","App","useState","setFontsReady","faLoaded","useRef","document","fonts","check","load","current","className","style","flex","display","antialias","adaptToDeviceRatio","canvasId","children","onMeshPicked","ReactDOM","StrictMode","getElementById"],"mappings":"2LAWIA,EACAC,E,gFCZW,G,OAAA,IAA0B,kC,SDarCC,EAAgD,GAChDC,EAAOC,KAAKC,MAEhB,SAASC,EAAYC,EAAoBN,GACvCO,QAAQC,IAAI,eAAgBF,GA0G9B,SAASG,EAAcC,GAAoB,IAAD,EACxCX,EAASW,EAAEX,OACXC,EAAQU,EAAEV,MAEVW,IAAYC,mBAAoB,EAChCC,IAAeC,oBAAqB,EACpCH,IAAYI,wBAAwB,GAAI,iBAAkBf,GAAOgB,MAAK,SAAAC,IAlExE,SAA2BA,GACzBA,EAAUC,OAAOC,SAAQ,SAAAb,GACvB,GAAIA,EAAKc,UAAYd,EAAKc,SAASC,SAASC,KAAKC,QAAUjB,EAAKc,SAASC,SAASC,KAAKC,OAAOC,iBAAkB,CAAC,IAAD,IACxGC,EAAY,UAAGnB,EAAKc,gBAAR,aAAG,EAAeC,SAASC,KAAKC,OAC7CE,EAAaC,UAEkD,IAA1DD,EAAaC,SAASC,QAAQ,wBACtCF,EAAaC,SAASE,KAAK,uBAF3BH,EAAaC,SAAW,CAAC,uBAI3B,IAAMG,EAAqB,GACvBJ,EAAaI,UACfJ,EAAaI,SAASV,SAAQ,SAAAW,GAAO,OAAID,EAASD,KAAKE,EAAQC,SAIjE,IADA,IAAIC,EAAe,GACVC,EAAI,EAAGA,EAAIR,EAAaO,aAAaE,OAAQD,IACpDD,GAAgBP,EAAaO,aAAaC,GAG5C,IADA,IAAIE,EAAiB,GACZF,EAAI,EAAGA,EAAIR,EAAaU,eAAeD,OAAQD,IACtDE,GAAkBV,EAAaU,eAAeF,GAEhDG,IAAOC,aAAa/B,EAAKc,SAASW,KAAO,uBAAyBC,EAClEI,IAAOC,aAAa/B,EAAKc,SAASW,KAAO,yBAA2BI,EACpE,IAAIG,EAAmB,IAAIC,IAAejC,EAAKc,SAASW,KAAO,UAAW/B,EACxE,CACEwC,OAAQlC,EAAKc,SAASW,KAAO,UAC7BU,SAAUnC,EAAKc,SAASW,KAAO,WAEjC,CACEW,WAAYjB,EAAaiB,WACzBhB,SAAUD,EAAaC,SACvBG,SAAUA,EACVc,oBAAmBlB,EAAamB,oBAAqBnB,EAAamB,mBAClEC,kBAAkB,IAItB,UAAApB,EAAaI,gBAAb,SAAuBV,SAAQ,SAAAW,GAC7B,IAAK,IAAIG,EAAI,EAAGA,EAAIhB,EAAU6B,SAASZ,OAAQD,IAE7C,IADA,IAAMc,EAAW9B,EAAU6B,SAASb,GAAGZ,SAASC,KAAKyB,SAC5CC,EAAI,EAAGA,EAAID,EAASb,OAAQc,IAC/BlB,EAAQmB,UAAYF,EAASC,IAC/BV,EAAiBY,WAAWpB,EAAQC,KAAMd,EAAU6B,SAASb,OAMrEK,EAAiBa,gBAAkB7C,EAAKc,SAAS+B,gBACjD7C,EAAKc,SAAWkB,EAEbb,EAAaC,UAAYD,EAAaC,SAASC,QAAQ,SAAW,GACnE1B,EAA4B2B,KAAKU,OAIvCrB,EAAUmC,gBAS0EC,CAAiBpC,MAKrGjB,EAAMsD,WAAa,IAAIC,IAAO,GAAK,EAAK,GAAK,IAC3B,IAAIC,IAAU,WAAYC,EAAW,GAAIzD,GAC7C,IAAI0D,IAAiB,MAAO,IAAIC,KAAS,GAAI,EAAG,GAAI3D,GADlE,IAEI4D,EAAS,IAAIC,IAAgB,WAAYC,KAAKC,GAAK,EAAID,KAAKC,GAAK,EAAGD,KAAKC,GAAK,EAAG,EACnF,IAAIJ,IAAQ,EAAG,EAAG,GAClB3D,GACF4D,EAAOI,MAAQ,IACfJ,EAAOK,KAAO,KACd,UAAAjE,EAAMkE,qBAAN,SAAqBtC,KAAKgC,GAC1BA,EAAOO,cAAcpE,GAAQ,GAC7BC,EAAMoE,YAAYC,eAAc,WAC1BrE,IACFA,EAAMsE,SACNrE,EAA4BkB,SAAQ,SAAAoD,GAAG,OAAIA,EAAIC,SAAS,QAASrE,KAAKC,MAAQF,GAAQ,YAK5F,IA4BeuE,EA5BO,WAEpB,MAAoCC,oBAAS,GAA7C,mBAAmBC,GAAnB,WACMC,EAAWC,kBAAO,GAaxB,OAZiD,IAA7CC,SAASC,MAAMC,MAAM,oBACvBF,SAASC,MAAME,KAAK,oBAAoBjE,MAAK,YAClB,IAArB4D,EAASM,UACXN,EAASM,SAAU,EACnBP,GAAc,QAGY,IAArBC,EAASM,UAClBN,EAASM,SAAU,EACnBP,GAAc,IAId,qBAAKQ,UAAU,MAAf,SACE,wBAAQA,UAAU,aAAlB,SACE,qBAAKC,MAAO,CAAEC,KAAM,EAAGC,QAAS,QAAhC,SACA,cAAC,IAAD,CAAQC,WAAS,EAACC,oBAAkB,EAACC,SAAS,YAA9C,SACE,cAAC,IAAD,CAAgBC,SAAU,KAAMC,aAActF,EAAYI,aAAcA,aExKlFmF,IAAStB,OACP,cAAC,IAAMuB,WAAP,UACE,cAAC,EAAD,MAEFf,SAASgB,eAAe,W","file":"static/js/main.5aad3464.chunk.js","sourcesContent":["import React, { useRef, useState } from 'react'\nimport { Engine, Scene as SceneComponent, SceneEventArgs } from 'react-babylonjs'\nimport { SceneLoader, Vector3, ArcRotateCamera, AbstractMesh, Scene, Color4, ShaderMaterial, Effect, BaseTexture, HemisphericLight, AssetContainer, PhotoDome } from '@babylonjs/core'\nimport '@babylonjs/loaders'\nimport './App.css'\nimport { GLTFFileLoader } from '@babylonjs/loaders'\n\nimport type { MaterialExtension } from './extras/material'\n\nimport dome_path from './images/dome.jpg'\n\nlet canvas: HTMLCanvasElement | null;\nlet scene: Scene | null;\nlet listMaterialsNeedUpdateTime: ShaderMaterial[] = [];\nlet time = Date.now();\n\nfunction meshPicked (mesh: AbstractMesh, scene: Scene) {\n  console.log('mesh picked:', mesh)\n}\n\n// function setDragAndDropUp() {\n//   if (canvas) {\n//     canvas.addEventListener('dragenter', handlerFunction, false);\n//     canvas.addEventListener('dragleave', handlerFunction, false);\n//     canvas.addEventListener('dragover', handlerFunction, false);\n//     canvas.addEventListener('drop', handlerFunction, false);\n//   }\n// }\n\n// function handlerFunction() {\n//   ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {\n//     canvas && canvas.addEventListener(eventName, preventDefaults, false)\n//   });\n  \n//   function preventDefaults (e: Event) {\n//     e.preventDefault()\n//     e.stopPropagation()\n//   }\n\n//   canvas && canvas.addEventListener('drop', handleDrop, false);\n//   function handleDrop(e: DragEvent) {\n//     let dt = e.dataTransfer;\n//     let files = dt && dt.files;\n//     files && handleFiles(files);\n//   }\n// }\n\n// async function handleFiles(files: FileList) {\n//   for (let i = 0; i < files.length; i++) {\n//     const file = files.item(i);\n//     if (file) {\n//       const toBase64 = (f: File) =>\n//       new Promise((resolve, reject) => {\n//         const reader = new FileReader();\n//         reader.readAsDataURL(f);\n//         reader.onload = () => resolve(reader.result);\n//         reader.onerror = error => reject(error);\n//       });\n//       const data = await toBase64(file);\n//     }\n//   }\n// }\n\nfunction processContainer (container: AssetContainer) {\n  container.meshes.forEach(mesh => {\n    if (mesh.material && mesh.material.metadata.gltf.extras && mesh.material.metadata.gltf.extras.isShaderMaterial) {\n      const materialInfo = mesh.material?.metadata.gltf.extras as MaterialExtension;\n      if (!materialInfo.uniforms) {\n        materialInfo.uniforms = [\"worldViewProjection\"];\n      } else if(materialInfo.uniforms.indexOf(\"worldViewProjection\") === -1) {\n        materialInfo.uniforms.push(\"worldViewProjection\");\n      }\n      const samplers: string[] = [];\n      if (materialInfo.samplers) {\n        materialInfo.samplers.forEach(sampler => samplers.push(sampler.name))\n      }\n      \n      let vertexSource = \"\";\n      for (let i = 0; i < materialInfo.vertexSource.length; i++) {\n        vertexSource += materialInfo.vertexSource[i];\n      }\n      let fragmentSource = \"\";\n      for (let i = 0; i < materialInfo.fragmentSource.length; i++) {\n        fragmentSource += materialInfo.fragmentSource[i];\n      }\n      Effect.ShadersStore[mesh.material.name + \"_customVertexShader\"] = vertexSource;\n      Effect.ShadersStore[mesh.material.name + \"_customFragmentShader\"] = fragmentSource;\n      var myShaderMaterial = new ShaderMaterial(mesh.material.name + \"_custom\", scene!, \n        {\n          vertex: mesh.material.name + \"_custom\",\n          fragment: mesh.material.name + \"_custom\",\n        }, \n        {\n          attributes: materialInfo.attributes,\n          uniforms: materialInfo.uniforms,\n          samplers: samplers,\n          needAlphaBlending: materialInfo.needsAlphaBlending ? materialInfo.needsAlphaBlending : false,\n          needAlphaTesting: true,\n          \n        }\n      );\n      materialInfo.samplers?.forEach(sampler => {\n        for (let i = 0; i < container.textures.length; i++) {\n          const pointers = container.textures[i].metadata.gltf.pointers as string[];\n          for (let j = 0; j < pointers.length; j++) {\n            if (sampler.pointer === pointers[j]) {\n              myShaderMaterial.setTexture(sampler.name, container.textures[i]);\n            }\n          }\n        }\n      });\n      \n      myShaderMaterial.backFaceCulling = mesh.material.backFaceCulling;\n      mesh.material = myShaderMaterial;\n\n      if(materialInfo.uniforms && materialInfo.uniforms.indexOf(\"time\") > -1) {\n        listMaterialsNeedUpdateTime.push(myShaderMaterial);\n      }\n    }\n  });\n  container.addAllToScene();\n}\n\nfunction onSceneMount (e: SceneEventArgs) {\n  canvas = e.canvas;\n  scene = e.scene;\n  //setDragAndDropUp();\n  SceneLoader.ShowLoadingScreen = false;\n  GLTFFileLoader.IncrementalLoading = false;\n  SceneLoader.LoadAssetContainerAsync(\"\", \"./object_1.glb\", scene).then(container => {processContainer(container)});\n  //SceneLoader.LoadAssetContainerAsync(\"\", \"./clownman.glb\", scene).then(container => {processContainer(container)});\n  //SceneLoader.LoadAssetContainerAsync(\"\", \"./fireball_final.glb\", scene).then(container => {processContainer(container)});\n  //SceneLoader.LoadAssetContainerAsync(\"\", \"./hat_final.glb\", scene).then(container => {processContainer(container)});\n\n  scene.clearColor = new Color4(0.5, 0.0, 0.5, 0.4);\n  const photoDome = new PhotoDome(\"testdome\", dome_path, {}, scene);\n  const light = new HemisphericLight('sun', new Vector3(-1, -1, 0), scene);\n  var camera = new ArcRotateCamera('BGCamera', Math.PI / 2 + Math.PI / 7, Math.PI / 2, 1,\n    new Vector3(0, 0, 0),\n    scene);\n  camera.speed = 0.01\n  camera.minZ = 0.001\n  scene.activeCameras?.push(camera);\n  camera.attachControl(canvas, true);\n  scene.getEngine().runRenderLoop(() => {\n    if (scene) {\n      scene.render();\n      listMaterialsNeedUpdateTime.forEach(mat => mat.setFloat('time', (Date.now() - time) / 1000));\n    }\n  })\n}\n\nconst App: React.FC = () => {\n\n  const [fontsReady, setFontsReady] = useState(false);\n  const faLoaded = useRef(false);\n  if (document.fonts.check(\"16px FontAwesome\") === false) {\n    document.fonts.load(\"16px FontAwesome\").then(() => {\n      if (faLoaded.current !== true) {\n        faLoaded.current = true;\n        setFontsReady(true);\n      }\n    });\n  } else if (faLoaded.current !== true) {\n    faLoaded.current = true;\n    setFontsReady(true);\n  }\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <div style={{ flex: 1, display: 'flex' }}>\n        <Engine antialias adaptToDeviceRatio canvasId='babylonJS'>\n          <SceneComponent children={null} onMeshPicked={meshPicked} onSceneMount={onSceneMount} />\n        </Engine>\n      </div>\n      </header>\n    </div>\n  );\n}\nexport default App;","export default __webpack_public_path__ + \"static/media/dome.225b30b8.jpg\";","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}