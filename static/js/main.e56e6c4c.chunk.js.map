{"version":3,"sources":["App.tsx","reportWebVitals.ts","index.tsx"],"names":["canvas","scene","listMaterialsNeedUpdateTime","time","Date","now","meshPicked","mesh","console","log","onSceneMount","e","SceneLoader","ShowLoadingScreen","GLTFFileLoader","IncrementalLoading","LoadAssetContainerAsync","then","container","meshes","forEach","material","metadata","gltf","extras","isShaderMaterial","materialInfo","uniforms","indexOf","push","samplers","sampler","name","vertexSource","i","length","fragmentSource","Effect","ShadersStore","myShaderMaterial","ShaderMaterial","vertex","fragment","attributes","needAlphaBlending","needAlphaTesting","texture","textures","pointers","pointer","setTexture","backFaceCulling","addAllToScene","clearColor","Color4","HemisphericLight","Vector3","camera","ArcRotateCamera","Math","PI","speed","minZ","activeCameras","attachControl","getEngine","runRenderLoop","render","mat","setFloat","App","useState","setFontsReady","faLoaded","useRef","document","fonts","check","load","current","className","style","flex","display","antialias","adaptToDeviceRatio","canvasId","children","onMeshPicked","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.e56e6c4c.chunk.js","sourcesContent":["import React, { useRef, useState } from 'react'\nimport { Engine, Scene as SceneComponent, SceneEventArgs } from 'react-babylonjs'\nimport { SceneLoader, Vector3, ArcRotateCamera, AbstractMesh, Scene, Color4, ShaderMaterial, Effect, BaseTexture, HemisphericLight } from '@babylonjs/core'\nimport '@babylonjs/loaders'\nimport './App.css'\nimport { GLTFFileLoader } from '@babylonjs/loaders'\n\nimport type { MaterialExtension } from './extras/material'\n\nlet canvas: HTMLCanvasElement | null;\nlet scene: Scene | null;\nlet listMaterialsNeedUpdateTime: ShaderMaterial[] = [];\nlet time = Date.now();\n\nfunction meshPicked (mesh: AbstractMesh, scene: Scene) {\n  console.log('mesh picked:', mesh)\n}\n\n// function setDragAndDropUp() {\n//   if (canvas) {\n//     canvas.addEventListener('dragenter', handlerFunction, false);\n//     canvas.addEventListener('dragleave', handlerFunction, false);\n//     canvas.addEventListener('dragover', handlerFunction, false);\n//     canvas.addEventListener('drop', handlerFunction, false);\n//   }\n// }\n\n// function handlerFunction() {\n//   ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {\n//     canvas && canvas.addEventListener(eventName, preventDefaults, false)\n//   });\n  \n//   function preventDefaults (e: Event) {\n//     e.preventDefault()\n//     e.stopPropagation()\n//   }\n\n//   canvas && canvas.addEventListener('drop', handleDrop, false);\n//   function handleDrop(e: DragEvent) {\n//     let dt = e.dataTransfer;\n//     let files = dt && dt.files;\n//     files && handleFiles(files);\n//   }\n// }\n\n// async function handleFiles(files: FileList) {\n//   for (let i = 0; i < files.length; i++) {\n//     const file = files.item(i);\n//     if (file) {\n//       const toBase64 = (f: File) =>\n//       new Promise((resolve, reject) => {\n//         const reader = new FileReader();\n//         reader.readAsDataURL(f);\n//         reader.onload = () => resolve(reader.result);\n//         reader.onerror = error => reject(error);\n//       });\n//       const data = await toBase64(file);\n//     }\n//   }\n// }\n\nfunction onSceneMount (e: SceneEventArgs) {\n  canvas = e.canvas;\n  scene = e.scene;\n  //setDragAndDropUp();\n  SceneLoader.ShowLoadingScreen = false;\n  GLTFFileLoader.IncrementalLoading = false;\n  SceneLoader.LoadAssetContainerAsync(\"\", \"./untitled.glb\", scene).then((container) => {\n    container.meshes.forEach(mesh => {\n      if (mesh.material && mesh.material.metadata.gltf.extras && mesh.material.metadata.gltf.extras.isShaderMaterial) {\n        const materialInfo = mesh.material?.metadata.gltf.extras as MaterialExtension;\n        if (!materialInfo.uniforms) {\n          materialInfo.uniforms = [\"worldViewProjection\"];\n        } else if(materialInfo.uniforms.indexOf(\"worldViewProjection\") === -1) {\n          materialInfo.uniforms.push(\"worldViewProjection\");\n        }\n        const samplers: string[] = [];\n        if (materialInfo.samplers) {\n          materialInfo.samplers.forEach(sampler => samplers.push(sampler.name))\n        }\n        \n        let vertexSource = \"\";\n        for (let i = 0; i < materialInfo.vertexSource.length; i++) {\n          vertexSource += materialInfo.vertexSource[i];\n        }\n        let fragmentSource = \"\";\n        for (let i = 0; i < materialInfo.fragmentSource.length; i++) {\n          fragmentSource += materialInfo.fragmentSource[i];\n        }\n        Effect.ShadersStore[mesh.material.name + \"_customVertexShader\"] = vertexSource;\n        Effect.ShadersStore[mesh.material.name + \"_customFragmentShader\"] = fragmentSource;\n        var myShaderMaterial = new ShaderMaterial(mesh.material.name + \"_custom\", scene!, \n          {\n            vertex: mesh.material.name + \"_custom\",\n            fragment: mesh.material.name + \"_custom\",\n          }, \n          {\n            attributes: materialInfo.attributes,\n            uniforms: materialInfo.uniforms,\n            samplers: samplers,\n            needAlphaBlending: false,\n            needAlphaTesting: true,\n          }\n        );\n        materialInfo.samplers?.forEach(sampler => {\n          let texture: BaseTexture | null = null;\n          for (let i = 0; i < container.textures.length; i++) {\n            const pointers = container.textures[i].metadata.gltf.pointers as string[];\n            for (let i = 0; i < pointers.length; i++) {\n              if (sampler.pointer === pointers[i]) {\n                texture = container.textures[i];\n              }\n            }\n          }\n          texture && myShaderMaterial.setTexture(sampler.name, texture);\n        });\n        \n        myShaderMaterial.backFaceCulling = mesh.material.backFaceCulling;\n        mesh.material = myShaderMaterial;\n\n        if(materialInfo.uniforms && materialInfo.uniforms.indexOf(\"time\") > -1) {\n          listMaterialsNeedUpdateTime.push(myShaderMaterial);\n        }\n      }\n    });\n    container.addAllToScene();\n  });\n\n  scene.clearColor = new Color4(0.5, 0.0, 0.5, 0.4);\n  const light = new HemisphericLight('sun', new Vector3(-1, -1, 0), scene);\n  var camera = new ArcRotateCamera('BGCamera', Math.PI / 2 + Math.PI / 7, Math.PI / 2, 100,\n    new Vector3(0, 0, 0),\n    scene);\n  camera.speed = 0.01\n  camera.minZ = 0.001\n  scene.activeCameras?.push(camera);\n  camera.attachControl(canvas, true);\n  scene.getEngine().runRenderLoop(() => {\n    if (scene) {\n      scene.render();\n      listMaterialsNeedUpdateTime.forEach(mat => mat.setFloat('time', (Date.now() - time) / 1000));\n    }\n  })\n}\n\nconst App: React.FC = () => {\n\n  const [fontsReady, setFontsReady] = useState(false);\n  const faLoaded = useRef(false);\n  if (document.fonts.check(\"16px FontAwesome\") === false) {\n    document.fonts.load(\"16px FontAwesome\").then(() => {\n      if (faLoaded.current !== true) {\n        faLoaded.current = true;\n        setFontsReady(true);\n      }\n    });\n  } else if (faLoaded.current !== true) {\n    faLoaded.current = true;\n    setFontsReady(true);\n  }\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <div style={{ flex: 1, display: 'flex' }}>\n        <Engine antialias adaptToDeviceRatio canvasId='babylonJS'>\n          <SceneComponent children={null} onMeshPicked={meshPicked} onSceneMount={onSceneMount} />\n        </Engine>\n      </div>\n      </header>\n    </div>\n  );\n}\nexport default App;","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n}\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}