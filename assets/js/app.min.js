/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/videocontext/dist/videocontext.js":
/*!********************************************************!*\
  !*** ./node_modules/videocontext/dist/videocontext.js ***!
  \********************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_549__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_549__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_549__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_549__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_549__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_549__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_549__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_549__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_549__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_549__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_549__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_549__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_549__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_549__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_549__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_549__(__nested_webpack_require_549__.s = \"./src/videocontext.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/Definitions/aaf_video_crop/aaf_video_crop.frag\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/aaf_video_crop/aaf_video_crop.frag ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nuniform float cropLeft;\\nuniform float cropRight;\\nuniform float cropTop;\\nuniform float cropBottom;\\nvarying vec2 v_texCoord;\\nvoid main(){\\n    vec4 color = texture2D(u_image, v_texCoord);\\n    if (v_texCoord[0] < (cropLeft+1.0)/2.0) color = vec4(0.0,0.0,0.0,0.0);\\n    if (v_texCoord[0] > (cropRight+1.0)/2.0) color = vec4(0.0,0.0,0.0,0.0);\\n    if (v_texCoord[1] < (-cropBottom+1.0)/2.0) color = vec4(0.0,0.0,0.0,0.0);\\n    if (v_texCoord[1] > (-cropTop+1.0)/2.0) color = vec4(0.0,0.0,0.0,0.0);\\n    gl_FragColor = color;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_crop/aaf_video_crop.js\":\n/*!**********************************************************!*\\\n  !*** ./src/Definitions/aaf_video_crop/aaf_video_crop.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_5252__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _aaf_video_crop = __nested_webpack_require_5252__(/*! ./aaf_video_crop.vert */ \"./src/Definitions/aaf_video_crop/aaf_video_crop.vert\");\n\nvar _aaf_video_crop2 = _interopRequireDefault(_aaf_video_crop);\n\nvar _aaf_video_crop3 = __nested_webpack_require_5252__(/*! ./aaf_video_crop.frag */ \"./src/Definitions/aaf_video_crop/aaf_video_crop.frag\");\n\nvar _aaf_video_crop4 = _interopRequireDefault(_aaf_video_crop3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar aaf_video_crop = {\n    title: \"AAF Video Crop Effect\",\n    description: \"A crop effect based on the AAF spec.\",\n    vertexShader: _aaf_video_crop2.default,\n    fragmentShader: _aaf_video_crop4.default,\n    properties: {\n        cropLeft: { type: \"uniform\", value: -1.0 },\n        cropRight: { type: \"uniform\", value: 1.0 },\n        cropTop: { type: \"uniform\", value: -1.0 },\n        cropBottom: { type: \"uniform\", value: 1.0 }\n    },\n    inputs: [\"u_image\"]\n};\n\nexports.default = aaf_video_crop;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_crop/aaf_video_crop.vert\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/aaf_video_crop/aaf_video_crop.vert ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_flip/aaf_video_flip.frag\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/aaf_video_flip/aaf_video_flip.frag ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texCoord;\\nvoid main(){\\n    vec2 coord = vec2(v_texCoord[0] ,1.0 - v_texCoord[1]);\\n    vec4 color = texture2D(u_image, coord);\\n    gl_FragColor = color;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_flip/aaf_video_flip.js\":\n/*!**********************************************************!*\\\n  !*** ./src/Definitions/aaf_video_flip/aaf_video_flip.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_7859__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _aaf_video_flip = __nested_webpack_require_7859__(/*! ./aaf_video_flip.vert */ \"./src/Definitions/aaf_video_flip/aaf_video_flip.vert\");\n\nvar _aaf_video_flip2 = _interopRequireDefault(_aaf_video_flip);\n\nvar _aaf_video_flip3 = __nested_webpack_require_7859__(/*! ./aaf_video_flip.frag */ \"./src/Definitions/aaf_video_flip/aaf_video_flip.frag\");\n\nvar _aaf_video_flip4 = _interopRequireDefault(_aaf_video_flip3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar aaf_video_flip = {\n    title: \"AAF Video Flip Effect\",\n    description: \"A flip effect based on the AAF spec. Mirrors the image in the x-axis\",\n    vertexShader: _aaf_video_flip2.default,\n    fragmentShader: _aaf_video_flip4.default,\n    properties: {},\n    inputs: [\"u_image\"]\n};\n\nexports.default = aaf_video_flip;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_flip/aaf_video_flip.vert\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/aaf_video_flip/aaf_video_flip.vert ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_flop/aaf_video_flop.frag\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/aaf_video_flop/aaf_video_flop.frag ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texCoord;\\nvoid main(){\\n    vec2 coord = vec2(1.0 - v_texCoord[0] ,v_texCoord[1]);\\n    vec4 color = texture2D(u_image, coord);\\n    gl_FragColor = color;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_flop/aaf_video_flop.js\":\n/*!**********************************************************!*\\\n  !*** ./src/Definitions/aaf_video_flop/aaf_video_flop.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_10286__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _aaf_video_flop = __nested_webpack_require_10286__(/*! ./aaf_video_flop.vert */ \"./src/Definitions/aaf_video_flop/aaf_video_flop.vert\");\n\nvar _aaf_video_flop2 = _interopRequireDefault(_aaf_video_flop);\n\nvar _aaf_video_flop3 = __nested_webpack_require_10286__(/*! ./aaf_video_flop.frag */ \"./src/Definitions/aaf_video_flop/aaf_video_flop.frag\");\n\nvar _aaf_video_flop4 = _interopRequireDefault(_aaf_video_flop3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar aaf_video_flop = {\n    title: \"AAF Video Flop Effect\",\n    description: \"A flop effect based on the AAF spec. Mirrors the image in the y-axis\",\n    vertexShader: _aaf_video_flop2.default,\n    fragmentShader: _aaf_video_flop4.default,\n    properties: {},\n    inputs: [\"u_image\"]\n};\n\nexports.default = aaf_video_flop;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_flop/aaf_video_flop.vert\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/aaf_video_flop/aaf_video_flop.vert ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_position/aaf_video_position.frag\":\n/*!********************************************************************!*\\\n  !*** ./src/Definitions/aaf_video_position/aaf_video_position.frag ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nuniform float positionOffsetX;\\nuniform float positionOffsetY;\\nvarying vec2 v_texCoord;\\nvarying float v_progress;\\nvoid main(){\\n    vec2 pos = vec2(v_texCoord[0] - positionOffsetX/2.0, v_texCoord[1] -  positionOffsetY/2.0);\\n    vec4 color = texture2D(u_image, pos);\\n    if (pos[0] < 0.0 || pos[0] > 1.0 || pos[1] < 0.0 || pos[1] > 1.0){\\n        color = vec4(0.0,0.0,0.0,0.0);\\n    }\\n    gl_FragColor = color;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_position/aaf_video_position.js\":\n/*!******************************************************************!*\\\n  !*** ./src/Definitions/aaf_video_position/aaf_video_position.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_13022__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _aaf_video_position = __nested_webpack_require_13022__(/*! ./aaf_video_position.vert */ \"./src/Definitions/aaf_video_position/aaf_video_position.vert\");\n\nvar _aaf_video_position2 = _interopRequireDefault(_aaf_video_position);\n\nvar _aaf_video_position3 = __nested_webpack_require_13022__(/*! ./aaf_video_position.frag */ \"./src/Definitions/aaf_video_position/aaf_video_position.frag\");\n\nvar _aaf_video_position4 = _interopRequireDefault(_aaf_video_position3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar aaf_video_position = {\n    title: \"AAF Video Position Effect\",\n    description: \"A position effect based on the AAF spec.\",\n    vertexShader: _aaf_video_position2.default,\n    fragmentShader: _aaf_video_position4.default,\n    properties: {\n        positionOffsetX: { type: \"uniform\", value: 0.0 },\n        positionOffsetY: { type: \"uniform\", value: 0.0 }\n    },\n    inputs: [\"u_image\"]\n};\n\nexports.default = aaf_video_position;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_position/aaf_video_position.vert\":\n/*!********************************************************************!*\\\n  !*** ./src/Definitions/aaf_video_position/aaf_video_position.vert ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_scale/aaf_video_scale.frag\":\n/*!**************************************************************!*\\\n  !*** ./src/Definitions/aaf_video_scale/aaf_video_scale.frag ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nuniform float scaleX;\\nuniform float scaleY;\\nvarying vec2 v_texCoord;\\nvarying float v_progress;\\nvoid main(){\\n    vec2 pos = vec2(v_texCoord[0]*1.0/scaleX - (1.0/scaleX/2.0 -0.5), v_texCoord[1]*1.0/scaleY - (1.0/scaleY/2.0 -0.5));\\n    vec4 color = texture2D(u_image, pos);\\n    if (pos[0] < 0.0 || pos[0] > 1.0 || pos[1] < 0.0 || pos[1] > 1.0){\\n        color = vec4(0.0,0.0,0.0,0.0);\\n    }\\n    gl_FragColor = color;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_scale/aaf_video_scale.js\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/aaf_video_scale/aaf_video_scale.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_15909__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _aaf_video_scale = __nested_webpack_require_15909__(/*! ./aaf_video_scale.vert */ \"./src/Definitions/aaf_video_scale/aaf_video_scale.vert\");\n\nvar _aaf_video_scale2 = _interopRequireDefault(_aaf_video_scale);\n\nvar _aaf_video_scale3 = __nested_webpack_require_15909__(/*! ./aaf_video_scale.frag */ \"./src/Definitions/aaf_video_scale/aaf_video_scale.frag\");\n\nvar _aaf_video_scale4 = _interopRequireDefault(_aaf_video_scale3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar aaf_video_scale = {\n    title: \"AAF Video Scale Effect\",\n    description: \"A scale effect based on the AAF spec.\",\n    vertexShader: _aaf_video_scale2.default,\n    fragmentShader: _aaf_video_scale4.default,\n    properties: {\n        scaleX: { type: \"uniform\", value: 1.0 },\n        scaleY: { type: \"uniform\", value: 1.0 }\n    },\n    inputs: [\"u_image\"]\n};\n\nexports.default = aaf_video_scale;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/aaf_video_scale/aaf_video_scale.vert\":\n/*!**************************************************************!*\\\n  !*** ./src/Definitions/aaf_video_scale/aaf_video_scale.vert ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/colorThreshold/colorThreshold.frag\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/colorThreshold/colorThreshold.frag ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nuniform float a;\\nuniform vec3 colorAlphaThreshold;\\nvarying vec2 v_texCoord;\\nvarying float v_mix;\\nvoid main(){\\n    vec4 color = texture2D(u_image, v_texCoord);\\n    if (color[0] > colorAlphaThreshold[0] && color[1]> colorAlphaThreshold[1] && color[2]> colorAlphaThreshold[2]){\\n        color = vec4(0.0,0.0,0.0,0.0);\\n    }\\n    gl_FragColor = color;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/colorThreshold/colorThreshold.js\":\n/*!**********************************************************!*\\\n  !*** ./src/Definitions/colorThreshold/colorThreshold.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_18616__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _colorThreshold = __nested_webpack_require_18616__(/*! ./colorThreshold.vert */ \"./src/Definitions/colorThreshold/colorThreshold.vert\");\n\nvar _colorThreshold2 = _interopRequireDefault(_colorThreshold);\n\nvar _colorThreshold3 = __nested_webpack_require_18616__(/*! ./colorThreshold.frag */ \"./src/Definitions/colorThreshold/colorThreshold.frag\");\n\nvar _colorThreshold4 = _interopRequireDefault(_colorThreshold3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar colorThreshold = {\n    title: \"Color Threshold\",\n    description: \"Turns all pixels with a greater value than the specified threshold transparent.\",\n    vertexShader: _colorThreshold2.default,\n    fragmentShader: _colorThreshold4.default,\n    properties: {\n        a: { type: \"uniform\", value: 0.0 },\n        colorAlphaThreshold: { type: \"uniform\", value: [0.0, 0.55, 0.0] }\n    },\n    inputs: [\"u_image\"]\n};\n\nexports.default = colorThreshold;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/colorThreshold/colorThreshold.vert\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/colorThreshold/colorThreshold.vert ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/combine/combine.frag\":\n/*!**********************************************!*\\\n  !*** ./src/Definitions/combine/combine.frag ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nuniform float a;\\nvarying vec2 v_texCoord;\\nvarying float v_mix;\\nvoid main(){\\n    vec4 color = texture2D(u_image, v_texCoord);\\n    gl_FragColor = color;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/combine/combine.js\":\n/*!********************************************!*\\\n  !*** ./src/Definitions/combine/combine.js ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_21044__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _combine = __nested_webpack_require_21044__(/*! ./combine.vert */ \"./src/Definitions/combine/combine.vert\");\n\nvar _combine2 = _interopRequireDefault(_combine);\n\nvar _combine3 = __nested_webpack_require_21044__(/*! ./combine.frag */ \"./src/Definitions/combine/combine.frag\");\n\nvar _combine4 = _interopRequireDefault(_combine3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar combine = {\n    title: \"Combine\",\n    description: \"A basic effect which renders the input to the output, Typically used as a combine node for layering up media with alpha transparency.\",\n    vertexShader: _combine2.default,\n    fragmentShader: _combine4.default,\n    properties: {\n        a: { type: \"uniform\", value: 0.0 }\n    },\n    inputs: [\"u_image\"]\n};\n\nexports.default = combine;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/combine/combine.vert\":\n/*!**********************************************!*\\\n  !*** ./src/Definitions/combine/combine.vert ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/crop/crop.frag\":\n/*!****************************************!*\\\n  !*** ./src/Definitions/crop/crop.frag ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nuniform float x;\\nuniform float y;\\nuniform float width;\\nuniform float height;\\nvarying vec2 v_texCoord;\\nvarying float v_progress;\\nvoid main(){\\n    vec2 pos = (((v_texCoord)*vec2(width, height)) + vec2(0, 1.0-height)) +vec2(x,-y);\\n    vec4 color = texture2D(u_image, pos);\\n    if (pos[0] < 0.0 || pos[0] > 1.0 || pos[1] < 0.0 || pos[1] > 1.0){\\n        color = vec4(0.0,0.0,0.0,0.0);\\n    }\\n    gl_FragColor = color;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/crop/crop.js\":\n/*!**************************************!*\\\n  !*** ./src/Definitions/crop/crop.js ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_23495__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _crop = __nested_webpack_require_23495__(/*! ./crop.vert */ \"./src/Definitions/crop/crop.vert\");\n\nvar _crop2 = _interopRequireDefault(_crop);\n\nvar _crop3 = __nested_webpack_require_23495__(/*! ./crop.frag */ \"./src/Definitions/crop/crop.frag\");\n\nvar _crop4 = _interopRequireDefault(_crop3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar crop = {\n    title: \"Primer Simple Crop\",\n    description: \"A simple crop processors for primer\",\n    vertexShader: _crop2.default,\n    fragmentShader: _crop4.default,\n    properties: {\n        x: { type: \"uniform\", value: 0.0 },\n        y: { type: \"uniform\", value: 0.0 },\n        width: { type: \"uniform\", value: 1.0 },\n        height: { type: \"uniform\", value: 1.0 }\n    },\n    inputs: [\"u_image\"]\n};\n\nexports.default = crop;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/crop/crop.vert\":\n/*!****************************************!*\\\n  !*** ./src/Definitions/crop/crop.vert ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/crossfade/crossfade.frag\":\n/*!**************************************************!*\\\n  !*** ./src/Definitions/crossfade/crossfade.frag ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image_a;\\nuniform sampler2D u_image_b;\\nuniform float mix;\\nvarying vec2 v_texCoord;\\nvarying float v_mix;\\nvoid main(){\\n    vec4 color_a = texture2D(u_image_a, v_texCoord);\\n    vec4 color_b = texture2D(u_image_b, v_texCoord);\\n    color_a[0] *= (1.0 - mix);\\n    color_a[1] *= (1.0 - mix);\\n    color_a[2] *= (1.0 - mix);\\n    color_a[3] *= (1.0 - mix);\\n    color_b[0] *= mix;\\n    color_b[1] *= mix;\\n    color_b[2] *= mix;\\n    color_b[3] *= mix;\\n    gl_FragColor = color_a + color_b;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/crossfade/crossfade.js\":\n/*!************************************************!*\\\n  !*** ./src/Definitions/crossfade/crossfade.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_26068__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _crossfade = __nested_webpack_require_26068__(/*! ./crossfade.vert */ \"./src/Definitions/crossfade/crossfade.vert\");\n\nvar _crossfade2 = _interopRequireDefault(_crossfade);\n\nvar _crossfade3 = __nested_webpack_require_26068__(/*! ./crossfade.frag */ \"./src/Definitions/crossfade/crossfade.frag\");\n\nvar _crossfade4 = _interopRequireDefault(_crossfade3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar crossfade = {\n    title: \"Cross-Fade\",\n    description: \"A cross-fade effect. Typically used as a transistion.\",\n    vertexShader: _crossfade2.default,\n    fragmentShader: _crossfade4.default,\n    properties: {\n        mix: { type: \"uniform\", value: 0.0 }\n    },\n    inputs: [\"u_image_a\", \"u_image_b\"]\n};\n\nexports.default = crossfade;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/crossfade/crossfade.vert\":\n/*!**************************************************!*\\\n  !*** ./src/Definitions/crossfade/crossfade.vert ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/definitions.js\":\n/*!****************************************!*\\\n  !*** ./src/Definitions/definitions.js ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_27755__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _aaf_video_scale = __nested_webpack_require_27755__(/*! ./aaf_video_scale */ \"./src/Definitions/aaf_video_scale/aaf_video_scale.js\");\n\nvar _aaf_video_scale2 = _interopRequireDefault(_aaf_video_scale);\n\nvar _crossfade = __nested_webpack_require_27755__(/*! ./crossfade */ \"./src/Definitions/crossfade/crossfade.js\");\n\nvar _crossfade2 = _interopRequireDefault(_crossfade);\n\nvar _horizontalWipe = __nested_webpack_require_27755__(/*! ./horizontalWipe */ \"./src/Definitions/horizontalWipe/horizontalWipe.js\");\n\nvar _horizontalWipe2 = _interopRequireDefault(_horizontalWipe);\n\nvar _verticalWipe = __nested_webpack_require_27755__(/*! ./verticalWipe */ \"./src/Definitions/verticalWipe/verticalWipe.js\");\n\nvar _verticalWipe2 = _interopRequireDefault(_verticalWipe);\n\nvar _randomDissolve = __nested_webpack_require_27755__(/*! ./randomDissolve */ \"./src/Definitions/randomDissolve/randomDissolve.js\");\n\nvar _randomDissolve2 = _interopRequireDefault(_randomDissolve);\n\nvar _toColorAndBackFade = __nested_webpack_require_27755__(/*! ./toColorAndBackFade */ \"./src/Definitions/toColorAndBackFade/toColorAndBackFade.js\");\n\nvar _toColorAndBackFade2 = _interopRequireDefault(_toColorAndBackFade);\n\nvar _starWipe = __nested_webpack_require_27755__(/*! ./starWipe */ \"./src/Definitions/starWipe/starWipe.js\");\n\nvar _starWipe2 = _interopRequireDefault(_starWipe);\n\nvar _combine = __nested_webpack_require_27755__(/*! ./combine */ \"./src/Definitions/combine/combine.js\");\n\nvar _combine2 = _interopRequireDefault(_combine);\n\nvar _colorThreshold = __nested_webpack_require_27755__(/*! ./colorThreshold */ \"./src/Definitions/colorThreshold/colorThreshold.js\");\n\nvar _colorThreshold2 = _interopRequireDefault(_colorThreshold);\n\nvar _monochrome = __nested_webpack_require_27755__(/*! ./monochrome */ \"./src/Definitions/monochrome/monochrome.js\");\n\nvar _monochrome2 = _interopRequireDefault(_monochrome);\n\nvar _horizontalBlur = __nested_webpack_require_27755__(/*! ./horizontalBlur */ \"./src/Definitions/horizontalBlur/horizontalBlur.js\");\n\nvar _horizontalBlur2 = _interopRequireDefault(_horizontalBlur);\n\nvar _verticalBlur = __nested_webpack_require_27755__(/*! ./verticalBlur */ \"./src/Definitions/verticalBlur/verticalBlur.js\");\n\nvar _verticalBlur2 = _interopRequireDefault(_verticalBlur);\n\nvar _aaf_video_flop = __nested_webpack_require_27755__(/*! ./aaf_video_flop */ \"./src/Definitions/aaf_video_flop/aaf_video_flop.js\");\n\nvar _aaf_video_flop2 = _interopRequireDefault(_aaf_video_flop);\n\nvar _aaf_video_flip = __nested_webpack_require_27755__(/*! ./aaf_video_flip */ \"./src/Definitions/aaf_video_flip/aaf_video_flip.js\");\n\nvar _aaf_video_flip2 = _interopRequireDefault(_aaf_video_flip);\n\nvar _aaf_video_position = __nested_webpack_require_27755__(/*! ./aaf_video_position */ \"./src/Definitions/aaf_video_position/aaf_video_position.js\");\n\nvar _aaf_video_position2 = _interopRequireDefault(_aaf_video_position);\n\nvar _aaf_video_crop = __nested_webpack_require_27755__(/*! ./aaf_video_crop */ \"./src/Definitions/aaf_video_crop/aaf_video_crop.js\");\n\nvar _aaf_video_crop2 = _interopRequireDefault(_aaf_video_crop);\n\nvar _staticDissolve = __nested_webpack_require_27755__(/*! ./staticDissolve */ \"./src/Definitions/staticDissolve/staticDissolve.js\");\n\nvar _staticDissolve2 = _interopRequireDefault(_staticDissolve);\n\nvar _staticEffect = __nested_webpack_require_27755__(/*! ./staticEffect */ \"./src/Definitions/staticEffect/staticEffect.js\");\n\nvar _staticEffect2 = _interopRequireDefault(_staticEffect);\n\nvar _dreamfade = __nested_webpack_require_27755__(/*! ./dreamfade */ \"./src/Definitions/dreamfade/dreamfade.js\");\n\nvar _dreamfade2 = _interopRequireDefault(_dreamfade);\n\nvar _opacity = __nested_webpack_require_27755__(/*! ./opacity */ \"./src/Definitions/opacity/opacity.js\");\n\nvar _opacity2 = _interopRequireDefault(_opacity);\n\nvar _crop = __nested_webpack_require_27755__(/*! ./crop */ \"./src/Definitions/crop/crop.js\");\n\nvar _crop2 = _interopRequireDefault(_crop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar DEFINITIONS = {\n    AAF_VIDEO_SCALE: _aaf_video_scale2.default,\n    CROSSFADE: _crossfade2.default,\n    DREAMFADE: _dreamfade2.default,\n    HORIZONTAL_WIPE: _horizontalWipe2.default,\n    VERTICAL_WIPE: _verticalWipe2.default,\n    RANDOM_DISSOLVE: _randomDissolve2.default,\n    STATIC_DISSOLVE: _staticDissolve2.default,\n    STATIC_EFFECT: _staticEffect2.default,\n    TO_COLOR_AND_BACK: _toColorAndBackFade2.default,\n    STAR_WIPE: _starWipe2.default,\n    COMBINE: _combine2.default,\n    COLORTHRESHOLD: _colorThreshold2.default,\n    MONOCHROME: _monochrome2.default,\n    HORIZONTAL_BLUR: _horizontalBlur2.default,\n    VERTICAL_BLUR: _verticalBlur2.default,\n    AAF_VIDEO_CROP: _aaf_video_crop2.default,\n    AAF_VIDEO_POSITION: _aaf_video_position2.default,\n    AAF_VIDEO_FLIP: _aaf_video_flip2.default,\n    AAF_VIDEO_FLOP: _aaf_video_flop2.default,\n    OPACITY: _opacity2.default,\n    CROP: _crop2.default\n};\n\nexports.default = DEFINITIONS;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/dreamfade/dreamfade.frag\":\n/*!**************************************************!*\\\n  !*** ./src/Definitions/dreamfade/dreamfade.frag ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image_a;\\nuniform sampler2D u_image_b;\\nuniform float mix;\\nvarying vec2 v_texCoord;\\nvarying float v_mix;\\nvoid main(){\\n    float wobble = 1.0 - abs((mix*2.0)-1.0);\\n    vec2 pos = vec2(v_texCoord[0] + ((sin(v_texCoord[1]*(10.0*wobble*3.14) + wobble*10.0)/13.0)), v_texCoord[1]);\\n    vec4 color_a = texture2D(u_image_a, pos);\\n    vec4 color_b = texture2D(u_image_b, pos);\\n    color_a[0] *= (1.0 - mix);\\n    color_a[1] *= (1.0 - mix);\\n    color_a[2] *= (1.0 - mix);\\n    color_a[3] *= (1.0 - mix);\\n    color_b[0] *= mix;\\n    color_b[1] *= mix;\\n    color_b[2] *= mix;\\n    color_b[3] *= mix;\\n    gl_FragColor = color_a + color_b;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/dreamfade/dreamfade.js\":\n/*!************************************************!*\\\n  !*** ./src/Definitions/dreamfade/dreamfade.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_33914__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _dreamfade = __nested_webpack_require_33914__(/*! ./dreamfade.vert */ \"./src/Definitions/dreamfade/dreamfade.vert\");\n\nvar _dreamfade2 = _interopRequireDefault(_dreamfade);\n\nvar _dreamfade3 = __nested_webpack_require_33914__(/*! ./dreamfade.frag */ \"./src/Definitions/dreamfade/dreamfade.frag\");\n\nvar _dreamfade4 = _interopRequireDefault(_dreamfade3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar dreamfade = {\n    title: \"Dream-Fade\",\n    description: \"A wobbly dream effect. Typically used as a transistion.\",\n    vertexShader: _dreamfade2.default,\n    fragmentShader: _dreamfade4.default,\n    properties: {\n        mix: { type: \"uniform\", value: 0.0 }\n    },\n    inputs: [\"u_image_a\", \"u_image_b\"]\n};\n\nexports.default = dreamfade;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/dreamfade/dreamfade.vert\":\n/*!**************************************************!*\\\n  !*** ./src/Definitions/dreamfade/dreamfade.vert ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/horizontalBlur/horizontalBlur.frag\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/horizontalBlur/horizontalBlur.frag ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texCoord;\\nvarying vec2 v_blurTexCoords[14];\\nvoid main(){\\n    gl_FragColor = vec4(0.0);\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 0])*0.0044299121055113265;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 1])*0.00895781211794;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 2])*0.0215963866053;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 3])*0.0443683338718;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 4])*0.0776744219933;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 5])*0.115876621105;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 6])*0.147308056121;\\n    gl_FragColor += texture2D(u_image, v_texCoord         )*0.159576912161;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 7])*0.147308056121;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 8])*0.115876621105;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 9])*0.0776744219933;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[10])*0.0443683338718;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[11])*0.0215963866053;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[12])*0.00895781211794;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[13])*0.0044299121055113265;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/horizontalBlur/horizontalBlur.js\":\n/*!**********************************************************!*\\\n  !*** ./src/Definitions/horizontalBlur/horizontalBlur.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_37375__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _horizontalBlur = __nested_webpack_require_37375__(/*! ./horizontalBlur.vert */ \"./src/Definitions/horizontalBlur/horizontalBlur.vert\");\n\nvar _horizontalBlur2 = _interopRequireDefault(_horizontalBlur);\n\nvar _horizontalBlur3 = __nested_webpack_require_37375__(/*! ./horizontalBlur.frag */ \"./src/Definitions/horizontalBlur/horizontalBlur.frag\");\n\nvar _horizontalBlur4 = _interopRequireDefault(_horizontalBlur3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar horizontal_blur = {\n    title: \"Horizontal Blur\",\n    description: \"A horizontal blur effect. Adpated from http://xissburg.com/faster-gaussian-blur-in-glsl/\",\n    vertexShader: _horizontalBlur2.default,\n    fragmentShader: _horizontalBlur4.default,\n    properties: {\n        blurAmount: { type: \"uniform\", value: 1.0 }\n    },\n    inputs: [\"u_image\"]\n};\n\nexports.default = horizontal_blur;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/horizontalBlur/horizontalBlur.vert\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/horizontalBlur/horizontalBlur.vert ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nuniform float blurAmount;\\nvarying vec2 v_texCoord;\\nvarying vec2 v_blurTexCoords[14];\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n    v_blurTexCoords[ 0] = v_texCoord + vec2(-0.028 * blurAmount, 0.0);\\n    v_blurTexCoords[ 1] = v_texCoord + vec2(-0.024 * blurAmount, 0.0);\\n    v_blurTexCoords[ 2] = v_texCoord + vec2(-0.020 * blurAmount, 0.0);\\n    v_blurTexCoords[ 3] = v_texCoord + vec2(-0.016 * blurAmount, 0.0);\\n    v_blurTexCoords[ 4] = v_texCoord + vec2(-0.012 * blurAmount, 0.0);\\n    v_blurTexCoords[ 5] = v_texCoord + vec2(-0.008 * blurAmount, 0.0);\\n    v_blurTexCoords[ 6] = v_texCoord + vec2(-0.004 * blurAmount, 0.0);\\n    v_blurTexCoords[ 7] = v_texCoord + vec2( 0.004 * blurAmount, 0.0);\\n    v_blurTexCoords[ 8] = v_texCoord + vec2( 0.008 * blurAmount, 0.0);\\n    v_blurTexCoords[ 9] = v_texCoord + vec2( 0.012 * blurAmount, 0.0);\\n    v_blurTexCoords[10] = v_texCoord + vec2( 0.016 * blurAmount, 0.0);\\n    v_blurTexCoords[11] = v_texCoord + vec2( 0.020 * blurAmount, 0.0);\\n    v_blurTexCoords[12] = v_texCoord + vec2( 0.024 * blurAmount, 0.0);\\n    v_blurTexCoords[13] = v_texCoord + vec2( 0.028 * blurAmount, 0.0);\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/horizontalWipe/horizontalWipe.frag\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/horizontalWipe/horizontalWipe.frag ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image_a;\\nuniform sampler2D u_image_b;\\nuniform float mix;\\nvarying vec2 v_texCoord;\\nvarying float v_mix;\\nvoid main(){\\n    vec4 color_a = texture2D(u_image_a, v_texCoord);\\n    vec4 color_b = texture2D(u_image_b, v_texCoord);\\n    if (v_texCoord[0] > mix){\\n        gl_FragColor = color_a;\\n    } else {\\n        gl_FragColor = color_b;\\n    }\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/horizontalWipe/horizontalWipe.js\":\n/*!**********************************************************!*\\\n  !*** ./src/Definitions/horizontalWipe/horizontalWipe.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_41113__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _horizontalWipe = __nested_webpack_require_41113__(/*! ./horizontalWipe.vert */ \"./src/Definitions/horizontalWipe/horizontalWipe.vert\");\n\nvar _horizontalWipe2 = _interopRequireDefault(_horizontalWipe);\n\nvar _horizontalWipe3 = __nested_webpack_require_41113__(/*! ./horizontalWipe.frag */ \"./src/Definitions/horizontalWipe/horizontalWipe.frag\");\n\nvar _horizontalWipe4 = _interopRequireDefault(_horizontalWipe3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar horizontal_wipe = {\n    title: \"Horizontal Wipe\",\n    description: \"A horizontal wipe effect. Typically used as a transistion.\",\n    vertexShader: _horizontalWipe2.default,\n    fragmentShader: _horizontalWipe4.default,\n    properties: {\n        mix: { type: \"uniform\", value: 0.0 }\n    },\n    inputs: [\"u_image_a\", \"u_image_b\"]\n};\n\nexports.default = horizontal_wipe;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/horizontalWipe/horizontalWipe.vert\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/horizontalWipe/horizontalWipe.vert ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/monochrome/monochrome.frag\":\n/*!****************************************************!*\\\n  !*** ./src/Definitions/monochrome/monochrome.frag ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nuniform vec3 inputMix;\\nuniform vec3 outputMix;\\nvarying vec2 v_texCoord;\\nvarying float v_mix;\\nvoid main(){\\n    vec4 color = texture2D(u_image, v_texCoord);\\n    float mono = color[0]*inputMix[0] + color[1]*inputMix[1] + color[2]*inputMix[2];\\n    color[0] = mono * outputMix[0];\\n    color[1] = mono * outputMix[1];\\n    color[2] = mono * outputMix[2];\\n    gl_FragColor = color;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/monochrome/monochrome.js\":\n/*!**************************************************!*\\\n  !*** ./src/Definitions/monochrome/monochrome.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_43740__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _monochrome = __nested_webpack_require_43740__(/*! ./monochrome.vert */ \"./src/Definitions/monochrome/monochrome.vert\");\n\nvar _monochrome2 = _interopRequireDefault(_monochrome);\n\nvar _monochrome3 = __nested_webpack_require_43740__(/*! ./monochrome.frag */ \"./src/Definitions/monochrome/monochrome.frag\");\n\nvar _monochrome4 = _interopRequireDefault(_monochrome3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar monochrome = {\n    title: \"Monochrome\",\n    description: \"Change images to a single chroma (e.g can be used to make a black & white filter). Input color mix and output color mix can be adjusted.\",\n    vertexShader: _monochrome2.default,\n    fragmentShader: _monochrome4.default,\n    properties: {\n        inputMix: { type: \"uniform\", value: [0.4, 0.6, 0.2] },\n        outputMix: { type: \"uniform\", value: [1.0, 1.0, 1.0] }\n    },\n    inputs: [\"u_image\"]\n};\n\nexports.default = monochrome;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/monochrome/monochrome.vert\":\n/*!****************************************************!*\\\n  !*** ./src/Definitions/monochrome/monochrome.vert ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/opacity/opacity.frag\":\n/*!**********************************************!*\\\n  !*** ./src/Definitions/opacity/opacity.frag ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nuniform float opacity;\\nvarying vec2 v_texCoord;\\nvarying float v_opacity;\\nvoid main(){\\n    vec4 color = texture2D(u_image, v_texCoord);\\n    color[3] *= opacity;\\n    gl_FragColor = color;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/opacity/opacity.js\":\n/*!********************************************!*\\\n  !*** ./src/Definitions/opacity/opacity.js ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_46168__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _opacity = __nested_webpack_require_46168__(/*! ./opacity.vert */ \"./src/Definitions/opacity/opacity.vert\");\n\nvar _opacity2 = _interopRequireDefault(_opacity);\n\nvar _opacity3 = __nested_webpack_require_46168__(/*! ./opacity.frag */ \"./src/Definitions/opacity/opacity.frag\");\n\nvar _opacity4 = _interopRequireDefault(_opacity3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar opacity = {\n    title: \"Opacity\",\n    description: \"Sets the opacity of an input.\",\n    vertexShader: _opacity2.default,\n    fragmentShader: _opacity4.default,\n    properties: {\n        opacity: { type: \"uniform\", value: 0.7 }\n    },\n    inputs: [\"u_image\"]\n};\n\nexports.default = opacity;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/opacity/opacity.vert\":\n/*!**********************************************!*\\\n  !*** ./src/Definitions/opacity/opacity.vert ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/randomDissolve/randomDissolve.frag\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/randomDissolve/randomDissolve.frag ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image_a;\\nuniform sampler2D u_image_b;\\nuniform float mix;\\nvarying vec2 v_texCoord;\\nvarying float v_mix;\\nfloat rand(vec2 co){\\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\\n}\\nvoid main(){\\n    vec4 color_a = texture2D(u_image_a, v_texCoord);\\n    vec4 color_b = texture2D(u_image_b, v_texCoord);\\n    if (clamp(rand(v_texCoord),  0.01, 1.001) > mix){\\n        gl_FragColor = color_a;\\n    } else {\\n        gl_FragColor = color_b;\\n    }\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/randomDissolve/randomDissolve.js\":\n/*!**********************************************************!*\\\n  !*** ./src/Definitions/randomDissolve/randomDissolve.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_48716__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _randomDissolve = __nested_webpack_require_48716__(/*! ./randomDissolve.vert */ \"./src/Definitions/randomDissolve/randomDissolve.vert\");\n\nvar _randomDissolve2 = _interopRequireDefault(_randomDissolve);\n\nvar _randomDissolve3 = __nested_webpack_require_48716__(/*! ./randomDissolve.frag */ \"./src/Definitions/randomDissolve/randomDissolve.frag\");\n\nvar _randomDissolve4 = _interopRequireDefault(_randomDissolve3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar randomDissolve = {\n    title: \"Random Dissolve\",\n    description: \"A random dissolve effect. Typically used as a transistion.\",\n    vertexShader: _randomDissolve2.default,\n    fragmentShader: _randomDissolve4.default,\n    properties: {\n        mix: { type: \"uniform\", value: 0.0 }\n    },\n    inputs: [\"u_image_a\", \"u_image_b\"]\n};\n\nexports.default = randomDissolve;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/randomDissolve/randomDissolve.vert\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/randomDissolve/randomDissolve.vert ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/starWipe/starWipe.frag\":\n/*!************************************************!*\\\n  !*** ./src/Definitions/starWipe/starWipe.frag ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image_a;\\nuniform sampler2D u_image_b;\\nuniform float mix;\\nvarying vec2 v_texCoord;\\nvarying float v_mix;\\nfloat sign (vec2 p1, vec2 p2, vec2 p3){\\n    return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1]);\\n}\\nbool pointInTriangle(vec2 pt, vec2 v1, vec2 v2, vec2 v3){\\n    bool b1, b2, b3;\\n    b1 = sign(pt, v1, v2) < 0.0;\\n    b2 = sign(pt, v2, v3) < 0.0;\\n    b3 = sign(pt, v3, v1) < 0.0;\\n    return ((b1 == b2) && (b2 == b3));\\n}\\nvec2 rotatePointAboutPoint(vec2 point, vec2 pivot, float angle){\\n    float s = sin(angle);\\n    float c = cos(angle);\\n    float x = point[0] - pivot[0];\\n    float y = point[1] - pivot[1];\\n    float new_x = x * c - y * s;\\n    float new_y = x * s + y * c;\\n    return vec2(new_x + pivot[0], new_y+pivot[1]);\\n}\\n\\nvoid main(){\\n    vec4 color_a = texture2D(u_image_b, v_texCoord);\\n    vec4 color_b = texture2D(u_image_a, v_texCoord);\\n    vec2 t0_p0,t0_p1,t0_p2,t1_p0,t1_p1,t1_p2,t2_p0,t2_p1,t2_p2,t3_p0,t3_p1,t3_p2;\\n    vec2 t4_p0,t4_p1,t4_p2,t5_p0,t5_p1,t5_p2,t6_p0,t6_p1,t6_p2,t7_p0,t7_p1,t7_p2;\\n\\n\\n    t0_p0 = vec2(0.0, 0.25) * clamp(mix,0.0,1.0) * 2.0 + vec2(0.5,0.5);\\n    t0_p1 = vec2(0.0, -0.25) * clamp(mix,0.0,1.0) * 2.0 + vec2(0.5,0.5);\\n    t0_p2 = vec2(1.0, 0.0) * clamp(mix,0.0,1.0) * 2.0 + vec2(0.5,0.5);\\n\\n    t1_p0 = rotatePointAboutPoint(t0_p0, vec2(0.5,0.5), 0.7854);\\n    t1_p1 = rotatePointAboutPoint(t0_p1, vec2(0.5,0.5), 0.7854);\\n    t1_p2 = rotatePointAboutPoint(t0_p2, vec2(0.5,0.5), 0.7854);\\n\\n    t2_p0 = rotatePointAboutPoint(t0_p0, vec2(0.5,0.5), 0.7854 * 2.0);\\n    t2_p1 = rotatePointAboutPoint(t0_p1, vec2(0.5,0.5), 0.7854 * 2.0);\\n    t2_p2 = rotatePointAboutPoint(t0_p2, vec2(0.5,0.5), 0.7854 * 2.0);\\n\\n    t3_p0 = rotatePointAboutPoint(t0_p0, vec2(0.5,0.5), 0.7854 * 3.0);\\n    t3_p1 = rotatePointAboutPoint(t0_p1, vec2(0.5,0.5), 0.7854 * 3.0);\\n    t3_p2 = rotatePointAboutPoint(t0_p2, vec2(0.5,0.5), 0.7854 * 3.0);\\n\\n    t4_p0 = rotatePointAboutPoint(t0_p0, vec2(0.5,0.5), 0.7854 * 4.0);\\n    t4_p1 = rotatePointAboutPoint(t0_p1, vec2(0.5,0.5), 0.7854 * 4.0);\\n    t4_p2 = rotatePointAboutPoint(t0_p2, vec2(0.5,0.5), 0.7854 * 4.0);\\n\\n    t5_p0 = rotatePointAboutPoint(t0_p0, vec2(0.5,0.5), 0.7854 * 5.0);\\n    t5_p1 = rotatePointAboutPoint(t0_p1, vec2(0.5,0.5), 0.7854 * 5.0);\\n    t5_p2 = rotatePointAboutPoint(t0_p2, vec2(0.5,0.5), 0.7854 * 5.0);\\n\\n    t6_p0 = rotatePointAboutPoint(t0_p0, vec2(0.5,0.5), 0.7854 * 6.0);\\n    t6_p1 = rotatePointAboutPoint(t0_p1, vec2(0.5,0.5), 0.7854 * 6.0);\\n    t6_p2 = rotatePointAboutPoint(t0_p2, vec2(0.5,0.5), 0.7854 * 6.0);\\n\\n    t7_p0 = rotatePointAboutPoint(t0_p0, vec2(0.5,0.5), 0.7854 * 7.0);\\n    t7_p1 = rotatePointAboutPoint(t0_p1, vec2(0.5,0.5), 0.7854 * 7.0);\\n    t7_p2 = rotatePointAboutPoint(t0_p2, vec2(0.5,0.5), 0.7854 * 7.0);\\n\\n    if(mix > 0.99){\\n        gl_FragColor = color_a;\\n        return;\\n    }\\n    if(mix < 0.01){\\n        gl_FragColor = color_b;\\n        return;\\n    }\\n    if(pointInTriangle(v_texCoord, t0_p0, t0_p1, t0_p2) || pointInTriangle(v_texCoord, t1_p0, t1_p1, t1_p2) || pointInTriangle(v_texCoord, t2_p0, t2_p1, t2_p2) || pointInTriangle(v_texCoord, t3_p0, t3_p1, t3_p2) || pointInTriangle(v_texCoord, t4_p0, t4_p1, t4_p2) || pointInTriangle(v_texCoord, t5_p0, t5_p1, t5_p2) || pointInTriangle(v_texCoord, t6_p0, t6_p1, t6_p2) || pointInTriangle(v_texCoord, t7_p0, t7_p1, t7_p2)){\\n        gl_FragColor = color_a;\\n    } else {\\n        gl_FragColor = color_b;\\n    }\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/starWipe/starWipe.js\":\n/*!**********************************************!*\\\n  !*** ./src/Definitions/starWipe/starWipe.js ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_54381__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _starWipe = __nested_webpack_require_54381__(/*! ./starWipe.vert */ \"./src/Definitions/starWipe/starWipe.vert\");\n\nvar _starWipe2 = _interopRequireDefault(_starWipe);\n\nvar _starWipe3 = __nested_webpack_require_54381__(/*! ./starWipe.frag */ \"./src/Definitions/starWipe/starWipe.frag\");\n\nvar _starWipe4 = _interopRequireDefault(_starWipe3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar starWipe = {\n    title: \"Star Wipe Fade\",\n    description: \"A classic star wipe transistion. Typically used as a transistion.\",\n    vertexShader: _starWipe2.default,\n    fragmentShader: _starWipe4.default,\n    properties: {\n        mix: { type: \"uniform\", value: 1.0 }\n    },\n    inputs: [\"u_image_a\", \"u_image_b\"]\n};\n\nexports.default = starWipe;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/starWipe/starWipe.vert\":\n/*!************************************************!*\\\n  !*** ./src/Definitions/starWipe/starWipe.vert ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/staticDissolve/staticDissolve.frag\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/staticDissolve/staticDissolve.frag ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image_a;\\nuniform sampler2D u_image_b;\\nuniform float mix;\\nuniform float currentTime;\\nvarying vec2 v_texCoord;\\nvarying float v_mix;\\nfloat rand(vec2 co, float currentTime){\\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))+currentTime) * 43758.5453);\\n}\\nvoid main(){\\n    vec4 color_a = texture2D(u_image_a, v_texCoord);\\n    vec4 color_b = texture2D(u_image_b, v_texCoord);\\n    if (clamp(rand(v_texCoord, currentTime),  0.01, 1.001) > mix){\\n        gl_FragColor = color_a;\\n    } else {\\n        gl_FragColor = color_b;\\n    }\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/staticDissolve/staticDissolve.js\":\n/*!**********************************************************!*\\\n  !*** ./src/Definitions/staticDissolve/staticDissolve.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_57078__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _staticDissolve = __nested_webpack_require_57078__(/*! ./staticDissolve.vert */ \"./src/Definitions/staticDissolve/staticDissolve.vert\");\n\nvar _staticDissolve2 = _interopRequireDefault(_staticDissolve);\n\nvar _staticDissolve3 = __nested_webpack_require_57078__(/*! ./staticDissolve.frag */ \"./src/Definitions/staticDissolve/staticDissolve.frag\");\n\nvar _staticDissolve4 = _interopRequireDefault(_staticDissolve3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar staticDissolve = {\n    title: \"Static Dissolve\",\n    description: \"A static dissolve effect. Typically used as a transistion.\",\n    vertexShader: _staticDissolve2.default,\n    fragmentShader: _staticDissolve4.default,\n    properties: {\n        mix: { type: \"uniform\", value: 0.0 }\n    },\n    inputs: [\"u_image_a\", \"u_image_b\"]\n};\n\nexports.default = staticDissolve;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/staticDissolve/staticDissolve.vert\":\n/*!************************************************************!*\\\n  !*** ./src/Definitions/staticDissolve/staticDissolve.vert ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/staticEffect/staticEffect.frag\":\n/*!********************************************************!*\\\n  !*** ./src/Definitions/staticEffect/staticEffect.frag ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nuniform float currentTime;\\nuniform float amount;\\nvarying vec2 v_texCoord;\\nuniform vec3 weight;\\nfloat rand(vec2 co, float currentTime){\\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))+currentTime) * 43758.5453);\\n}\\nvoid main(){\\n    vec4 color = texture2D(u_image, v_texCoord);\\n    color[0] = color[0] + (2.0*(clamp(rand(v_texCoord, currentTime),  0.01, 1.001)-0.5)) * weight[0] * amount;\\n    color[1] = color[1] + (2.0*(clamp(rand(v_texCoord, currentTime),  0.01, 1.001)-0.5)) * weight[1] * amount;\\n    color[2] = color[2] + (2.0*(clamp(rand(v_texCoord, currentTime),  0.01, 1.001)-0.5)) * weight[2] *amount;\\n    gl_FragColor = color;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/staticEffect/staticEffect.js\":\n/*!******************************************************!*\\\n  !*** ./src/Definitions/staticEffect/staticEffect.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_60001__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _staticEffect = __nested_webpack_require_60001__(/*! ./staticEffect.vert */ \"./src/Definitions/staticEffect/staticEffect.vert\");\n\nvar _staticEffect2 = _interopRequireDefault(_staticEffect);\n\nvar _staticEffect3 = __nested_webpack_require_60001__(/*! ./staticEffect.frag */ \"./src/Definitions/staticEffect/staticEffect.frag\");\n\nvar _staticEffect4 = _interopRequireDefault(_staticEffect3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar staticEffect = {\n    title: \"Static\",\n    description: \"A static effect to add pseudo random noise to a video\",\n    vertexShader: _staticEffect2.default,\n    fragmentShader: _staticEffect4.default,\n    properties: {\n        weight: { type: \"uniform\", value: [1.0, 1.0, 1.0] },\n        amount: { type: \"uniform\", value: 1.0 }\n    },\n    inputs: [\"u_image\"]\n};\n\nexports.default = staticEffect;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/staticEffect/staticEffect.vert\":\n/*!********************************************************!*\\\n  !*** ./src/Definitions/staticEffect/staticEffect.vert ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/toColorAndBackFade/toColorAndBackFade.frag\":\n/*!********************************************************************!*\\\n  !*** ./src/Definitions/toColorAndBackFade/toColorAndBackFade.frag ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image_a;\\nuniform sampler2D u_image_b;\\nuniform float mix;\\nuniform vec4 color;\\nvarying vec2 v_texCoord;\\nvarying float v_mix;\\nvoid main(){\\n    vec4 color_a = texture2D(u_image_a, v_texCoord);\\n    vec4 color_b = texture2D(u_image_b, v_texCoord);\\n    float mix_amount = (mix *2.0) - 1.0;\\n    if(mix_amount < 0.0){\\n        gl_FragColor = abs(mix_amount) * color_a + (1.0 - abs(mix_amount)) * color;\\n    } else {\\n        gl_FragColor = mix_amount * color_b + (1.0 - mix_amount) * color;\\n    }\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/toColorAndBackFade/toColorAndBackFade.js\":\n/*!******************************************************************!*\\\n  !*** ./src/Definitions/toColorAndBackFade/toColorAndBackFade.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_62849__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _toColorAndBackFade = __nested_webpack_require_62849__(/*! ./toColorAndBackFade.vert */ \"./src/Definitions/toColorAndBackFade/toColorAndBackFade.vert\");\n\nvar _toColorAndBackFade2 = _interopRequireDefault(_toColorAndBackFade);\n\nvar _toColorAndBackFade3 = __nested_webpack_require_62849__(/*! ./toColorAndBackFade.frag */ \"./src/Definitions/toColorAndBackFade/toColorAndBackFade.frag\");\n\nvar _toColorAndBackFade4 = _interopRequireDefault(_toColorAndBackFade3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar toColorAndBackFade = {\n    title: \"To Color And Back Fade\",\n    description: \"A fade to black and back effect. Setting mix to 0.5 is a fully solid color frame. Typically used as a transistion.\",\n    vertexShader: _toColorAndBackFade2.default,\n    fragmentShader: _toColorAndBackFade4.default,\n    properties: {\n        mix: { type: \"uniform\", value: 0.0 },\n        color: { type: \"uniform\", value: [0.0, 0.0, 0.0, 0.0] }\n    },\n    inputs: [\"u_image_a\", \"u_image_b\"]\n};\nexports.default = toColorAndBackFade;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/toColorAndBackFade/toColorAndBackFade.vert\":\n/*!********************************************************************!*\\\n  !*** ./src/Definitions/toColorAndBackFade/toColorAndBackFade.vert ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/verticalBlur/verticalBlur.frag\":\n/*!********************************************************!*\\\n  !*** ./src/Definitions/verticalBlur/verticalBlur.frag ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texCoord;\\nvarying vec2 v_blurTexCoords[14];\\nvoid main(){\\n    gl_FragColor = vec4(0.0);\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 0])*0.0044299121055113265;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 1])*0.00895781211794;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 2])*0.0215963866053;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 3])*0.0443683338718;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 4])*0.0776744219933;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 5])*0.115876621105;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 6])*0.147308056121;\\n    gl_FragColor += texture2D(u_image, v_texCoord         )*0.159576912161;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 7])*0.147308056121;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 8])*0.115876621105;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[ 9])*0.0776744219933;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[10])*0.0443683338718;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[11])*0.0215963866053;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[12])*0.00895781211794;\\n    gl_FragColor += texture2D(u_image, v_blurTexCoords[13])*0.0044299121055113265;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/verticalBlur/verticalBlur.js\":\n/*!******************************************************!*\\\n  !*** ./src/Definitions/verticalBlur/verticalBlur.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_66629__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _verticalBlur = __nested_webpack_require_66629__(/*! ./verticalBlur.vert */ \"./src/Definitions/verticalBlur/verticalBlur.vert\");\n\nvar _verticalBlur2 = _interopRequireDefault(_verticalBlur);\n\nvar _verticalBlur3 = __nested_webpack_require_66629__(/*! ./verticalBlur.frag */ \"./src/Definitions/verticalBlur/verticalBlur.frag\");\n\nvar _verticalBlur4 = _interopRequireDefault(_verticalBlur3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar verticalBlur = {\n    title: \"Vertical Blur\",\n    description: \"A vertical blur effect. Adpated from http://xissburg.com/faster-gaussian-blur-in-glsl/\",\n    vertexShader: _verticalBlur2.default,\n    fragmentShader: _verticalBlur4.default,\n    properties: {\n        blurAmount: { type: \"uniform\", value: 1.0 }\n    },\n    inputs: [\"u_image\"]\n};\n\nexports.default = verticalBlur;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/verticalBlur/verticalBlur.vert\":\n/*!********************************************************!*\\\n  !*** ./src/Definitions/verticalBlur/verticalBlur.vert ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nuniform float blurAmount;\\nvarying vec2 v_blurTexCoords[14];\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n    v_blurTexCoords[ 0] = v_texCoord + vec2(0.0,-0.028 * blurAmount);\\n    v_blurTexCoords[ 1] = v_texCoord + vec2(0.0,-0.024 * blurAmount);\\n    v_blurTexCoords[ 2] = v_texCoord + vec2(0.0,-0.020 * blurAmount);\\n    v_blurTexCoords[ 3] = v_texCoord + vec2(0.0,-0.016 * blurAmount);\\n    v_blurTexCoords[ 4] = v_texCoord + vec2(0.0,-0.012 * blurAmount);\\n    v_blurTexCoords[ 5] = v_texCoord + vec2(0.0,-0.008 * blurAmount);\\n    v_blurTexCoords[ 6] = v_texCoord + vec2(0.0,-0.004 * blurAmount);\\n    v_blurTexCoords[ 7] = v_texCoord + vec2(0.0, 0.004 * blurAmount);\\n    v_blurTexCoords[ 8] = v_texCoord + vec2(0.0, 0.008 * blurAmount);\\n    v_blurTexCoords[ 9] = v_texCoord + vec2(0.0, 0.012 * blurAmount);\\n    v_blurTexCoords[10] = v_texCoord + vec2(0.0, 0.016 * blurAmount);\\n    v_blurTexCoords[11] = v_texCoord + vec2(0.0, 0.020 * blurAmount);\\n    v_blurTexCoords[12] = v_texCoord + vec2(0.0, 0.024 * blurAmount);\\n    v_blurTexCoords[13] = v_texCoord + vec2(0.0, 0.028 * blurAmount);\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/verticalWipe/verticalWipe.frag\":\n/*!********************************************************!*\\\n  !*** ./src/Definitions/verticalWipe/verticalWipe.frag ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image_a;\\nuniform sampler2D u_image_b;\\nuniform float mix;\\nvarying vec2 v_texCoord;\\nvarying float v_mix;\\nvoid main(){\\n    vec4 color_a = texture2D(u_image_a, v_texCoord);\\n    vec4 color_b = texture2D(u_image_b, v_texCoord);\\n    if (v_texCoord[1] > mix){\\n        gl_FragColor = color_a;\\n    } else {\\n        gl_FragColor = color_b;\\n    }\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/Definitions/verticalWipe/verticalWipe.js\":\n/*!******************************************************!*\\\n  !*** ./src/Definitions/verticalWipe/verticalWipe.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_70267__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _verticalWipe = __nested_webpack_require_70267__(/*! ./verticalWipe.vert */ \"./src/Definitions/verticalWipe/verticalWipe.vert\");\n\nvar _verticalWipe2 = _interopRequireDefault(_verticalWipe);\n\nvar _verticalWipe3 = __nested_webpack_require_70267__(/*! ./verticalWipe.frag */ \"./src/Definitions/verticalWipe/verticalWipe.frag\");\n\nvar _verticalWipe4 = _interopRequireDefault(_verticalWipe3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar verticalWipe = {\n    title: \"vertical Wipe\",\n    description: \"A vertical wipe effect. Typically used as a transistion.\",\n    vertexShader: _verticalWipe2.default,\n    fragmentShader: _verticalWipe4.default,\n    properties: {\n        mix: { type: \"uniform\", value: 0.0 }\n    },\n    inputs: [\"u_image_a\", \"u_image_b\"]\n};\n\nexports.default = verticalWipe;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/Definitions/verticalWipe/verticalWipe.vert\":\n/*!********************************************************!*\\\n  !*** ./src/Definitions/verticalWipe/verticalWipe.vert ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/DestinationNode/destinationnode.frag\":\n/*!**************************************************!*\\\n  !*** ./src/DestinationNode/destinationnode.frag ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texCoord;\\nvarying float v_progress;\\nvoid main(){\\n    gl_FragColor = texture2D(u_image, v_texCoord);\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/DestinationNode/destinationnode.js\":\n/*!************************************************!*\\\n  !*** ./src/DestinationNode/destinationnode.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_72558__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.DESTINATIONTYPE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _processingnode = __nested_webpack_require_72558__(/*! ../ProcessingNodes/processingnode */ \"./src/ProcessingNodes/processingnode.js\");\n\nvar _processingnode2 = _interopRequireDefault(_processingnode);\n\nvar _destinationnode = __nested_webpack_require_72558__(/*! ./destinationnode.frag */ \"./src/DestinationNode/destinationnode.frag\");\n\nvar _destinationnode2 = _interopRequireDefault(_destinationnode);\n\nvar _destinationnode3 = __nested_webpack_require_72558__(/*! ./destinationnode.vert */ \"./src/DestinationNode/destinationnode.vert\");\n\nvar _destinationnode4 = _interopRequireDefault(_destinationnode3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nvar TYPE = \"DestinationNode\";\n\nvar DestinationNode = function (_ProcessingNode) {\n    _inherits(DestinationNode, _ProcessingNode);\n\n    /**\n     * Initialise an instance of a DestinationNode.\n     *\n     * There should only be a single instance of a DestinationNode per VideoContext instance. An VideoContext's destination can be accessed like so: videoContext.desitnation.\n     *\n     * You should not instantiate this directly.\n     */\n    function DestinationNode(gl, renderGraph) {\n        _classCallCheck(this, DestinationNode);\n\n        var definition = {\n            fragmentShader: _destinationnode2.default,\n            vertexShader: _destinationnode4.default,\n            properties: {},\n            inputs: [\"u_image\"]\n        };\n\n        var _this = _possibleConstructorReturn(this, (DestinationNode.__proto__ || Object.getPrototypeOf(DestinationNode)).call(this, gl, renderGraph, definition, definition.inputs, false));\n\n        _this._displayName = TYPE;\n        return _this;\n    }\n\n    _createClass(DestinationNode, [{\n        key: \"_render\",\n        value: function _render() {\n            var _this2 = this;\n\n            var gl = this._gl;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n            gl.clearColor(0, 0, 0, 0.0); // green;\n            gl.clear(gl.COLOR_BUFFER_BIT);\n\n            this.inputs.forEach(function (node) {\n                _get(DestinationNode.prototype.__proto__ || Object.getPrototypeOf(DestinationNode.prototype), \"_render\", _this2).call(_this2);\n                //map the input textures input the node\n                var texture = node._texture;\n\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = _this2._shaderInputsTextureUnitMapping[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var mapping = _step.value;\n\n                        gl.activeTexture(mapping.textureUnit);\n                        gl.uniform1i(mapping.location, mapping.textureUnitIndex);\n                        gl.bindTexture(gl.TEXTURE_2D, texture);\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                gl.drawArrays(gl.TRIANGLES, 0, 6);\n            });\n        }\n    }]);\n\n    return DestinationNode;\n}(_processingnode2.default);\n\nexports.DESTINATIONTYPE = TYPE;\nexports.default = DestinationNode;\n\n/***/ }),\n\n/***/ \"./src/DestinationNode/destinationnode.vert\":\n/*!**************************************************!*\\\n  !*** ./src/DestinationNode/destinationnode.vert ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nvarying vec2 v_texCoord;\\nvoid main() {\\n    gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\n    v_texCoord = a_texCoord;\\n}\\n\"\n\n/***/ }),\n\n/***/ \"./src/ProcessingNodes/compositingnode.js\":\n/*!************************************************!*\\\n  !*** ./src/ProcessingNodes/compositingnode.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_79283__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.COMPOSITINGTYPE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _processingnode = __nested_webpack_require_79283__(/*! ./processingnode */ \"./src/ProcessingNodes/processingnode.js\");\n\nvar _processingnode2 = _interopRequireDefault(_processingnode);\n\nvar _utils = __nested_webpack_require_79283__(/*! ../utils.js */ \"./src/utils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nvar TYPE = \"CompositingNode\";\n\nvar CompositingNode = function (_ProcessingNode) {\n    _inherits(CompositingNode, _ProcessingNode);\n\n    /**\n     * Initialise an instance of a Compositing Node. You should not instantiate this directly, but use VideoContest.createCompositingNode().\n     */\n    function CompositingNode(gl, renderGraph, definition) {\n        _classCallCheck(this, CompositingNode);\n\n        var placeholderTexture = (0, _utils.createElementTexture)(gl);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0]));\n\n        var _this = _possibleConstructorReturn(this, (CompositingNode.__proto__ || Object.getPrototypeOf(CompositingNode)).call(this, gl, renderGraph, definition, definition.inputs, false));\n\n        _this._placeholderTexture = placeholderTexture;\n        _this._displayName = TYPE;\n        return _this;\n    }\n\n    _createClass(CompositingNode, [{\n        key: \"_render\",\n        value: function _render() {\n            var _this2 = this;\n\n            var gl = this._gl;\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._texture, 0);\n            gl.clearColor(0, 0, 0, 0); // green;\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            this.inputs.forEach(function (node) {\n                if (node === undefined) return;\n                _get(CompositingNode.prototype.__proto__ || Object.getPrototypeOf(CompositingNode.prototype), \"_render\", _this2).call(_this2);\n\n                //map the input textures input the node\n                var texture = node._texture;\n\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = _this2._shaderInputsTextureUnitMapping[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var mapping = _step.value;\n\n                        gl.activeTexture(mapping.textureUnit);\n                        gl.uniform1i(mapping.location, mapping.textureUnitIndex);\n                        gl.bindTexture(gl.TEXTURE_2D, texture);\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                gl.drawArrays(gl.TRIANGLES, 0, 6);\n            });\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        }\n    }]);\n\n    return CompositingNode;\n}(_processingnode2.default);\n\nexports.COMPOSITINGTYPE = TYPE;\nexports.default = CompositingNode;\n\n/***/ }),\n\n/***/ \"./src/ProcessingNodes/effectnode.js\":\n/*!*******************************************!*\\\n  !*** ./src/ProcessingNodes/effectnode.js ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_85270__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.EFFECTYPE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _processingnode = __nested_webpack_require_85270__(/*! ./processingnode */ \"./src/ProcessingNodes/processingnode.js\");\n\nvar _processingnode2 = _interopRequireDefault(_processingnode);\n\nvar _utils = __nested_webpack_require_85270__(/*! ../utils.js */ \"./src/utils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nvar TYPE = \"EffectNode\";\n\nvar EffectNode = function (_ProcessingNode) {\n    _inherits(EffectNode, _ProcessingNode);\n\n    /**\n     * Initialise an instance of an EffectNode. You should not instantiate this directly, but use VideoContest.createEffectNode().\n     */\n    function EffectNode(gl, renderGraph, definition) {\n        _classCallCheck(this, EffectNode);\n\n        var placeholderTexture = (0, _utils.createElementTexture)(gl);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0]));\n\n        var _this = _possibleConstructorReturn(this, (EffectNode.__proto__ || Object.getPrototypeOf(EffectNode)).call(this, gl, renderGraph, definition, definition.inputs, true));\n\n        _this._placeholderTexture = placeholderTexture;\n        _this._displayName = TYPE;\n        return _this;\n    }\n\n    _createClass(EffectNode, [{\n        key: \"_render\",\n        value: function _render() {\n            var gl = this._gl;\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._texture, 0);\n            gl.clearColor(0, 0, 0, 0); // green;\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.blendFunc(gl.ONE, gl.ZERO);\n\n            _get(EffectNode.prototype.__proto__ || Object.getPrototypeOf(EffectNode.prototype), \"_render\", this).call(this);\n\n            var inputs = this._renderGraph.getInputsForNode(this);\n\n            for (var i = 0; i < this._shaderInputsTextureUnitMapping.length; i++) {\n                var inputTexture = this._placeholderTexture;\n                var textureUnit = this._shaderInputsTextureUnitMapping[i].textureUnit;\n                if (i < inputs.length && inputs[i] !== undefined) {\n                    inputTexture = inputs[i]._texture;\n                }\n\n                gl.activeTexture(textureUnit);\n                gl.uniform1i(this._shaderInputsTextureUnitMapping[i].location, this._shaderInputsTextureUnitMapping[i].textureUnitIndex);\n                gl.bindTexture(gl.TEXTURE_2D, inputTexture);\n            }\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        }\n    }]);\n\n    return EffectNode;\n}(_processingnode2.default);\n\nexports.EFFECTYPE = TYPE;\nexports.default = EffectNode;\n\n/***/ }),\n\n/***/ \"./src/ProcessingNodes/processingnode.js\":\n/*!***********************************************!*\\\n  !*** ./src/ProcessingNodes/processingnode.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_90384__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.PROCESSINGTYPE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _graphnode = __nested_webpack_require_90384__(/*! ../graphnode */ \"./src/graphnode.js\");\n\nvar _graphnode2 = _interopRequireDefault(_graphnode);\n\nvar _utils = __nested_webpack_require_90384__(/*! ../utils.js */ \"./src/utils.js\");\n\nvar _exceptions = __nested_webpack_require_90384__(/*! ../exceptions.js */ \"./src/exceptions.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nvar TYPE = \"ProcessingNode\";\n\nvar ProcessingNode = function (_GraphNode) {\n    _inherits(ProcessingNode, _GraphNode);\n\n    /**\n     * Initialise an instance of a ProcessingNode.\n     *\n     * This class is not used directly, but is extended to create CompositingNodes, TransitionNodes, and EffectNodes.\n     */\n    function ProcessingNode(gl, renderGraph, definition, inputNames, limitConnections) {\n        _classCallCheck(this, ProcessingNode);\n\n        var _this = _possibleConstructorReturn(this, (ProcessingNode.__proto__ || Object.getPrototypeOf(ProcessingNode)).call(this, gl, renderGraph, inputNames, limitConnections));\n\n        _this._vertexShader = (0, _utils.compileShader)(gl, definition.vertexShader, gl.VERTEX_SHADER);\n        _this._fragmentShader = (0, _utils.compileShader)(gl, definition.fragmentShader, gl.FRAGMENT_SHADER);\n        _this._definition = definition;\n        _this._properties = {}; //definition.properties;\n        //copy definition properties\n        for (var propertyName in definition.properties) {\n            var propertyValue = definition.properties[propertyName].value;\n            //if an array then shallow copy it\n            if (Object.prototype.toString.call(propertyValue) === \"[object Array]\") {\n                propertyValue = definition.properties[propertyName].value.slice();\n            }\n            var propertyType = definition.properties[propertyName].type;\n            _this._properties[propertyName] = {\n                type: propertyType,\n                value: propertyValue\n            };\n        }\n\n        _this._shaderInputsTextureUnitMapping = [];\n        _this._maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n        _this._boundTextureUnits = 0;\n        _this._texture = (0, _utils.createElementTexture)(gl);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.canvas.width, gl.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        //compile the shader\n        _this._program = (0, _utils.createShaderProgram)(gl, _this._vertexShader, _this._fragmentShader);\n\n        //create and setup the framebuffer\n        _this._framebuffer = gl.createFramebuffer();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, _this._framebuffer);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, _this._texture, 0);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        //create properties on this object for the passed properties\n\n        var _loop = function _loop(_propertyName) {\n            Object.defineProperty(_this, _propertyName, {\n                get: function get() {\n                    return this._properties[_propertyName].value;\n                },\n                set: function set(passedValue) {\n                    this._properties[_propertyName].value = passedValue;\n                }\n            });\n        };\n\n        for (var _propertyName in _this._properties) {\n            _loop(_propertyName);\n        }\n\n        //create texutres for any texture properties\n        for (var _propertyName2 in _this._properties) {\n            var _propertyValue = _this._properties[_propertyName2].value;\n            if (_propertyValue instanceof Image) {\n                _this._properties[_propertyName2].texture = (0, _utils.createElementTexture)(gl);\n                _this._properties[_propertyName2].textureUnit = gl.TEXTURE0 + _this._boundTextureUnits;\n                _this._properties[_propertyName2].textureUnitIndex = _this._boundTextureUnits;\n                _this._boundTextureUnits += 1;\n                if (_this._boundTextureUnits > _this._maxTextureUnits) {\n                    throw new _exceptions.RenderException(\"Trying to bind more than available textures units to shader\");\n                }\n            }\n        }\n\n        // calculate texture units for input textures\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = definition.inputs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var inputName = _step.value;\n\n                _this._shaderInputsTextureUnitMapping.push({\n                    name: inputName,\n                    textureUnit: gl.TEXTURE0 + _this._boundTextureUnits,\n                    textureUnitIndex: _this._boundTextureUnits,\n                    location: gl.getUniformLocation(_this._program, inputName)\n                });\n                _this._boundTextureUnits += 1;\n                if (_this._boundTextureUnits > _this._maxTextureUnits) {\n                    throw new _exceptions.RenderException(\"Trying to bind more than available textures units to shader\");\n                }\n            }\n\n            //find the locations of the properties in the compiled shader\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        for (var _propertyName3 in _this._properties) {\n            if (_this._properties[_propertyName3].type === \"uniform\") {\n                _this._properties[_propertyName3].location = _this._gl.getUniformLocation(_this._program, _propertyName3);\n            }\n        }\n        _this._currentTimeLocation = _this._gl.getUniformLocation(_this._program, \"currentTime\");\n        _this._currentTime = 0;\n\n        //Other setup\n        var positionLocation = gl.getAttribLocation(_this._program, \"a_position\");\n        var buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.enableVertexAttribArray(positionLocation);\n        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0]), gl.STATIC_DRAW);\n        var texCoordLocation = gl.getAttribLocation(_this._program, \"a_texCoord\");\n        gl.enableVertexAttribArray(texCoordLocation);\n        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\n        _this._displayName = TYPE;\n        return _this;\n    }\n\n    /**\n     * Sets the passed processing node property to the passed value.\n     * @param {string} name - The name of the processing node parameter to modify.\n     * @param {Object} value - The value to set it to.\n     *\n     * @example\n     * var ctx = new VideoContext();\n     * var monoNode = ctx.effect(VideoContext.DEFINITIONS.MONOCHROME);\n     * monoNode.setProperty(\"inputMix\", [1.0,0.0,0.0]); //Just use red channel\n     */\n\n\n    _createClass(ProcessingNode, [{\n        key: \"setProperty\",\n        value: function setProperty(name, value) {\n            this._properties[name].value = value;\n        }\n\n        /**\n         * Sets the passed processing node property to the passed value.\n         * @param {string} name - The name of the processing node parameter to get.\n         *\n         * @example\n         * var ctx = new VideoContext();\n         * var monoNode = ctx.effect(VideoContext.DEFINITIONS.MONOCHROME);\n         * console.log(monoNode.getProperty(\"inputMix\")); //Will output [0.4,0.6,0.2], the default value from the effect definition.\n         *\n         */\n\n    }, {\n        key: \"getProperty\",\n        value: function getProperty(name) {\n            return this._properties[name].value;\n        }\n\n        /**\n         * Destroy and clean-up the node.\n         */\n\n    }, {\n        key: \"destroy\",\n        value: function destroy() {\n            _get(ProcessingNode.prototype.__proto__ || Object.getPrototypeOf(ProcessingNode.prototype), \"destroy\", this).call(this);\n            //destrpy texutres for any texture properties\n            for (var propertyName in this._properties) {\n                var propertyValue = this._properties[propertyName].value;\n                if (propertyValue instanceof Image) {\n                    this._gl.deleteTexture(this._properties[propertyName].texture);\n                    this._texture = undefined;\n                }\n            }\n            //Destroy main\n            this._gl.deleteTexture(this._texture);\n            this._texture = undefined;\n            //Detach shaders\n            this._gl.detachShader(this._program, this._vertexShader);\n            this._gl.detachShader(this._program, this._fragmentShader);\n            //Delete shaders\n            this._gl.deleteShader(this._vertexShader);\n            this._gl.deleteShader(this._fragmentShader);\n            //Delete program\n            this._gl.deleteProgram(this._program);\n            //Delete Framebuffer\n            this._gl.deleteFramebuffer(this._framebuffer);\n        }\n    }, {\n        key: \"_update\",\n        value: function _update(currentTime) {\n            this._currentTime = currentTime;\n        }\n    }, {\n        key: \"_seek\",\n        value: function _seek(currentTime) {\n            this._currentTime = currentTime;\n        }\n    }, {\n        key: \"_render\",\n        value: function _render() {\n            this._rendered = true;\n            var gl = this._gl;\n            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n            gl.useProgram(this._program);\n\n            //upload the default uniforms\n            gl.uniform1f(this._currentTimeLocation, parseFloat(this._currentTime));\n\n            for (var propertyName in this._properties) {\n                var propertyValue = this._properties[propertyName].value;\n                var propertyType = this._properties[propertyName].type;\n                var propertyLocation = this._properties[propertyName].location;\n                if (propertyType !== \"uniform\") continue;\n\n                if (typeof propertyValue === \"number\") {\n                    gl.uniform1f(propertyLocation, propertyValue);\n                } else if (Object.prototype.toString.call(propertyValue) === \"[object Array]\") {\n                    if (propertyValue.length === 1) {\n                        gl.uniform1fv(propertyLocation, propertyValue);\n                    } else if (propertyValue.length === 2) {\n                        gl.uniform2fv(propertyLocation, propertyValue);\n                    } else if (propertyValue.length === 3) {\n                        gl.uniform3fv(propertyLocation, propertyValue);\n                    } else if (propertyValue.length === 4) {\n                        gl.uniform4fv(propertyLocation, propertyValue);\n                    } else {\n                        console.debug(\"Shader parameter\", propertyName, \"is too long an array:\", propertyValue);\n                    }\n                } else if (propertyValue instanceof Image) {\n                    var texture = this._properties[propertyName].texture;\n                    var textureUnit = this._properties[propertyName].textureUnit;\n                    var textureUnitIndex = this._properties[propertyName].textureUnit;\n                    (0, _utils.updateTexture)(gl, texture, propertyValue);\n\n                    gl.activeTexture(textureUnit);\n                    gl.uniform1i(propertyLocation, textureUnitIndex);\n                    gl.bindTexture(gl.TEXTURE_2D, texture);\n                } else {\n                    //TODO - add tests for textures\n                    /*gl.activeTexture(gl.TEXTURE0 + textureOffset);\n                    gl.uniform1i(parameterLoctation, textureOffset);\n                    gl.bindTexture(gl.TEXTURE_2D, textures[textureOffset-1]);*/\n                }\n            }\n        }\n    }]);\n\n    return ProcessingNode;\n}(_graphnode2.default);\n\nexports.PROCESSINGTYPE = TYPE;\nexports.default = ProcessingNode;\n\n/***/ }),\n\n/***/ \"./src/ProcessingNodes/transitionnode.js\":\n/*!***********************************************!*\\\n  !*** ./src/ProcessingNodes/transitionnode.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_105039__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.TRANSITIONTYPE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _effectnode = __nested_webpack_require_105039__(/*! ./effectnode */ \"./src/ProcessingNodes/effectnode.js\");\n\nvar _effectnode2 = _interopRequireDefault(_effectnode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nvar TYPE = \"TransitionNode\";\n\nvar TransitionNode = function (_EffectNode) {\n    _inherits(TransitionNode, _EffectNode);\n\n    /**\n     * Initialise an instance of a TransitionNode. You should not instantiate this directly, but use VideoContest.createTransitonNode().\n     */\n    function TransitionNode(gl, renderGraph, definition) {\n        _classCallCheck(this, TransitionNode);\n\n        var _this = _possibleConstructorReturn(this, (TransitionNode.__proto__ || Object.getPrototypeOf(TransitionNode)).call(this, gl, renderGraph, definition));\n\n        _this._transitions = {};\n\n        //save a version of the original property values\n        _this._initialPropertyValues = {};\n        for (var propertyName in _this._properties) {\n            _this._initialPropertyValues[propertyName] = _this._properties[propertyName].value;\n        }\n        _this._displayName = TYPE;\n        return _this;\n    }\n\n    _createClass(TransitionNode, [{\n        key: \"_doesTransitionFitOnTimeline\",\n        value: function _doesTransitionFitOnTimeline(testTransition) {\n            if (this._transitions[testTransition.property] === undefined) return true;\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this._transitions[testTransition.property][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var transition = _step.value;\n\n                    if (testTransition.start > transition.start && testTransition.start < transition.end) return false;\n                    if (testTransition.end > transition.start && testTransition.end < transition.end) return false;\n                    if (transition.start > testTransition.start && transition.start < testTransition.end) return false;\n                    if (transition.end > testTransition.start && transition.end < testTransition.end) return false;\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            return true;\n        }\n    }, {\n        key: \"_insertTransitionInTimeline\",\n        value: function _insertTransitionInTimeline(transition) {\n            if (this._transitions[transition.property] === undefined) this._transitions[transition.property] = [];\n            this._transitions[transition.property].push(transition);\n\n            this._transitions[transition.property].sort(function (a, b) {\n                return a.start - b.start;\n            });\n        }\n\n        /**\n         * Create a transition on the timeline.\n         *\n         * @param {number} startTime - The time at which the transition should start (relative to currentTime of video context).\n         * @param {number} endTime - The time at which the transition should be completed by (relative to currentTime of video context).\n         * @param {number} currentValue - The value to start the transition at.\n         * @param {number} targetValue - The value to transition to by endTime.\n         * @param {String} propertyName - The name of the property to clear transitions on, if undefined default to \"mix\".\n         *\n         * @return {Boolean} returns True if a transition is successfully added, false otherwise.\n         */\n\n    }, {\n        key: \"transition\",\n        value: function transition(startTime, endTime, currentValue, targetValue) {\n            var propertyName = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"mix\";\n\n            var transition = {\n                start: startTime + this._currentTime,\n                end: endTime + this._currentTime,\n                current: currentValue,\n                target: targetValue,\n                property: propertyName\n            };\n            if (!this._doesTransitionFitOnTimeline(transition)) return false;\n            this._insertTransitionInTimeline(transition);\n            return true;\n        }\n\n        /**\n         * Create a transition on the timeline at an absolute time.\n         *\n         * @param {number} startTime - The time at which the transition should start (relative to time 0).\n         * @param {number} endTime - The time at which the transition should be completed by (relative to time 0).\n         * @param {number} currentValue - The value to start the transition at.\n         * @param {number} targetValue - The value to transition to by endTime.\n         * @param {String} propertyName - The name of the property to clear transitions on, if undefined default to \"mix\".\n         *\n         * @return {Boolean} returns True if a transition is successfully added, false otherwise.\n         */\n\n    }, {\n        key: \"transitionAt\",\n        value: function transitionAt(startTime, endTime, currentValue, targetValue) {\n            var propertyName = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"mix\";\n\n            var transition = {\n                start: startTime,\n                end: endTime,\n                current: currentValue,\n                target: targetValue,\n                property: propertyName\n            };\n            if (!this._doesTransitionFitOnTimeline(transition)) return false;\n            this._insertTransitionInTimeline(transition);\n            return true;\n        }\n\n        /**\n         * Clear all transistions on the passed property. If no property is defined clear all transitions on the node.\n         *\n         * @param {String} propertyName - The name of the property to clear transitions on, if undefined clear all transitions on the node.\n         */\n\n    }, {\n        key: \"clearTransitions\",\n        value: function clearTransitions(propertyName) {\n            if (propertyName === undefined) {\n                this._transitions = {};\n            } else {\n                this._transitions[propertyName] = [];\n            }\n        }\n\n        /**\n         * Clear a transistion on the passed property that the specified time lies within.\n         *\n         * @param {String} propertyName - The name of the property to clear a transition on.\n         * @param {number} time - A time which lies within the property you're trying to clear.\n         *\n         * @return {Boolean} returns True if a transition is removed, false otherwise.\n         */\n\n    }, {\n        key: \"clearTransition\",\n        value: function clearTransition(propertyName, time) {\n            var transitionIndex = undefined;\n            for (var i = 0; i < this._transitions[propertyName].length; i++) {\n                var transition = this._transitions[propertyName][i];\n                if (time > transition.start && time < transition.end) {\n                    transitionIndex = i;\n                }\n            }\n            if (transitionIndex !== undefined) {\n                this._transitions[propertyName].splice(transitionIndex, 1);\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: \"_update\",\n        value: function _update(currentTime) {\n            _get(TransitionNode.prototype.__proto__ || Object.getPrototypeOf(TransitionNode.prototype), \"_update\", this).call(this, currentTime);\n            for (var propertyName in this._transitions) {\n                var value = this[propertyName];\n                if (this._transitions[propertyName].length > 0) {\n                    value = this._transitions[propertyName][0].current;\n                }\n                var transitionActive = false;\n\n                for (var i = 0; i < this._transitions[propertyName].length; i++) {\n                    var transition = this._transitions[propertyName][i];\n                    if (currentTime > transition.end) {\n                        value = transition.target;\n                        continue;\n                    }\n\n                    if (currentTime > transition.start && currentTime < transition.end) {\n                        var difference = transition.target - transition.current;\n                        var progress = (this._currentTime - transition.start) / (transition.end - transition.start);\n                        transitionActive = true;\n                        this[propertyName] = transition.current + difference * progress;\n                        break;\n                    }\n                }\n\n                if (!transitionActive) this[propertyName] = value;\n            }\n        }\n    }]);\n\n    return TransitionNode;\n}(_effectnode2.default);\n\nexports.TRANSITIONTYPE = TYPE;\nexports.default = TransitionNode;\n\n/***/ }),\n\n/***/ \"./src/SourceNodes/audionode.js\":\n/*!**************************************!*\\\n  !*** ./src/SourceNodes/audionode.js ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_116645__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.AUDIOTYPE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _medianode = __nested_webpack_require_116645__(/*! ./medianode */ \"./src/SourceNodes/medianode.js\");\n\nvar _medianode2 = _interopRequireDefault(_medianode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nvar TYPE = \"AudioNode\";\n\nvar AudioNode = function (_MediaNode) {\n    _inherits(AudioNode, _MediaNode);\n\n    /**\n     * Initialise an instance of an AudioNode.\n     * This should not be called directly, but created through a call to videoContext.audio();\n     */\n    function AudioNode() {\n        _classCallCheck(this, AudioNode);\n\n        var _this = _possibleConstructorReturn(this, (AudioNode.__proto__ || Object.getPrototypeOf(AudioNode)).apply(this, arguments));\n\n        _this._displayName = TYPE;\n        _this._elementType = \"audio\";\n        return _this;\n    }\n\n    _createClass(AudioNode, [{\n        key: \"_update\",\n        value: function _update(currentTime) {\n            _get(AudioNode.prototype.__proto__ || Object.getPrototypeOf(AudioNode.prototype), \"_update\", this).call(this, currentTime, false);\n        }\n    }]);\n\n    return AudioNode;\n}(_medianode2.default);\n\nexports.AUDIOTYPE = TYPE;\nexports.default = AudioNode;\n\n/***/ }),\n\n/***/ \"./src/SourceNodes/canvasnode.js\":\n/*!***************************************!*\\\n  !*** ./src/SourceNodes/canvasnode.js ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_120220__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.CANVASTYPE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _sourcenode = __nested_webpack_require_120220__(/*! ./sourcenode */ \"./src/SourceNodes/sourcenode.js\");\n\nvar _sourcenode2 = _interopRequireDefault(_sourcenode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nvar TYPE = \"CanvasNode\";\n\nvar CanvasNode = function (_SourceNode) {\n    _inherits(CanvasNode, _SourceNode);\n\n    /**\n     * Initialise an instance of a CanvasNode.\n     * This should not be called directly, but created through a call to videoContext.createCanvasNode();\n     */\n    function CanvasNode(canvas, gl, renderGraph, currentTime) {\n        var preloadTime = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 4;\n\n        _classCallCheck(this, CanvasNode);\n\n        var _this = _possibleConstructorReturn(this, (CanvasNode.__proto__ || Object.getPrototypeOf(CanvasNode)).call(this, canvas, gl, renderGraph, currentTime));\n\n        _this._preloadTime = preloadTime;\n        _this._displayName = TYPE;\n        return _this;\n    }\n\n    _createClass(CanvasNode, [{\n        key: \"_load\",\n        value: function _load() {\n            _get(CanvasNode.prototype.__proto__ || Object.getPrototypeOf(CanvasNode.prototype), \"_load\", this).call(this);\n            this._ready = true;\n            this._triggerCallbacks(\"loaded\");\n        }\n    }, {\n        key: \"_unload\",\n        value: function _unload() {\n            _get(CanvasNode.prototype.__proto__ || Object.getPrototypeOf(CanvasNode.prototype), \"_unload\", this).call(this);\n            this._ready = false;\n        }\n    }, {\n        key: \"_seek\",\n        value: function _seek(time) {\n            _get(CanvasNode.prototype.__proto__ || Object.getPrototypeOf(CanvasNode.prototype), \"_seek\", this).call(this, time);\n            if (this.state === _sourcenode.SOURCENODESTATE.playing || this.state === _sourcenode.SOURCENODESTATE.paused) {\n                if (this._element === undefined) this._load();\n                this._ready = false;\n            }\n            if ((this._state === _sourcenode.SOURCENODESTATE.sequenced || this._state === _sourcenode.SOURCENODESTATE.ended) && this._element !== undefined) {\n                this._unload();\n            }\n        }\n    }, {\n        key: \"_update\",\n        value: function _update(currentTime) {\n            //if (!super._update(currentTime)) return false;\n            _get(CanvasNode.prototype.__proto__ || Object.getPrototypeOf(CanvasNode.prototype), \"_update\", this).call(this, currentTime);\n            if (this._startTime - this._currentTime <= this._preloadTime && this._state !== _sourcenode.SOURCENODESTATE.waiting && this._state !== _sourcenode.SOURCENODESTATE.ended) this._load();\n\n            if (this._state === _sourcenode.SOURCENODESTATE.playing) {\n                return true;\n            } else if (this._state === _sourcenode.SOURCENODESTATE.paused) {\n                return true;\n            } else if (this._state === _sourcenode.SOURCENODESTATE.ended && this._element !== undefined) {\n                this._unload();\n                return false;\n            }\n        }\n    }]);\n\n    return CanvasNode;\n}(_sourcenode2.default);\n\nexports.CANVASTYPE = TYPE;\nexports.default = CanvasNode;\n\n/***/ }),\n\n/***/ \"./src/SourceNodes/imagenode.js\":\n/*!**************************************!*\\\n  !*** ./src/SourceNodes/imagenode.js ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_125791__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.IMAGETYPE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _sourcenode = __nested_webpack_require_125791__(/*! ./sourcenode */ \"./src/SourceNodes/sourcenode.js\");\n\nvar _sourcenode2 = _interopRequireDefault(_sourcenode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nvar TYPE = \"CanvasNode\";\n\nvar ImageNode = function (_SourceNode) {\n    _inherits(ImageNode, _SourceNode);\n\n    /**\n     * Initialise an instance of an ImageNode.\n     * This should not be called directly, but created through a call to videoContext.createImageNode();\n     */\n    function ImageNode(src, gl, renderGraph, currentTime) {\n        var preloadTime = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 4;\n        var attributes = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n        _classCallCheck(this, ImageNode);\n\n        var _this = _possibleConstructorReturn(this, (ImageNode.__proto__ || Object.getPrototypeOf(ImageNode)).call(this, src, gl, renderGraph, currentTime));\n\n        _this._preloadTime = preloadTime;\n        _this._attributes = attributes;\n        _this._textureUploaded = false;\n        _this._displayName = TYPE;\n        return _this;\n    }\n\n    _createClass(ImageNode, [{\n        key: \"_load\",\n        value: function _load() {\n            var _this2 = this;\n\n            if (this._image !== undefined) {\n                for (var key in this._attributes) {\n                    this._image[key] = this._attributes[key];\n                }\n                return;\n            }\n            if (this._isResponsibleForElementLifeCycle) {\n                _get(ImageNode.prototype.__proto__ || Object.getPrototypeOf(ImageNode.prototype), \"_load\", this).call(this);\n                this._image = new Image();\n                this._image.setAttribute(\"crossorigin\", \"anonymous\");\n                // It's important to set the `onload` event before the `src` property\n                // https://stackoverflow.com/questions/12354865/image-onload-event-and-browser-cache?answertab=active#tab-top\n                this._image.onload = function () {\n                    _this2._ready = true;\n                    if (window.createImageBitmap) {\n                        window.createImageBitmap(_this2._image, { imageOrientation: \"flipY\" }).then(function (imageBitmap) {\n                            _this2._element = imageBitmap;\n                            _this2._triggerCallbacks(\"loaded\");\n                        });\n                    } else {\n                        _this2._element = _this2._image;\n                        _this2._triggerCallbacks(\"loaded\");\n                    }\n                };\n                this._image.src = this._elementURL;\n                this._image.onerror = function () {\n                    console.error(\"ImageNode failed to load. url:\", _this2._elementURL);\n                };\n\n                for (var _key in this._attributes) {\n                    this._image[_key] = this._attributes[_key];\n                }\n            }\n            this._image.onerror = function () {\n                console.debug(\"Error with element\", _this2._image);\n                _this2._state = _sourcenode.SOURCENODESTATE.error;\n                //Event though there's an error ready should be set to true so the node can output transparenn\n                _this2._ready = true;\n                _this2._triggerCallbacks(\"error\");\n            };\n        }\n    }, {\n        key: \"_unload\",\n        value: function _unload() {\n            _get(ImageNode.prototype.__proto__ || Object.getPrototypeOf(ImageNode.prototype), \"_unload\", this).call(this);\n            if (this._isResponsibleForElementLifeCycle) {\n                if (this._image !== undefined) {\n                    this._image.src = \"\";\n                    this._image.onerror = undefined;\n                    this._image = undefined;\n                    delete this._image;\n                }\n                if (this._element instanceof window.ImageBitmap) {\n                    this._element.close();\n                }\n            }\n            this._ready = false;\n        }\n    }, {\n        key: \"_seek\",\n        value: function _seek(time) {\n            _get(ImageNode.prototype.__proto__ || Object.getPrototypeOf(ImageNode.prototype), \"_seek\", this).call(this, time);\n            if (this.state === _sourcenode.SOURCENODESTATE.playing || this.state === _sourcenode.SOURCENODESTATE.paused) {\n                if (this._image === undefined) this._load();\n            }\n            if ((this._state === _sourcenode.SOURCENODESTATE.sequenced || this._state === _sourcenode.SOURCENODESTATE.ended) && this._element !== undefined) {\n                this._unload();\n            }\n        }\n    }, {\n        key: \"_update\",\n        value: function _update(currentTime) {\n            //if (!super._update(currentTime)) return false;\n            if (this._textureUploaded) {\n                _get(ImageNode.prototype.__proto__ || Object.getPrototypeOf(ImageNode.prototype), \"_update\", this).call(this, currentTime, false);\n            } else {\n                _get(ImageNode.prototype.__proto__ || Object.getPrototypeOf(ImageNode.prototype), \"_update\", this).call(this, currentTime);\n            }\n\n            if (this._startTime - this._currentTime <= this._preloadTime && this._state !== _sourcenode.SOURCENODESTATE.waiting && this._state !== _sourcenode.SOURCENODESTATE.ended) this._load();\n\n            if (this._state === _sourcenode.SOURCENODESTATE.playing) {\n                return true;\n            } else if (this._state === _sourcenode.SOURCENODESTATE.paused) {\n                return true;\n            } else if (this._state === _sourcenode.SOURCENODESTATE.ended && this._image !== undefined) {\n                this._unload();\n                return false;\n            }\n        }\n    }, {\n        key: \"elementURL\",\n        get: function get() {\n            return this._elementURL;\n        }\n    }]);\n\n    return ImageNode;\n}(_sourcenode2.default);\n\nexports.IMAGETYPE = TYPE;\nexports.default = ImageNode;\n\n/***/ }),\n\n/***/ \"./src/SourceNodes/medianode.js\":\n/*!**************************************!*\\\n  !*** ./src/SourceNodes/medianode.js ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_134184__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if (\"value\" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };\n\nvar _sourcenode = __nested_webpack_require_134184__(/*! ./sourcenode */ \"./src/SourceNodes/sourcenode.js\");\n\nvar _sourcenode2 = _interopRequireDefault(_sourcenode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nvar MediaNode = function (_SourceNode) {\n    _inherits(MediaNode, _SourceNode);\n\n    /**\n     * Initialise an instance of a MediaNode.\n     * This should not be called directly, but extended by other Node Types which use a `HTMLMediaElement`.\n     */\n    function MediaNode(src, gl, renderGraph, currentTime) {\n        var globalPlaybackRate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1.0;\n        var sourceOffset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n        var preloadTime = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 4;\n        var mediaElementCache = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n        var attributes = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : {};\n\n        _classCallCheck(this, MediaNode);\n\n        var _this = _possibleConstructorReturn(this, (MediaNode.__proto__ || Object.getPrototypeOf(MediaNode)).call(this, src, gl, renderGraph, currentTime));\n\n        _this._preloadTime = preloadTime;\n        _this._sourceOffset = sourceOffset;\n        _this._globalPlaybackRate = globalPlaybackRate;\n        _this._mediaElementCache = mediaElementCache;\n        _this._playbackRate = 1.0;\n        _this._playbackRateUpdated = true;\n        _this._attributes = Object.assign({ volume: 1.0 }, attributes);\n        _this._loopElement = false;\n        _this._isElementPlaying = false;\n        if (_this._attributes.loop) {\n            _this._loopElement = _this._attributes.loop;\n        }\n        return _this;\n    }\n\n    _createClass(MediaNode, [{\n        key: \"_triggerLoad\",\n        value: function _triggerLoad() {\n            var _this2 = this;\n\n            // If the user hasn't supplied an element, videocontext is responsible for the element\n            if (this._isResponsibleForElementLifeCycle) {\n                if (this._mediaElementCache) {\n                    /**\n                     * Get a cached video element and also pass this instance so the\n                     * cache can access the current play state.\n                     */\n                    this._element = this._mediaElementCache.getElementAndLinkToNode(this);\n                } else {\n                    this._element = document.createElement(this._elementType);\n                    this._element.setAttribute(\"crossorigin\", \"anonymous\");\n                    this._element.setAttribute(\"webkit-playsinline\", \"\");\n                    this._element.setAttribute(\"playsinline\", \"\");\n                    this._playbackRateUpdated = true;\n                }\n                this._element.volume = this._attributes.volume;\n                if (window.MediaStream !== undefined && this._elementURL instanceof MediaStream) {\n                    this._element.srcObject = this._elementURL;\n                } else {\n                    this._element.src = this._elementURL;\n                }\n            }\n            // at this stage either the user or the element cache should have provided an element\n            if (this._element) {\n                for (var key in this._attributes) {\n                    this._element[key] = this._attributes[key];\n                }\n\n                var currentTimeOffset = 0;\n                if (this._currentTime > this._startTime) currentTimeOffset = this._currentTime - this._startTime;\n                this._element.currentTime = this._sourceOffset + currentTimeOffset;\n                this._element.onerror = function () {\n                    if (_this2._element === undefined) return;\n                    console.debug(\"Error with element\", _this2._element);\n                    _this2._state = _sourcenode.SOURCENODESTATE.error;\n                    //Event though there's an error ready should be set to true so the node can output transparenn\n                    _this2._ready = true;\n                    _this2._triggerCallbacks(\"error\");\n                };\n            } else {\n                // If the element doesn't exist for whatever reason enter the error state.\n                this._state = _sourcenode.SOURCENODESTATE.error;\n                this._ready = true;\n                this._triggerCallbacks(\"error\");\n            }\n\n            this._loadTriggered = true;\n        }\n\n        /**\n         * _load has two functions:\n         *\n         * 1. `_triggerLoad` which ensures the element has the correct src and is at the correct currentTime,\n         *     so that the browser can start fetching media.\n         *\n         * 2.  `shouldPollForElementReadyState` waits until the element has a \"readState\" that signals there\n         *     is enough media to start playback. This is a little confusing as currently structured.\n         *     We're using the _update loop to poll the _load function which checks the element status.\n         *     When ready we fire off the \"loaded callback\"\n         *\n         */\n\n    }, {\n        key: \"_load\",\n        value: function _load() {\n            _get(MediaNode.prototype.__proto__ || Object.getPrototypeOf(MediaNode.prototype), \"_load\", this).call(this);\n\n            /**\n             * We've got to be careful here as _load is called many times whilst waiting for the element to buffer\n             * and this function should only be called once.\n             * This is step one in what should be a more thorough refactor\n             */\n            if (!this._loadTriggered) {\n                this._triggerLoad();\n            }\n\n            var shouldPollForElementReadyState = this._element !== undefined;\n            /**\n             * this expression is effectively polling the element, waiting for it to buffer\n             * it gets called a lot of time\n             */\n            if (shouldPollForElementReadyState) {\n                if (this._element.readyState > 3 && !this._element.seeking) {\n                    // at this point the element has enough data for current playback position\n                    // and at least a couple of frames into the future\n\n                    // Check if the duration has changed. Update if necessary.\n                    // this could potentially go in the normal update loop but I don't want to change\n                    // too many things at once\n                    if (this._loopElement === false) {\n                        if (this._stopTime === Infinity || this._stopTime == undefined) {\n                            this._stopTime = this._startTime + this._element.duration;\n                            this._triggerCallbacks(\"durationchange\", this.duration);\n                        }\n                    }\n\n                    // signal to user that this node has \"loaded\"\n                    if (this._ready !== true) {\n                        this._triggerCallbacks(\"loaded\");\n                        this._playbackRateUpdated = true;\n                    }\n\n                    this._ready = true;\n                } else {\n                    if (this._state !== _sourcenode.SOURCENODESTATE.error) {\n                        this._ready = false;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"_unload\",\n        value: function _unload() {\n            _get(MediaNode.prototype.__proto__ || Object.getPrototypeOf(MediaNode.prototype), \"_unload\", this).call(this);\n            if (this._isResponsibleForElementLifeCycle && this._element !== undefined) {\n                this._element.removeAttribute(\"src\");\n                this._element.srcObject = undefined;\n                this._element.load();\n                for (var key in this._attributes) {\n                    this._element.removeAttribute(key);\n                }\n                // Unlink this form the cache, freeing up the element for another media node\n                if (this._mediaElementCache) this._mediaElementCache.unlinkNodeFromElement(this._element);\n                this._element = undefined;\n                if (!this._mediaElementCache) delete this._element;\n            }\n            // reset class to initial state\n            this._ready = false;\n            this._isElementPlaying = false;\n            // For completeness. I couldn't find a path that required reuse of this._loadTriggered after _unload.\n            this._loadTriggered = false;\n        }\n    }, {\n        key: \"_seek\",\n        value: function _seek(time) {\n            _get(MediaNode.prototype.__proto__ || Object.getPrototypeOf(MediaNode.prototype), \"_seek\", this).call(this, time);\n            if (this.state === _sourcenode.SOURCENODESTATE.playing || this.state === _sourcenode.SOURCENODESTATE.paused) {\n                if (this._element === undefined) this._load();\n                var relativeTime = this._currentTime - this._startTime + this._sourceOffset;\n                this._element.currentTime = relativeTime;\n                this._ready = false;\n            }\n            if ((this._state === _sourcenode.SOURCENODESTATE.sequenced || this._state === _sourcenode.SOURCENODESTATE.ended) && this._element !== undefined) {\n                this._unload();\n            }\n        }\n    }, {\n        key: \"_update\",\n        value: function _update(currentTime) {\n            var triggerTextureUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            //if (!super._update(currentTime)) return false;\n            _get(MediaNode.prototype.__proto__ || Object.getPrototypeOf(MediaNode.prototype), \"_update\", this).call(this, currentTime, triggerTextureUpdate);\n            //check if the media has ended\n            if (this._element !== undefined) {\n                if (this._element.ended) {\n                    this._state = _sourcenode.SOURCENODESTATE.ended;\n                    this._triggerCallbacks(\"ended\");\n                }\n            }\n\n            if (this._startTime - this._currentTime <= this._preloadTime && this._state !== _sourcenode.SOURCENODESTATE.waiting && this._state !== _sourcenode.SOURCENODESTATE.ended) this._load();\n\n            if (this._state === _sourcenode.SOURCENODESTATE.playing) {\n                if (this._playbackRateUpdated) {\n                    this._element.playbackRate = this._globalPlaybackRate * this._playbackRate;\n                    this._playbackRateUpdated = false;\n                }\n                if (!this._isElementPlaying) {\n                    this._element.play();\n                    if (this._stretchPaused) {\n                        this._element.pause();\n                    }\n                    this._isElementPlaying = true;\n                }\n                return true;\n            } else if (this._state === _sourcenode.SOURCENODESTATE.paused) {\n                this._element.pause();\n                this._isElementPlaying = false;\n                return true;\n            } else if (this._state === _sourcenode.SOURCENODESTATE.ended && this._element !== undefined) {\n                this._element.pause();\n                if (this._isElementPlaying) {\n                    this._unload();\n                }\n                return false;\n            }\n        }\n    }, {\n        key: \"clearTimelineState\",\n        value: function clearTimelineState() {\n            _get(MediaNode.prototype.__proto__ || Object.getPrototypeOf(MediaNode.prototype), \"clearTimelineState\", this).call(this);\n            if (this._element !== undefined) {\n                this._element.pause();\n                this._isElementPlaying = false;\n            }\n            this._unload();\n        }\n    }, {\n        key: \"destroy\",\n        value: function destroy() {\n            if (this._element) this._element.pause();\n            _get(MediaNode.prototype.__proto__ || Object.getPrototypeOf(MediaNode.prototype), \"destroy\", this).call(this);\n        }\n    }, {\n        key: \"playbackRate\",\n        set: function set(playbackRate) {\n            this._playbackRate = playbackRate;\n            this._playbackRateUpdated = true;\n        },\n        get: function get() {\n            return this._playbackRate;\n        }\n    }, {\n        key: \"stretchPaused\",\n        set: function set(stretchPaused) {\n            _set(MediaNode.prototype.__proto__ || Object.getPrototypeOf(MediaNode.prototype), \"stretchPaused\", stretchPaused, this);\n            if (this._element) {\n                if (this._stretchPaused) {\n                    this._element.pause();\n                } else {\n                    if (this._state === _sourcenode.SOURCENODESTATE.playing) {\n                        this._element.play();\n                    }\n                }\n            }\n        },\n        get: function get() {\n            return this._stretchPaused;\n        }\n    }, {\n        key: \"elementURL\",\n        get: function get() {\n            return this._elementURL;\n        }\n\n        /**\n         * @property {Boolean}\n         * @summary - Check if the element is waiting on the network to continue playback\n         */\n\n    }, {\n        key: \"_buffering\",\n        get: function get() {\n            if (this._element) {\n                return this._element.readyState < HTMLMediaElement.HAVE_FUTURE_DATA;\n            }\n\n            return false;\n        }\n    }, {\n        key: \"volume\",\n        set: function set(volume) {\n            this._attributes.volume = volume;\n            if (this._element !== undefined) this._element.volume = this._attributes.volume;\n        }\n    }]);\n\n    return MediaNode;\n}(_sourcenode2.default);\n\nexports.default = MediaNode;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/SourceNodes/nodes.js\":\n/*!**********************************!*\\\n  !*** ./src/SourceNodes/nodes.js ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_150659__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _audionode = __nested_webpack_require_150659__(/*! ./audionode */ \"./src/SourceNodes/audionode.js\");\n\nvar _audionode2 = _interopRequireDefault(_audionode);\n\nvar _canvasnode = __nested_webpack_require_150659__(/*! ./canvasnode */ \"./src/SourceNodes/canvasnode.js\");\n\nvar _canvasnode2 = _interopRequireDefault(_canvasnode);\n\nvar _imagenode = __nested_webpack_require_150659__(/*! ./imagenode */ \"./src/SourceNodes/imagenode.js\");\n\nvar _imagenode2 = _interopRequireDefault(_imagenode);\n\nvar _medianode = __nested_webpack_require_150659__(/*! ./medianode */ \"./src/SourceNodes/medianode.js\");\n\nvar _medianode2 = _interopRequireDefault(_medianode);\n\nvar _sourcenode = __nested_webpack_require_150659__(/*! ./sourcenode */ \"./src/SourceNodes/sourcenode.js\");\n\nvar _sourcenode2 = _interopRequireDefault(_sourcenode);\n\nvar _videonode = __nested_webpack_require_150659__(/*! ./videonode */ \"./src/SourceNodes/videonode.js\");\n\nvar _videonode2 = _interopRequireDefault(_videonode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar NODES = {\n    AudioNode: _audionode2.default,\n    CanvasNode: _canvasnode2.default,\n    ImageNode: _imagenode2.default,\n    MediaNode: _medianode2.default,\n    SourceNode: _sourcenode2.default,\n    VideoNode: _videonode2.default\n};\n\nexports.default = NODES;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/SourceNodes/sourcenode.js\":\n/*!***************************************!*\\\n  !*** ./src/SourceNodes/sourcenode.js ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_152303__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SOURCETYPE = exports.SOURCENODESTATE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _utils = __nested_webpack_require_152303__(/*! ../utils.js */ \"./src/utils.js\");\n\nvar _graphnode = __nested_webpack_require_152303__(/*! ../graphnode */ \"./src/graphnode.js\");\n\nvar _graphnode2 = _interopRequireDefault(_graphnode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nvar STATE = {\n    waiting: 0,\n    sequenced: 1,\n    playing: 2,\n    paused: 3,\n    ended: 4,\n    error: 5\n};\n\nvar TYPE = \"SourceNode\";\n\nvar SourceNode = function (_GraphNode) {\n    _inherits(SourceNode, _GraphNode);\n\n    /**\n     * Initialise an instance of a SourceNode.\n     * This is the base class for other Nodes which generate media to be passed into the processing pipeline.\n     */\n    function SourceNode(src, gl, renderGraph, currentTime) {\n        _classCallCheck(this, SourceNode);\n\n        var _this = _possibleConstructorReturn(this, (SourceNode.__proto__ || Object.getPrototypeOf(SourceNode)).call(this, gl, renderGraph, [], true));\n\n        _this._element = undefined;\n        _this._elementURL = undefined;\n        _this._isResponsibleForElementLifeCycle = true;\n\n        if (typeof src === \"string\" || window.MediaStream !== undefined && src instanceof MediaStream) {\n            //create the node from the passed URL or MediaStream\n            _this._elementURL = src;\n        } else {\n            //use the passed element to create the SourceNode\n            _this._element = src;\n            _this._isResponsibleForElementLifeCycle = false;\n        }\n\n        _this._state = STATE.waiting;\n        _this._currentTime = currentTime;\n        _this._startTime = NaN;\n        _this._stopTime = Infinity;\n        _this._ready = false;\n        _this._loadCalled = false;\n        _this._stretchPaused = false;\n        _this._texture = (0, _utils.createElementTexture)(gl);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0]));\n        _this._callbacks = [];\n        _this._renderPaused = false;\n        _this._displayName = TYPE;\n        return _this;\n    }\n\n    /**\n     * Returns the state of the node.\n     * 0 - Waiting, start() has not been called on it yet.\n     * 1 - Sequenced, start() has been called but it is not playing yet.\n     * 2 - Playing, the node is playing.\n     * 3 - Paused, the node is paused.\n     * 4 - Ended, playback of the node has finished.\n     *\n     * @example\n     * var ctx = new VideoContext();\n     * var videoNode = ctx.createVideoSourceNode('video.mp4');\n     * console.log(videoNode.state); //will output 0 (for waiting)\n     * videoNode.start(5);\n     * console.log(videoNode.state); //will output 1 (for sequenced)\n     * videoNode.stop(10);\n     * ctx.play();\n     * console.log(videoNode.state); //will output 2 (for playing)\n     * ctx.paused();\n     * console.log(videoNode.state); //will output 3 (for paused)\n     */\n\n\n    _createClass(SourceNode, [{\n        key: \"_load\",\n        value: function _load() {\n            if (!this._loadCalled) {\n                this._triggerCallbacks(\"load\");\n                this._loadCalled = true;\n            }\n        }\n    }, {\n        key: \"_unload\",\n        value: function _unload() {\n            this._triggerCallbacks(\"destroy\");\n            this._loadCalled = false;\n        }\n\n        /**\n         * Register callbacks against one of these events: \"load\", \"destroy\", \"seek\", \"pause\", \"play\", \"ended\", \"durationchange\", \"loaded\", \"error\"\n         *\n         * @param {String} type - the type of event to register the callback against.\n         * @param {function} func - the function to call.\n         *\n         * @example\n         * var ctx = new VideoContext();\n         * var videoNode = ctx.createVideoSourceNode('video.mp4');\n         *\n         * videoNode.registerCallback(\"load\", function(){\"video is loading\"});\n         * videoNode.registerCallback(\"play\", function(){\"video is playing\"});\n         * videoNode.registerCallback(\"ended\", function(){\"video has eneded\"});\n         *\n         */\n\n    }, {\n        key: \"registerCallback\",\n        value: function registerCallback(type, func) {\n            this._callbacks.push({ type: type, func: func });\n        }\n\n        /**\n         * Remove callback.\n         *\n         * @param {function} [func] - the callback to remove, if undefined will remove all callbacks for this node.\n         *\n         * @example\n         * var ctx = new VideoContext();\n         * var videoNode = ctx.createVideoSourceNode('video.mp4');\n         *\n         * videoNode.registerCallback(\"load\", function(){\"video is loading\"});\n         * videoNode.registerCallback(\"play\", function(){\"video is playing\"});\n         * videoNode.registerCallback(\"ended\", function(){\"video has eneded\"});\n         * videoNode.unregisterCallback(); //remove all of the three callbacks.\n         *\n         */\n\n    }, {\n        key: \"unregisterCallback\",\n        value: function unregisterCallback(func) {\n            var toRemove = [];\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this._callbacks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var callback = _step.value;\n\n                    if (func === undefined) {\n                        toRemove.push(callback);\n                    } else if (callback.func === func) {\n                        toRemove.push(callback);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = toRemove[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var _callback = _step2.value;\n\n                    var index = this._callbacks.indexOf(_callback);\n                    this._callbacks.splice(index, 1);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"_triggerCallbacks\",\n        value: function _triggerCallbacks(type, data) {\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this._callbacks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var callback = _step3.value;\n\n                    if (callback.type === type) {\n                        if (data !== undefined) {\n                            callback.func(this, data);\n                        } else {\n                            callback.func(this);\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Start playback at VideoContext.currentTime plus passed time. If passed time is negative, will play as soon as possible.\n         *\n         * @param {number} time - the time from the currentTime of the VideoContext which to start playing, if negative will play as soon as possible.\n         * @return {boolean} Will return true is seqeuncing has succeded, or false if it is already sequenced.\n         */\n\n    }, {\n        key: \"start\",\n        value: function start(time) {\n            if (this._state !== STATE.waiting) {\n                console.debug(\"SourceNode is has already been sequenced. Can't sequence twice.\");\n                return false;\n            }\n\n            this._startTime = this._currentTime + time;\n            this._state = STATE.sequenced;\n            return true;\n        }\n\n        /**\n         * Start playback at an absolute time ont the VideoContext's timeline.\n         *\n         * @param {number} time - the time on the VideoContexts timeline to start playing.\n         * @return {boolean} Will return true is seqeuncing has succeded, or false if it is already sequenced.\n         */\n\n    }, {\n        key: \"startAt\",\n        value: function startAt(time) {\n            if (this._state !== STATE.waiting) {\n                console.debug(\"SourceNode is has already been sequenced. Can't sequence twice.\");\n                return false;\n            }\n            this._startTime = time;\n            this._state = STATE.sequenced;\n            return true;\n        }\n    }, {\n        key: \"stop\",\n\n\n        /**\n         * Stop playback at VideoContext.currentTime plus passed time. If passed time is negative, will play as soon as possible.\n         *\n         * @param {number} time - the time from the currentTime of the video context which to stop playback.\n         * @return {boolean} Will return true is seqeuncing has succeded, or false if the playback has already ended or if start hasn't been called yet, or if time is less than the start time.\n         */\n        value: function stop(time) {\n            if (this._state === STATE.ended) {\n                console.debug(\"SourceNode has already ended. Cannot call stop.\");\n                return false;\n            } else if (this._state === STATE.waiting) {\n                console.debug(\"SourceNode must have start called before stop is called\");\n                return false;\n            }\n            if (this._currentTime + time <= this._startTime) {\n                console.debug(\"SourceNode must have a stop time after it's start time, not before.\");\n                return false;\n            }\n            this._stopTime = this._currentTime + time;\n            this._stretchPaused = false;\n            this._triggerCallbacks(\"durationchange\", this.duration);\n            return true;\n        }\n\n        /**\n         * Stop playback at an absolute time ont the VideoContext's timeline.\n         *\n         * @param {number} time - the time on the VideoContexts timeline to stop playing.\n         * @return {boolean} Will return true is seqeuncing has succeded, or false if the playback has already ended or if start hasn't been called yet, or if time is less than the start time.\n         */\n\n    }, {\n        key: \"stopAt\",\n        value: function stopAt(time) {\n            if (this._state === STATE.ended) {\n                console.debug(\"SourceNode has already ended. Cannot call stop.\");\n                return false;\n            } else if (this._state === STATE.waiting) {\n                console.debug(\"SourceNode must have start called before stop is called\");\n                return false;\n            }\n            if (time <= this._startTime) {\n                console.debug(\"SourceNode must have a stop time after it's start time, not before.\");\n                return false;\n            }\n            this._stopTime = time;\n            this._stretchPaused = false;\n            this._triggerCallbacks(\"durationchange\", this.duration);\n            return true;\n        }\n    }, {\n        key: \"_seek\",\n        value: function _seek(time) {\n            this._renderPaused = false;\n\n            this._triggerCallbacks(\"seek\", time);\n\n            if (this._state === STATE.waiting) return;\n            if (time < this._startTime) {\n                (0, _utils.clearTexture)(this._gl, this._texture);\n                this._state = STATE.sequenced;\n            }\n            if (time >= this._startTime && this._state !== STATE.paused) {\n                this._state = STATE.playing;\n            }\n            if (time >= this._stopTime) {\n                (0, _utils.clearTexture)(this._gl, this._texture);\n                this._triggerCallbacks(\"ended\");\n                this._state = STATE.ended;\n            }\n            //update the current time\n            this._currentTime = time;\n        }\n    }, {\n        key: \"_pause\",\n        value: function _pause() {\n            if (this._state === STATE.playing || this._currentTime === 0 && this._startTime === 0) {\n                this._triggerCallbacks(\"pause\");\n                this._state = STATE.paused;\n                this._renderPaused = false;\n            }\n        }\n    }, {\n        key: \"_play\",\n        value: function _play() {\n            if (this._state === STATE.paused) {\n                this._triggerCallbacks(\"play\");\n                this._state = STATE.playing;\n            }\n        }\n    }, {\n        key: \"_isReady\",\n        value: function _isReady() {\n            if (this._buffering) {\n                return false;\n            }\n            if (this._state === STATE.playing || this._state === STATE.paused || this._state === STATE.error) {\n                return this._ready;\n            }\n            return true;\n        }\n    }, {\n        key: \"_update\",\n        value: function _update(currentTime) {\n            var triggerTextureUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            this._rendered = true;\n            var timeDelta = currentTime - this._currentTime;\n\n            //update the current time\n            this._currentTime = currentTime;\n\n            //update the state\n            if (this._state === STATE.waiting || this._state === STATE.ended || this._state === STATE.error) return false;\n\n            this._triggerCallbacks(\"render\", currentTime);\n\n            if (currentTime < this._startTime) {\n                (0, _utils.clearTexture)(this._gl, this._texture);\n                this._state = STATE.sequenced;\n            }\n\n            if (currentTime >= this._startTime && this._state !== STATE.paused && this._state !== STATE.error) {\n                if (this._state !== STATE.playing) this._triggerCallbacks(\"play\");\n                this._state = STATE.playing;\n            }\n\n            if (currentTime >= this._stopTime) {\n                (0, _utils.clearTexture)(this._gl, this._texture);\n                this._triggerCallbacks(\"ended\");\n                this._state = STATE.ended;\n            }\n\n            //update this source nodes texture\n            if (this._element === undefined || this._ready === false) return true;\n\n            if (!this._renderPaused && this._state === STATE.paused) {\n                if (triggerTextureUpdate) (0, _utils.updateTexture)(this._gl, this._texture, this._element);\n                this._renderPaused = true;\n            }\n            if (this._state === STATE.playing) {\n                if (triggerTextureUpdate) (0, _utils.updateTexture)(this._gl, this._texture, this._element);\n                if (this._stretchPaused) {\n                    this._stopTime += timeDelta;\n                }\n            }\n\n            return true;\n        }\n\n        /**\n         * Clear any timeline state the node currently has, this puts the node in the \"waiting\" state, as if neither start nor stop had been called.\n         */\n\n    }, {\n        key: \"clearTimelineState\",\n        value: function clearTimelineState() {\n            this._startTime = NaN;\n            this._stopTime = Infinity;\n            this._state = STATE.waiting;\n        }\n\n        /**\n         * Destroy and clean-up the node.\n         */\n\n    }, {\n        key: \"destroy\",\n        value: function destroy() {\n            this._unload();\n            _get(SourceNode.prototype.__proto__ || Object.getPrototypeOf(SourceNode.prototype), \"destroy\", this).call(this);\n            this.unregisterCallback();\n            delete this._element;\n            this._elementURL = undefined;\n            this._state = STATE.waiting;\n            this._currentTime = 0;\n            this._startTime = NaN;\n            this._stopTime = Infinity;\n            this._ready = false;\n            this._loadCalled = false;\n            this._gl.deleteTexture(this._texture);\n            this._texture = undefined;\n        }\n    }, {\n        key: \"state\",\n        get: function get() {\n            return this._state;\n        }\n\n        /**\n         * Returns the underlying DOM element which represents this source node.\n         * Note: If a source node is created with a url rather than passing in an existing element then this will return undefined until the source node preloads the element.\n         *\n         * @return {Element} The underlying DOM element representing the media for the node. If the lifecycle of the video is owned UNSIGNED_BYTE the node itself, this can return undefined if the element hasn't been loaded yet.\n         *\n         * @example\n         * //Accessing the Element on a VideoNode created via a URL\n         * var ctx = new VideoContext();\n         * var videoNode = ctx.createVideoSourceNode('video.mp4');\n         * videoNode.start(0);\n         * videoNode.stop(5);\n         * //When the node starts playing the element should exist so set it's volume to 0\n         * videoNode.regsiterCallback(\"play\", function(){videoNode.element.volume = 0;});\n         *\n         *\n         * @example\n         * //Accessing the Element on a VideoNode created via an already existing element\n         * var ctx = new VideoContext();\n         * var videoElement = document.createElement(\"video\");\n         * var videoNode = ctx.createVideoSourceNode(videoElement);\n         * videoNode.start(0);\n         * videoNode.stop(5);\n         * //The elemnt can be accessed any time because it's lifecycle is managed outside of the VideoContext\n         * videoNode.element.volume = 0;\n         *\n         */\n\n    }, {\n        key: \"element\",\n        get: function get() {\n            return this._element;\n        }\n\n        /**\n         * Returns the duration of the node on a timeline. If no start time is set will return undefiend, if no stop time is set will return Infinity.\n         *\n         * @return {number} The duration of the node in seconds.\n         *\n         * @example\n         * var ctx = new VideoContext();\n         * var videoNode = ctx.createVideoSourceNode('video.mp4');\n         * videoNode.start(5);\n         * videoNode.stop(10);\n         * console.log(videoNode.duration); //will output 10\n         */\n\n    }, {\n        key: \"duration\",\n        get: function get() {\n            if (isNaN(this._startTime)) return undefined;\n            if (this._stopTime === Infinity) return Infinity;\n            return this._stopTime - this._startTime;\n        }\n    }, {\n        key: \"stretchPaused\",\n        set: function set(stretchPaused) {\n            this._stretchPaused = stretchPaused;\n        },\n        get: function get() {\n            return this._stretchPaused;\n        }\n    }, {\n        key: \"startTime\",\n        get: function get() {\n            return this._startTime;\n        }\n    }, {\n        key: \"stopTime\",\n        get: function get() {\n            return this._stopTime;\n        }\n    }]);\n\n    return SourceNode;\n}(_graphnode2.default);\n\nexports.SOURCENODESTATE = STATE;\nexports.SOURCETYPE = TYPE;\nexports.default = SourceNode;\n\n/***/ }),\n\n/***/ \"./src/SourceNodes/videonode.js\":\n/*!**************************************!*\\\n  !*** ./src/SourceNodes/videonode.js ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_174878__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.VIDEOTYPE = undefined;\n\nvar _medianode = __nested_webpack_require_174878__(/*! ./medianode */ \"./src/SourceNodes/medianode.js\");\n\nvar _medianode2 = _interopRequireDefault(_medianode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nvar TYPE = \"VideoNode\";\n\nvar VideoNode = function (_MediaNode) {\n    _inherits(VideoNode, _MediaNode);\n\n    /**\n     * Initialise an instance of a VideoNode.\n     * This should not be called directly, but created through a call to videoContext.createVideoNode();\n     */\n    function VideoNode() {\n        _classCallCheck(this, VideoNode);\n\n        var _this = _possibleConstructorReturn(this, (VideoNode.__proto__ || Object.getPrototypeOf(VideoNode)).apply(this, arguments));\n\n        _this._displayName = TYPE;\n        _this._elementType = \"video\";\n        return _this;\n    }\n\n    return VideoNode;\n}(_medianode2.default);\n\nexports.VIDEOTYPE = TYPE;\nexports.default = VideoNode;\n\n/***/ }),\n\n/***/ \"./src/exceptions.js\":\n/*!***************************!*\\\n  !*** ./src/exceptions.js ***!\n  \\***************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ConnectException = ConnectException;\nexports.RenderException = RenderException;\n//Matthew Shotton, R&D User Experience,© BBC 2015\nfunction ConnectException(message) {\n    this.message = message;\n    this.name = \"ConnectionException\";\n}\n\nfunction RenderException(message) {\n    this.message = message;\n    this.name = \"RenderException\";\n}\n\n/***/ }),\n\n/***/ \"./src/graphnode.js\":\n/*!**************************!*\\\n  !*** ./src/graphnode.js ***!\n  \\**************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//Matthew Shotton, R&D User Experience,© BBC 2015\n\nvar TYPE = \"GraphNode\";\n\nvar GraphNode = function () {\n    /**\n     * Base class from which all processing and source nodes are derrived.\n     */\n    function GraphNode(gl, renderGraph, inputNames) {\n        var limitConnections = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        _classCallCheck(this, GraphNode);\n\n        this._renderGraph = renderGraph;\n        this._limitConnections = limitConnections;\n        this._inputNames = inputNames;\n        this._destroyed = false;\n\n        //Setup WebGL output texture\n        this._gl = gl;\n        this._renderGraph = renderGraph;\n        this._rendered = false;\n        this._displayName = TYPE;\n    }\n\n    /**\n     * Get a string representation of the class name.\n     *\n     * @return String A string of the class name.\n     */\n\n    _createClass(GraphNode, [{\n        key: \"connect\",\n\n\n        /**\n         * Connect this node to the targetNode\n         *\n         * @param {GraphNode} targetNode - the node to connect.\n         * @param {(number| String)} [targetPort] - the port on the targetNode to connect to, this can be an index, a string identifier, or undefined (in which case the next available port will be connected to).\n         *\n         */\n        value: function connect(targetNode, targetPort) {\n            return this._renderGraph.registerConnection(this, targetNode, targetPort);\n        }\n\n        /**\n         * Disconnect this node from the targetNode. If targetNode is undefind remove all out-bound connections.\n         *\n         * @param {GraphNode} [targetNode] - the node to disconnect from. If undefined, disconnect from all nodes.\n         *\n         */\n\n    }, {\n        key: \"disconnect\",\n        value: function disconnect(targetNode) {\n            var _this = this;\n\n            if (targetNode === undefined) {\n                var toRemove = this._renderGraph.getOutputsForNode(this);\n                toRemove.forEach(function (target) {\n                    return _this._renderGraph.unregisterConnection(_this, target);\n                });\n                if (toRemove.length > 0) return true;\n                return false;\n            }\n            return this._renderGraph.unregisterConnection(this, targetNode);\n        }\n\n        /**\n         * Destory this node, removing it from the graph.\n         */\n\n    }, {\n        key: \"destroy\",\n        value: function destroy() {\n            this.disconnect();\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.inputs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var input = _step.value;\n\n                    input.disconnect(this);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            this._destroyed = true;\n        }\n    }, {\n        key: \"displayName\",\n        get: function get() {\n            return this._displayName;\n        }\n\n        /**\n         * Get the names of the inputs to this node.\n         *\n         * @return {String[]} An array of the names of the inputs ot the node.\n         */\n\n    }, {\n        key: \"inputNames\",\n        get: function get() {\n            return this._inputNames.slice();\n        }\n\n        /**\n         * The maximum number of connections that can be made to this node. If there is not limit this will return Infinity.\n         *\n         * @return {number} The number of connections which can be made to this node.\n         */\n\n    }, {\n        key: \"maximumConnections\",\n        get: function get() {\n            if (this._limitConnections === false) return Infinity;\n            return this._inputNames.length;\n        }\n\n        /**\n         * Get an array of all the nodes which connect to this node.\n         *\n         * @return {GraphNode[]} An array of nodes which connect to this node.\n         */\n\n    }, {\n        key: \"inputs\",\n        get: function get() {\n            var result = this._renderGraph.getInputsForNode(this);\n            result = result.filter(function (n) {\n                return n !== undefined;\n            });\n            return result;\n        }\n\n        /**\n         * Get an array of all the nodes which this node outputs to.\n         *\n         * @return {GraphNode[]} An array of nodes which this node connects to.\n         */\n\n    }, {\n        key: \"outputs\",\n        get: function get() {\n            return this._renderGraph.getOutputsForNode(this);\n        }\n\n        /**\n         * Get whether the node has been destroyed or not.\n         *\n         * @return {boolean} A true/false value of whather the node has been destoryed or not.\n         */\n\n    }, {\n        key: \"destroyed\",\n        get: function get() {\n            return this._destroyed;\n        }\n    }]);\n\n    return GraphNode;\n}();\n\nexports.GRAPHTYPE = TYPE;\nexports.default = GraphNode;\n\n/***/ }),\n\n/***/ \"./src/rendergraph.js\":\n/*!****************************!*\\\n  !*** ./src/rendergraph.js ***!\n  \\****************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_184237__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nvar _exceptions = __nested_webpack_require_184237__(/*! ./exceptions.js */ \"./src/exceptions.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar RenderGraph = function () {\n    /**\n     * Manages the rendering graph.\n     */\n    function RenderGraph() {\n        _classCallCheck(this, RenderGraph);\n\n        this.connections = [];\n    }\n\n    /**\n     * Get a list of nodes which are connected to the output of the passed node.\n     *\n     * @param {GraphNode} node - the node to get the outputs for.\n     * @return {GraphNode[]} An array of the nodes which are connected to the output.\n     */\n\n\n    _createClass(RenderGraph, [{\n        key: \"getOutputsForNode\",\n        value: function getOutputsForNode(node) {\n            var results = [];\n            this.connections.forEach(function (connection) {\n                if (connection.source === node) {\n                    results.push(connection.destination);\n                }\n            });\n            return results;\n        }\n\n        /**\n         * Get a list of nodes which are connected, by input name, to the given node. Array contains objects of the form: {\"source\":sourceNode, \"type\":\"name\", \"name\":inputName, \"destination\":destinationNode}.\n         *\n         * @param {GraphNode} node - the node to get the named inputs for.\n         * @return {Object[]} An array of objects representing the nodes and connection type, which are connected to the named inputs for the node.\n         */\n\n    }, {\n        key: \"getNamedInputsForNode\",\n        value: function getNamedInputsForNode(node) {\n            var results = [];\n            this.connections.forEach(function (connection) {\n                if (connection.destination === node && connection.type === \"name\") {\n                    results.push(connection);\n                }\n            });\n            return results;\n        }\n\n        /**\n         * Get a list of nodes which are connected, by z-index name, to the given node. Array contains objects of the form: {\"source\":sourceNode, \"type\":\"zIndex\", \"zIndex\":0, \"destination\":destinationNode}.\n         *\n         * @param {GraphNode} node - the node to get the z-index refernced inputs for.\n         * @return {Object[]} An array of objects representing the nodes and connection type, which are connected by z-Index for the node.\n         */\n\n    }, {\n        key: \"getZIndexInputsForNode\",\n        value: function getZIndexInputsForNode(node) {\n            var results = [];\n            this.connections.forEach(function (connection) {\n                if (connection.destination === node && connection.type === \"zIndex\") {\n                    results.push(connection);\n                }\n            });\n            results.sort(function (a, b) {\n                return a.zIndex - b.zIndex;\n            });\n            return results;\n        }\n\n        /**\n         * Get a list of nodes which are connected as inputs to the given node. The length of the return array is always equal to the number of inputs for the node, with undefined taking the place of any inputs not connected.\n         *\n         * @param {GraphNode} node - the node to get the inputs for.\n         * @return {GraphNode[]} An array of GraphNodes which are connected to the node.\n         */\n\n    }, {\n        key: \"getInputsForNode\",\n        value: function getInputsForNode(node) {\n            var inputNames = node.inputNames;\n            var results = [];\n            var namedInputs = this.getNamedInputsForNode(node);\n            var indexedInputs = this.getZIndexInputsForNode(node);\n\n            if (node._limitConnections === true) {\n                for (var i = 0; i < inputNames.length; i++) {\n                    results[i] = undefined;\n                }\n\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = namedInputs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var connection = _step.value;\n\n                        var index = inputNames.indexOf(connection.name);\n                        results[index] = connection.source;\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                var indexedInputsIndex = 0;\n                for (var _i = 0; _i < results.length; _i++) {\n                    if (results[_i] === undefined && indexedInputs[indexedInputsIndex] !== undefined) {\n                        results[_i] = indexedInputs[indexedInputsIndex].source;\n                        indexedInputsIndex += 1;\n                    }\n                }\n            } else {\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                    for (var _iterator2 = namedInputs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                        var _connection = _step2.value;\n\n                        results.push(_connection.source);\n                    }\n                } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                            _iterator2.return();\n                        }\n                    } finally {\n                        if (_didIteratorError2) {\n                            throw _iteratorError2;\n                        }\n                    }\n                }\n\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n\n                try {\n                    for (var _iterator3 = indexedInputs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                        var _connection2 = _step3.value;\n\n                        results.push(_connection2.source);\n                    }\n                } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                            _iterator3.return();\n                        }\n                    } finally {\n                        if (_didIteratorError3) {\n                            throw _iteratorError3;\n                        }\n                    }\n                }\n            }\n            return results;\n        }\n\n        /**\n         * Check if a named input on a node is available to connect too.\n         * @param {GraphNode} node - the node to check.\n         * @param {String} inputName - the named input to check.\n         */\n\n    }, {\n        key: \"isInputAvailable\",\n        value: function isInputAvailable(node, inputName) {\n            if (node._inputNames.indexOf(inputName) === -1) return false;\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n                for (var _iterator4 = this.connections[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var connection = _step4.value;\n\n                    if (connection.type === \"name\") {\n                        if (connection.destination === node && connection.name === inputName) {\n                            return false;\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                    }\n                } finally {\n                    if (_didIteratorError4) {\n                        throw _iteratorError4;\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        /**\n         * Register a connection between two nodes.\n         *\n         * @param {GraphNode} sourceNode - the node to connect from.\n         * @param {GraphNode} destinationNode - the node to connect to.\n         * @param {(String | number)} [target] - the target port of the conenction, this could be a string to specfiy a specific named port, a number to specify a port by index, or undefined, in which case the next available port will be connected to.\n         * @return {boolean} Will return true if connection succeeds otherwise will throw a ConnectException.\n         */\n\n    }, {\n        key: \"registerConnection\",\n        value: function registerConnection(sourceNode, destinationNode, target) {\n            if (destinationNode.inputs.length >= destinationNode.inputNames.length && destinationNode._limitConnections === true) {\n                throw new _exceptions.ConnectException(\"Node has reached max number of inputs, can't connect\");\n            }\n\n            if (destinationNode._limitConnections === false) {\n                //check if connection is already made, if so raise a warning\n                var inputs = this.getInputsForNode(destinationNode);\n                if (inputs.includes(sourceNode)) {\n                    console.debug(\"WARNING - node connected mutliple times, removing previous connection\");\n                    this.unregisterConnection(sourceNode, destinationNode);\n                }\n            }\n\n            if (typeof target === \"number\") {\n                //target is a specific\n                this.connections.push({\n                    source: sourceNode,\n                    type: \"zIndex\",\n                    zIndex: target,\n                    destination: destinationNode\n                });\n            } else if (typeof target === \"string\" && destinationNode._limitConnections) {\n                //target is a named port\n\n                //make sure named port is free\n                if (this.isInputAvailable(destinationNode, target)) {\n                    this.connections.push({\n                        source: sourceNode,\n                        type: \"name\",\n                        name: target,\n                        destination: destinationNode\n                    });\n                } else {\n                    throw new _exceptions.ConnectException(\"Port \" + target + \" is already connected to\");\n                }\n            } else {\n                //target is undefined so just make it a high zIndex\n                var indexedConns = this.getZIndexInputsForNode(destinationNode);\n                var index = 0;\n                if (indexedConns.length > 0) index = indexedConns[indexedConns.length - 1].zIndex + 1;\n                this.connections.push({\n                    source: sourceNode,\n                    type: \"zIndex\",\n                    zIndex: index,\n                    destination: destinationNode\n                });\n            }\n            return true;\n        }\n\n        /**\n         * Remove a connection between two nodes.\n         * @param {GraphNode} sourceNode - the node to unregsiter connection from.\n         * @param {GraphNode} destinationNode - the node to register connection to.\n         * @return {boolean} Will return true if removing connection succeeds, or false if there was no connectionsction to remove.\n         */\n\n    }, {\n        key: \"unregisterConnection\",\n        value: function unregisterConnection(sourceNode, destinationNode) {\n            var _this = this;\n\n            var toRemove = [];\n\n            this.connections.forEach(function (connection) {\n                if (connection.source === sourceNode && connection.destination === destinationNode) {\n                    toRemove.push(connection);\n                }\n            });\n\n            if (toRemove.length === 0) return false;\n\n            toRemove.forEach(function (removeNode) {\n                var index = _this.connections.indexOf(removeNode);\n                _this.connections.splice(index, 1);\n            });\n\n            return true;\n        }\n    }], [{\n        key: \"outputEdgesFor\",\n        value: function outputEdgesFor(node, connections) {\n            var results = [];\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = connections[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var conn = _step5.value;\n\n                    if (conn.source === node) {\n                        results.push(conn);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n\n            return results;\n        }\n    }, {\n        key: \"inputEdgesFor\",\n        value: function inputEdgesFor(node, connections) {\n            var results = [];\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n                for (var _iterator6 = connections[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var conn = _step6.value;\n\n                    if (conn.destination === node) {\n                        results.push(conn);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                        _iterator6.return();\n                    }\n                } finally {\n                    if (_didIteratorError6) {\n                        throw _iteratorError6;\n                    }\n                }\n            }\n\n            return results;\n        }\n    }, {\n        key: \"getInputlessNodes\",\n        value: function getInputlessNodes(connections) {\n            var inputLess = [];\n            var _iteratorNormalCompletion7 = true;\n            var _didIteratorError7 = false;\n            var _iteratorError7 = undefined;\n\n            try {\n                for (var _iterator7 = connections[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                    var conn = _step7.value;\n\n                    inputLess.push(conn.source);\n                }\n            } catch (err) {\n                _didIteratorError7 = true;\n                _iteratorError7 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                        _iterator7.return();\n                    }\n                } finally {\n                    if (_didIteratorError7) {\n                        throw _iteratorError7;\n                    }\n                }\n            }\n\n            var _iteratorNormalCompletion8 = true;\n            var _didIteratorError8 = false;\n            var _iteratorError8 = undefined;\n\n            try {\n                for (var _iterator8 = connections[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                    var _conn = _step8.value;\n\n                    var index = inputLess.indexOf(_conn.destination);\n                    if (index !== -1) {\n                        inputLess.splice(index, 1);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError8 = true;\n                _iteratorError8 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                        _iterator8.return();\n                    }\n                } finally {\n                    if (_didIteratorError8) {\n                        throw _iteratorError8;\n                    }\n                }\n            }\n\n            return inputLess;\n        }\n    }]);\n\n    return RenderGraph;\n}();\n\nexports.default = RenderGraph;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/utils.js\":\n/*!**********************!*\\\n  !*** ./src/utils.js ***!\n  \\**********************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_202777__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.UpdateablesManager = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nexports.compileShader = compileShader;\nexports.createShaderProgram = createShaderProgram;\nexports.createElementTexture = createElementTexture;\nexports.updateTexture = updateTexture;\nexports.clearTexture = clearTexture;\nexports.generateRandomId = generateRandomId;\nexports.exportToJSON = exportToJSON;\nexports.snapshot = snapshot;\nexports.createControlFormForNode = createControlFormForNode;\nexports.visualiseVideoContextGraph = visualiseVideoContextGraph;\nexports.createSigmaGraphDataFromRenderGraph = createSigmaGraphDataFromRenderGraph;\nexports.importSimpleEDL = importSimpleEDL;\nexports.visualiseVideoContextTimeline = visualiseVideoContextTimeline;\nexports.mediaElementHasSource = mediaElementHasSource;\n\nvar _definitions = __nested_webpack_require_202777__(/*! ./Definitions/definitions.js */ \"./src/Definitions/definitions.js\");\n\nvar _definitions2 = _interopRequireDefault(_definitions);\n\nvar _sourcenode = __nested_webpack_require_202777__(/*! ./SourceNodes/sourcenode.js */ \"./src/SourceNodes/sourcenode.js\");\n\nvar _videonode = __nested_webpack_require_202777__(/*! ./SourceNodes/videonode.js */ \"./src/SourceNodes/videonode.js\");\n\nvar _canvasnode = __nested_webpack_require_202777__(/*! ./SourceNodes/canvasnode.js */ \"./src/SourceNodes/canvasnode.js\");\n\nvar _imagenode = __nested_webpack_require_202777__(/*! ./SourceNodes/imagenode.js */ \"./src/SourceNodes/imagenode.js\");\n\nvar _destinationnode = __nested_webpack_require_202777__(/*! ./DestinationNode/destinationnode.js */ \"./src/DestinationNode/destinationnode.js\");\n\nvar _transitionnode = __nested_webpack_require_202777__(/*! ./ProcessingNodes/transitionnode.js */ \"./src/ProcessingNodes/transitionnode.js\");\n\nvar _compositingnode = __nested_webpack_require_202777__(/*! ./ProcessingNodes/compositingnode.js */ \"./src/ProcessingNodes/compositingnode.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\n * Utility function to compile a WebGL Vertex or Fragment shader.\n *\n * @param {WebGLRenderingContext} gl - the webgl context fo which to build the shader.\n * @param {String} shaderSource - A string of shader code to compile.\n * @param {number} shaderType - Shader type, either WebGLRenderingContext.VERTEX_SHADER or WebGLRenderingContext.FRAGMENT_SHADER.\n *\n * @return {WebGLShader} A compiled shader.\n *\n */\nfunction compileShader(gl, shaderSource, shaderType) {\n    var shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, shaderSource);\n    gl.compileShader(shader);\n    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (!success) {\n        throw \"could not compile shader:\" + gl.getShaderInfoLog(shader);\n    }\n    return shader;\n}\n\n/*\n * Create a shader program from a passed vertex and fragment shader source string.\n *\n * @param {WebGLRenderingContext} gl - the webgl context fo which to build the shader.\n * @param {WebGLShader} vertexShader - A compiled vertex shader.\n * @param {WebGLShader} fragmentShader - A compiled fragment shader.\n *\n * @return {WebGLProgram} A compiled & linkde shader program.\n */\nfunction createShaderProgram(gl, vertexShader, fragmentShader) {\n    var program = gl.createProgram();\n\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        throw {\n            error: 4,\n            msg: \"Can't link shader program for track\",\n            toString: function toString() {\n                return this.msg;\n            }\n        };\n    }\n    return program;\n}\n\nfunction createElementTexture(gl) {\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    // Set the parameters so we can render any size image.\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    //Initialise the texture untit to clear.\n    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, type);\n\n    return texture;\n}\n\nfunction updateTexture(gl, texture, element) {\n    if (element.readyState !== undefined && element.readyState === 0) return;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, element);\n\n    texture._isTextureCleared = false;\n}\n\nfunction clearTexture(gl, texture) {\n    // A quick check to ensure we don't call 'texImage2D' when the texture has already been 'cleared' #performance\n    if (!texture._isTextureCleared) {\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0]));\n\n        texture._isTextureCleared = true;\n    }\n}\n\nfunction generateRandomId() {\n    var appearanceAdjective = [\"adorable\", \"alert\", \"average\", \"beautiful\", \"blonde\", \"bloody\", \"blushing\", \"bright\", \"clean\", \"clear\", \"cloudy\", \"colourful\", \"concerned\", \"crowded\", \"curious\", \"cute\", \"dark\", \"dirty\", \"drab\", \"distinct\", \"dull\", \"elegant\", \"fancy\", \"filthy\", \"glamorous\", \"gleaming\", \"graceful\", \"grotesque\", \"homely\", \"light\", \"misty\", \"motionless\", \"muddy\", \"plain\", \"poised\", \"quaint\", \"scary\", \"shiny\", \"smoggy\", \"sparkling\", \"spotless\", \"stormy\", \"strange\", \"ugly\", \"unsightly\", \"unusual\"];\n    var conditionAdjective = [\"alive\", \"brainy\", \"broken\", \"busy\", \"careful\", \"cautious\", \"clever\", \"crazy\", \"damaged\", \"dead\", \"difficult\", \"easy\", \"fake\", \"false\", \"famous\", \"forward\", \"fragile\", \"guilty\", \"helpful\", \"helpless\", \"important\", \"impossible\", \"infamous\", \"innocent\", \"inquisitive\", \"mad\", \"modern\", \"open\", \"outgoing\", \"outstanding\", \"poor\", \"powerful\", \"puzzled\", \"real\", \"rich\", \"right\", \"robust\", \"sane\", \"scary\", \"shy\", \"sleepy\", \"stupid\", \"super\", \"tame\", \"thick\", \"tired\", \"wild\", \"wrong\"];\n    var nounAnimal = [\"manatee\", \"gila monster\", \"nematode\", \"seahorse\", \"slug\", \"koala bear\", \"giant tortoise\", \"garden snail\", \"starfish\", \"sloth\", \"american woodcock\", \"coral\", \"swallowtail butterfly\", \"house sparrow\", \"sea anemone\"];\n\n    function randomChoice(array) {\n        return array[Math.floor(Math.random() * array.length)];\n    }\n\n    function capitalize(word) {\n        word = word.replace(/\\b\\w/g, function (l) {\n            return l.toUpperCase();\n        });\n        return word;\n    }\n\n    var name = randomChoice(appearanceAdjective) + \" \" + randomChoice(conditionAdjective) + \" \" + randomChoice(nounAnimal);\n    name = capitalize(name);\n    name = name.replace(/ /g, \"-\");\n    return name;\n}\n\nfunction exportToJSON(vc) {\n    console.warn(\"VideoContext.exportToJSON has been deprecated. Please use VideoContext.snapshot instead.\");\n    return JSON.stringify(snapshotNodes(vc));\n}\n\nfunction snapshot(vc) {\n    return {\n        nodes: snapshotNodes(vc),\n        videoContext: snapshotVideoContext(vc)\n    };\n}\n\nfunction snapshotVideoContext(vc) {\n    return {\n        currentTime: vc.currentTime,\n        duration: vc.duration,\n        state: vc.state,\n        playbackRate: vc.playbackRate\n    };\n}\n\nvar warningExportSourceLogged = false;\nfunction snapshotNodes(vc) {\n    function qualifyURL(url) {\n        var a = document.createElement(\"a\");\n        a.href = url;\n        return a.href;\n    }\n\n    function getInputIDs(node, vc) {\n        var inputs = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = node.inputs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var input = _step.value;\n\n                if (input === undefined) continue;\n                var inputID = void 0;\n                var inputIndex = node.inputs.indexOf(input);\n                var index = vc._processingNodes.indexOf(input);\n                if (index > -1) {\n                    inputID = \"processor\" + index;\n                } else {\n                    var _index = vc._sourceNodes.indexOf(input);\n                    if (_index > -1) {\n                        inputID = \"source\" + _index;\n                    } else {\n                        console.log(\"Warning, can't find input\", input);\n                    }\n                }\n                inputs.push({ id: inputID, index: inputIndex });\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        return inputs;\n    }\n\n    var result = {};\n\n    var sourceNodeStateMapping = [];\n    for (var state in _sourcenode.SOURCENODESTATE) {\n        sourceNodeStateMapping[_sourcenode.SOURCENODESTATE[state]] = state;\n    }\n\n    for (var index in vc._sourceNodes) {\n        var source = vc._sourceNodes[index];\n        var id = \"source\" + index;\n        var node_url = \"\";\n\n        if (!source._isResponsibleForElementLifeCycle) {\n            if (!warningExportSourceLogged) {\n                console.debug(\"Warning - Trying to export source created from an element not a URL. URL of export will be set to the elements src attribute and may be incorrect\", source);\n                warningExportSourceLogged = true;\n            }\n            node_url = source.element.src;\n        } else {\n            node_url = qualifyURL(source._elementURL);\n        }\n\n        var node = {\n            type: source.displayName,\n            url: node_url,\n            start: source.startTime,\n            stop: source.stopTime,\n            state: sourceNodeStateMapping[source.state]\n        };\n        if (node.type === _videonode.VIDEOTYPE) {\n            node.currentTime = null;\n            if (source.element && source.element.currentTime) {\n                node.currentTime = source.element.currentTime;\n            }\n        }\n\n        if (source._sourceOffset) {\n            node.sourceOffset = source._sourceOffset;\n        }\n        result[id] = node;\n    }\n\n    for (var _index2 in vc._processingNodes) {\n        var processor = vc._processingNodes[_index2];\n        var _id = \"processor\" + _index2;\n        var _node = {\n            type: processor.displayName,\n            definition: processor._definition,\n            inputs: getInputIDs(processor, vc),\n            properties: {}\n        };\n\n        for (var property in _node.definition.properties) {\n            _node.properties[property] = processor[property];\n        }\n\n        if (_node.type === _transitionnode.TRANSITIONTYPE) {\n            _node.transitions = processor._transitions;\n        }\n\n        result[_id] = _node;\n    }\n\n    result[\"destination\"] = {\n        type: \"Destination\",\n        inputs: getInputIDs(vc.destination, vc)\n    };\n\n    return result;\n}\n\nfunction createControlFormForNode(node, nodeName) {\n    var rootDiv = document.createElement(\"div\");\n\n    if (nodeName !== undefined) {\n        var title = document.createElement(\"h2\");\n        title.innerHTML = nodeName;\n        rootDiv.appendChild(title);\n    }\n\n    var _loop = function _loop(propertyName) {\n        var propertyParagraph = document.createElement(\"p\");\n        var propertyTitleHeader = document.createElement(\"h3\");\n        propertyTitleHeader.innerHTML = propertyName;\n        propertyParagraph.appendChild(propertyTitleHeader);\n\n        var propertyValue = node._properties[propertyName].value;\n        if (typeof propertyValue === \"number\") {\n            var range = document.createElement(\"input\");\n            range.setAttribute(\"type\", \"range\");\n            range.setAttribute(\"min\", \"0\");\n            range.setAttribute(\"max\", \"1\");\n            range.setAttribute(\"step\", \"0.01\");\n            range.setAttribute(\"value\", propertyValue, toString());\n\n            var number = document.createElement(\"input\");\n            number.setAttribute(\"type\", \"number\");\n            number.setAttribute(\"min\", \"0\");\n            number.setAttribute(\"max\", \"1\");\n            number.setAttribute(\"step\", \"0.01\");\n            number.setAttribute(\"value\", propertyValue, toString());\n\n            var mouseDown = false;\n            range.onmousedown = function () {\n                mouseDown = true;\n            };\n            range.onmouseup = function () {\n                mouseDown = false;\n            };\n            range.onmousemove = function () {\n                if (mouseDown) {\n                    node[propertyName] = parseFloat(range.value);\n                    number.value = range.value;\n                }\n            };\n            range.onchange = function () {\n                node[propertyName] = parseFloat(range.value);\n                number.value = range.value;\n            };\n            number.onchange = function () {\n                node[propertyName] = parseFloat(number.value);\n                range.value = number.value;\n            };\n            propertyParagraph.appendChild(range);\n            propertyParagraph.appendChild(number);\n        } else if (Object.prototype.toString.call(propertyValue) === \"[object Array]\") {\n            var _loop2 = function _loop2() {\n                var range = document.createElement(\"input\");\n                range.setAttribute(\"type\", \"range\");\n                range.setAttribute(\"min\", \"0\");\n                range.setAttribute(\"max\", \"1\");\n                range.setAttribute(\"step\", \"0.01\");\n                range.setAttribute(\"value\", propertyValue[i], toString());\n\n                var number = document.createElement(\"input\");\n                number.setAttribute(\"type\", \"number\");\n                number.setAttribute(\"min\", \"0\");\n                number.setAttribute(\"max\", \"1\");\n                number.setAttribute(\"step\", \"0.01\");\n                number.setAttribute(\"value\", propertyValue, toString());\n\n                var index = i;\n                var mouseDown = false;\n                range.onmousedown = function () {\n                    mouseDown = true;\n                };\n                range.onmouseup = function () {\n                    mouseDown = false;\n                };\n                range.onmousemove = function () {\n                    if (mouseDown) {\n                        node[propertyName][index] = parseFloat(range.value);\n                        number.value = range.value;\n                    }\n                };\n                range.onchange = function () {\n                    node[propertyName][index] = parseFloat(range.value);\n                    number.value = range.value;\n                };\n\n                number.onchange = function () {\n                    node[propertyName][index] = parseFloat(number.value);\n                    range.value = number.value;\n                };\n                propertyParagraph.appendChild(range);\n                propertyParagraph.appendChild(number);\n            };\n\n            for (i = 0; i < propertyValue.length; i++) {\n                _loop2();\n            }\n        }\n\n        rootDiv.appendChild(propertyParagraph);\n    };\n\n    for (var propertyName in node._properties) {\n        var i;\n\n        _loop(propertyName);\n    }\n    return rootDiv;\n}\n\nfunction calculateNodeDepthFromDestination(videoContext) {\n    var destination = videoContext.destination;\n    var depthMap = new Map();\n    depthMap.set(destination, 0);\n\n    function itterateBackwards(node) {\n        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n            for (var _iterator2 = node.inputs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var n = _step2.value;\n\n                var d = depth + 1;\n                if (depthMap.has(n)) {\n                    if (d > depthMap.get(n)) {\n                        depthMap.set(n, d);\n                    }\n                } else {\n                    depthMap.set(n, d);\n                }\n                itterateBackwards(n, depthMap.get(n));\n            }\n        } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                    _iterator2.return();\n                }\n            } finally {\n                if (_didIteratorError2) {\n                    throw _iteratorError2;\n                }\n            }\n        }\n    }\n\n    itterateBackwards(destination);\n    return depthMap;\n}\n\nfunction visualiseVideoContextGraph(videoContext, canvas) {\n    var ctx = canvas.getContext(\"2d\");\n    var w = canvas.width;\n    var h = canvas.height;\n    ctx.clearRect(0, 0, w, h);\n\n    var nodeDepths = calculateNodeDepthFromDestination(videoContext);\n    var depths = nodeDepths.values();\n    depths = Array.from(depths).sort(function (a, b) {\n        return b - a;\n    });\n    var maxDepth = depths[0];\n\n    var xStep = w / (maxDepth + 1);\n\n    var nodeHeight = h / videoContext._sourceNodes.length / 3;\n    var nodeWidth = nodeHeight * 1.618;\n\n    function calculateNodePos(node, nodeDepths, xStep, nodeHeight) {\n        var depth = nodeDepths.get(node);\n        nodeDepths.values();\n\n        var count = 0;\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n            for (var _iterator3 = nodeDepths[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var nodeDepth = _step3.value;\n\n                if (nodeDepth[0] === node) break;\n                if (nodeDepth[1] === depth) count += 1;\n            }\n        } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                    _iterator3.return();\n                }\n            } finally {\n                if (_didIteratorError3) {\n                    throw _iteratorError3;\n                }\n            }\n        }\n\n        return {\n            x: xStep * nodeDepths.get(node),\n            y: nodeHeight * 1.5 * count + 50\n        };\n    }\n\n    // \"video\":[\"#572A72\", \"#3C1255\"],\n    // \"image\":[\"#7D9F35\", \"#577714\"],\n    // \"canvas\":[\"#AA9639\", \"#806D15\"]\n\n    for (var i = 0; i < videoContext._renderGraph.connections.length; i++) {\n        var conn = videoContext._renderGraph.connections[i];\n        var source = calculateNodePos(conn.source, nodeDepths, xStep, nodeHeight);\n        var destination = calculateNodePos(conn.destination, nodeDepths, xStep, nodeHeight);\n        if (source !== undefined && destination !== undefined) {\n            ctx.beginPath();\n            //ctx.moveTo(source.x + nodeWidth/2, source.y + nodeHeight/2);\n            var x1 = source.x + nodeWidth / 2;\n            var y1 = source.y + nodeHeight / 2;\n            var x2 = destination.x + nodeWidth / 2;\n            var y2 = destination.y + nodeHeight / 2;\n            var dx = x2 - x1;\n            var dy = y2 - y1;\n\n            var angle = Math.PI / 2 - Math.atan2(dx, dy);\n\n            var distance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n\n            var midX = Math.min(x1, x2) + (Math.max(x1, x2) - Math.min(x1, x2)) / 2;\n            var midY = Math.min(y1, y2) + (Math.max(y1, y2) - Math.min(y1, y2)) / 2;\n\n            var testX = Math.cos(angle + Math.PI / 2) * distance / 1.5 + midX;\n            var testY = Math.sin(angle + Math.PI / 2) * distance / 1.5 + midY;\n            // console.log(testX, testY);\n\n            ctx.arc(testX, testY, distance / 1.2, angle - Math.PI + 0.95, angle - 0.95);\n\n            //ctx.arcTo(source.x + nodeWidth/2 ,source.y + nodeHeight/2,destination.x + nodeWidth/2,destination.y + nodeHeight/2,100);\n            //ctx.lineTo(midX, midY);\n            ctx.stroke();\n            //ctx.endPath();\n        }\n    }\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n        for (var _iterator4 = nodeDepths.keys()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var node = _step4.value;\n\n            var pos = calculateNodePos(node, nodeDepths, xStep, nodeHeight);\n            var color = \"#AA9639\";\n            var text = \"\";\n            if (node.displayName === _compositingnode.COMPOSITINGTYPE) {\n                color = \"#000000\";\n            }\n            if (node.displayName === _destinationnode.DESTINATIONTYPE) {\n                color = \"#7D9F35\";\n                text = \"Output\";\n            }\n            if (node.displayName === _videonode.VIDEOTYPE) {\n                color = \"#572A72\";\n                text = \"Video\";\n            }\n            if (node.displayName === _canvasnode.CANVASTYPE) {\n                color = \"#572A72\";\n                text = \"Canvas\";\n            }\n            if (node.displayName === _imagenode.IMAGETYPE) {\n                color = \"#572A72\";\n                text = \"Image\";\n            }\n            ctx.beginPath();\n            ctx.fillStyle = color;\n            ctx.fillRect(pos.x, pos.y, nodeWidth, nodeHeight);\n            ctx.fill();\n\n            ctx.fillStyle = \"#000\";\n            ctx.textAlign = \"center\";\n            ctx.font = \"10px Arial\";\n            ctx.fillText(text, pos.x + nodeWidth / 2, pos.y + nodeHeight / 2 + 2.5);\n            ctx.fill();\n        }\n    } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                _iterator4.return();\n            }\n        } finally {\n            if (_didIteratorError4) {\n                throw _iteratorError4;\n            }\n        }\n    }\n\n    return;\n}\n\nfunction createSigmaGraphDataFromRenderGraph(videoContext) {\n    function idForNode(node) {\n        if (videoContext._sourceNodes.indexOf(node) !== -1) {\n            var _id2 = \"source \" + node.displayName + \" \" + videoContext._sourceNodes.indexOf(node);\n            return _id2;\n        }\n        var id = \"processor \" + node.displayName + \" \" + videoContext._processingNodes.indexOf(node);\n        return id;\n    }\n\n    var graph = {\n        nodes: [{\n            id: idForNode(videoContext.destination),\n            label: \"Destination Node\",\n            x: 2.5,\n            y: 0.5,\n            size: 2,\n            node: videoContext.destination\n        }],\n        edges: []\n    };\n\n    for (var i = 0; i < videoContext._sourceNodes.length; i++) {\n        var sourceNode = videoContext._sourceNodes[i];\n        var y = i * (1.0 / videoContext._sourceNodes.length);\n        graph.nodes.push({\n            id: idForNode(sourceNode),\n            label: \"Source \" + i.toString(),\n            x: 0,\n            y: y,\n            size: 2,\n            color: \"#572A72\",\n            node: sourceNode\n        });\n    }\n    for (var _i = 0; _i < videoContext._processingNodes.length; _i++) {\n        var processingNode = videoContext._processingNodes[_i];\n        graph.nodes.push({\n            id: idForNode(processingNode),\n            x: Math.random() * 2.5,\n            y: Math.random(),\n            size: 2,\n            node: processingNode\n        });\n    }\n\n    for (var _i2 = 0; _i2 < videoContext._renderGraph.connections.length; _i2++) {\n        var conn = videoContext._renderGraph.connections[_i2];\n        graph.edges.push({\n            id: \"e\" + _i2.toString(),\n            source: idForNode(conn.source),\n            target: idForNode(conn.destination)\n        });\n    }\n\n    return graph;\n}\n\nfunction importSimpleEDL(ctx, playlist) {\n    // Create a \"track\" node to connect all the clips to.\n    var trackNode = ctx.compositor(_definitions2.default.COMBINE);\n\n    // Create a source node for each of the clips.\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n        for (var _iterator5 = playlist[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var clip = _step5.value;\n\n            var node = void 0;\n            if (clip.type === \"video\") {\n                node = ctx.video(clip.src, clip.sourceStart);\n            } else if (clip.type === \"image\") {\n                node = ctx.image(clip.src, clip.sourceStart);\n            } else {\n                console.debug(\"Clip type \" + clip.type + \" not recognised, skipping.\");\n                continue;\n            }\n            node.startAt(clip.start);\n            node.stopAt(clip.start + clip.duration);\n            node.connect(trackNode);\n        }\n    } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                _iterator5.return();\n            }\n        } finally {\n            if (_didIteratorError5) {\n                throw _iteratorError5;\n            }\n        }\n    }\n\n    return trackNode;\n}\n\nfunction visualiseVideoContextTimeline(videoContext, canvas, currentTime) {\n    var ctx = canvas.getContext(\"2d\");\n    var w = canvas.width;\n    var h = canvas.height;\n    var trackHeight = h / videoContext._sourceNodes.length;\n    var playlistDuration = videoContext.duration;\n\n    if (currentTime > playlistDuration && !videoContext.endOnLastSourceEnd) playlistDuration = currentTime;\n\n    if (videoContext.duration === Infinity) {\n        var total = 0;\n        for (var i = 0; i < videoContext._sourceNodes.length; i++) {\n            var sourceNode = videoContext._sourceNodes[i];\n            if (sourceNode._stopTime !== Infinity) total += sourceNode._stopTime;\n        }\n\n        if (total > videoContext.currentTime) {\n            playlistDuration = total + 5;\n        } else {\n            playlistDuration = videoContext.currentTime + 5;\n        }\n    }\n    var pixelsPerSecond = w / playlistDuration;\n    var mediaSourceStyle = {\n        video: [\"#572A72\", \"#3C1255\"],\n        image: [\"#7D9F35\", \"#577714\"],\n        canvas: [\"#AA9639\", \"#806D15\"]\n    };\n\n    ctx.clearRect(0, 0, w, h);\n    ctx.fillStyle = \"#999\";\n\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n        for (var _iterator6 = videoContext._processingNodes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var node = _step6.value;\n\n            if (node.displayName !== _transitionnode.TRANSITIONTYPE) continue;\n            for (var propertyName in node._transitions) {\n                var _iteratorNormalCompletion7 = true;\n                var _didIteratorError7 = false;\n                var _iteratorError7 = undefined;\n\n                try {\n                    for (var _iterator7 = node._transitions[propertyName][Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                        var transition = _step7.value;\n\n                        var tW = (transition.end - transition.start) * pixelsPerSecond;\n                        var tH = h;\n                        var tX = transition.start * pixelsPerSecond;\n                        var tY = 0;\n                        ctx.fillStyle = \"rgba(0,0,0, 0.3)\";\n                        ctx.fillRect(tX, tY, tW, tH);\n                        ctx.fill();\n                    }\n                } catch (err) {\n                    _didIteratorError7 = true;\n                    _iteratorError7 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                            _iterator7.return();\n                        }\n                    } finally {\n                        if (_didIteratorError7) {\n                            throw _iteratorError7;\n                        }\n                    }\n                }\n            }\n        }\n    } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                _iterator6.return();\n            }\n        } finally {\n            if (_didIteratorError6) {\n                throw _iteratorError6;\n            }\n        }\n    }\n\n    for (var _i3 = 0; _i3 < videoContext._sourceNodes.length; _i3++) {\n        var _sourceNode = videoContext._sourceNodes[_i3];\n        var duration = _sourceNode._stopTime - _sourceNode._startTime;\n        if (duration === Infinity) duration = videoContext.currentTime;\n        var start = _sourceNode._startTime;\n\n        var msW = duration * pixelsPerSecond;\n        var msH = trackHeight;\n        var msX = start * pixelsPerSecond;\n        var msY = trackHeight * _i3;\n        ctx.fillStyle = mediaSourceStyle.video[_i3 % mediaSourceStyle.video.length];\n\n        ctx.fillRect(msX, msY, msW, msH);\n        ctx.fill();\n    }\n\n    if (currentTime !== undefined) {\n        ctx.fillStyle = \"#000\";\n        ctx.fillRect(currentTime * pixelsPerSecond, 0, 1, h);\n    }\n}\n\nvar UpdateablesManager = exports.UpdateablesManager = function () {\n    function UpdateablesManager() {\n        _classCallCheck(this, UpdateablesManager);\n\n        this._updateables = [];\n        this._useWebworker = false;\n        this._active = false;\n        this._previousRAFTime = undefined;\n        this._previousWorkerTime = undefined;\n\n        this._webWorkerString = \"\\\n            var running = false;\\\n            function tick(){\\\n                postMessage(Date.now());\\\n                if (running){\\\n                    setTimeout(tick, 1000/20);\\\n                }\\\n            }\\\n            self.addEventListener('message',function(msg){\\\n                var data = msg.data;\\\n                if (data === 'start'){\\\n                    running = true;\\\n                    tick();\\\n                }\\\n                if (data === 'stop') running = false;\\\n            });\";\n        this._webWorker = undefined;\n    }\n\n    _createClass(UpdateablesManager, [{\n        key: \"_initWebWorker\",\n        value: function _initWebWorker() {\n            var _this = this;\n\n            window.URL = window.URL || window.webkitURL;\n            var blob = new Blob([this._webWorkerString], {\n                type: \"application/javascript\"\n            });\n            this._webWorker = new Worker(URL.createObjectURL(blob));\n            this._webWorker.onmessage = function (msg) {\n                var time = msg.data;\n                _this._updateWorkerTime(time);\n            };\n        }\n    }, {\n        key: \"_lostVisibility\",\n        value: function _lostVisibility() {\n            this._previousWorkerTime = Date.now();\n            this._useWebworker = true;\n            if (!this._webWorker) {\n                this._initWebWorker();\n            }\n            this._webWorker.postMessage(\"start\");\n        }\n    }, {\n        key: \"_gainedVisibility\",\n        value: function _gainedVisibility() {\n            this._useWebworker = false;\n            this._previousRAFTime = undefined;\n            if (this._webWorker) this._webWorker.postMessage(\"stop\");\n            requestAnimationFrame(this._updateRAFTime.bind(this));\n        }\n    }, {\n        key: \"_init\",\n        value: function _init() {\n            var _this2 = this;\n\n            if (!window.Worker) return;\n\n            //If page visibility API not present fallback to using \"focus\" and \"blur\" event listeners.\n            if (typeof document.hidden === \"undefined\") {\n                window.addEventListener(\"focus\", this._gainedVisibility.bind(this));\n                window.addEventListener(\"blur\", this._lostVisibility.bind(this));\n                return;\n            }\n            //Otherwise we can use the visibility API to do the loose/gain focus properly\n            document.addEventListener(\"visibilitychange\", function () {\n                if (document.hidden === true) {\n                    _this2._lostVisibility();\n                } else {\n                    _this2._gainedVisibility();\n                }\n            }, false);\n\n            requestAnimationFrame(this._updateRAFTime.bind(this));\n        }\n    }, {\n        key: \"_updateWorkerTime\",\n        value: function _updateWorkerTime(time) {\n            var dt = (time - this._previousWorkerTime) / 1000;\n            if (dt !== 0) this._update(dt);\n            this._previousWorkerTime = time;\n        }\n    }, {\n        key: \"_updateRAFTime\",\n        value: function _updateRAFTime(time) {\n            if (this._previousRAFTime === undefined) this._previousRAFTime = time;\n            var dt = (time - this._previousRAFTime) / 1000;\n            if (dt !== 0) this._update(dt);\n            this._previousRAFTime = time;\n            if (!this._useWebworker) requestAnimationFrame(this._updateRAFTime.bind(this));\n        }\n    }, {\n        key: \"_update\",\n        value: function _update(dt) {\n            for (var i = 0; i < this._updateables.length; i++) {\n                this._updateables[i]._update(parseFloat(dt));\n            }\n        }\n    }, {\n        key: \"register\",\n        value: function register(updateable) {\n            this._updateables.push(updateable);\n            if (this._active === false) {\n                this._active = true;\n                this._init();\n            }\n        }\n    }]);\n\n    return UpdateablesManager;\n}();\n\nfunction mediaElementHasSource(_ref) {\n    var src = _ref.src,\n        srcObject = _ref.srcObject;\n\n    return !((src === \"\" || src === undefined) && srcObject == null);\n}\n\n/***/ }),\n\n/***/ \"./src/videocontext.js\":\n/*!*****************************!*\\\n  !*** ./src/videocontext.js ***!\n  \\*****************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_238201__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //Matthew Shotton, R&D User Experience,© BBC 2015\n\n\nvar _utils = __nested_webpack_require_238201__(/*! ./utils.js */ \"./src/utils.js\");\n\nvar _nodes = __nested_webpack_require_238201__(/*! ./SourceNodes/nodes.js */ \"./src/SourceNodes/nodes.js\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _videonode = __nested_webpack_require_238201__(/*! ./SourceNodes/videonode.js */ \"./src/SourceNodes/videonode.js\");\n\nvar _videonode2 = _interopRequireDefault(_videonode);\n\nvar _audionode = __nested_webpack_require_238201__(/*! ./SourceNodes/audionode.js */ \"./src/SourceNodes/audionode.js\");\n\nvar _audionode2 = _interopRequireDefault(_audionode);\n\nvar _imagenode = __nested_webpack_require_238201__(/*! ./SourceNodes/imagenode.js */ \"./src/SourceNodes/imagenode.js\");\n\nvar _imagenode2 = _interopRequireDefault(_imagenode);\n\nvar _canvasnode = __nested_webpack_require_238201__(/*! ./SourceNodes/canvasnode.js */ \"./src/SourceNodes/canvasnode.js\");\n\nvar _canvasnode2 = _interopRequireDefault(_canvasnode);\n\nvar _sourcenode = __nested_webpack_require_238201__(/*! ./SourceNodes/sourcenode.js */ \"./src/SourceNodes/sourcenode.js\");\n\nvar _compositingnode = __nested_webpack_require_238201__(/*! ./ProcessingNodes/compositingnode.js */ \"./src/ProcessingNodes/compositingnode.js\");\n\nvar _compositingnode2 = _interopRequireDefault(_compositingnode);\n\nvar _destinationnode = __nested_webpack_require_238201__(/*! ./DestinationNode/destinationnode.js */ \"./src/DestinationNode/destinationnode.js\");\n\nvar _destinationnode2 = _interopRequireDefault(_destinationnode);\n\nvar _effectnode = __nested_webpack_require_238201__(/*! ./ProcessingNodes/effectnode.js */ \"./src/ProcessingNodes/effectnode.js\");\n\nvar _effectnode2 = _interopRequireDefault(_effectnode);\n\nvar _transitionnode = __nested_webpack_require_238201__(/*! ./ProcessingNodes/transitionnode.js */ \"./src/ProcessingNodes/transitionnode.js\");\n\nvar _transitionnode2 = _interopRequireDefault(_transitionnode);\n\nvar _rendergraph = __nested_webpack_require_238201__(/*! ./rendergraph.js */ \"./src/rendergraph.js\");\n\nvar _rendergraph2 = _interopRequireDefault(_rendergraph);\n\nvar _videoelementcache = __nested_webpack_require_238201__(/*! ./videoelementcache.js */ \"./src/videoelementcache.js\");\n\nvar _videoelementcache2 = _interopRequireDefault(_videoelementcache);\n\nvar _definitions = __nested_webpack_require_238201__(/*! ./Definitions/definitions.js */ \"./src/Definitions/definitions.js\");\n\nvar _definitions2 = _interopRequireDefault(_definitions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar updateablesManager = new _utils.UpdateablesManager();\n\n/**\n * VideoContext.\n * @module VideoContext\n */\n\nvar VideoContext = function () {\n    /**\n     * Initialise the VideoContext and render to the specific canvas. A 2nd parameter can be passed to the constructor which is a function that get's called if the VideoContext fails to initialise.\n     *\n     * @param {Canvas} canvas - the canvas element to render the output to.\n     * @param {function} [initErrorCallback] - a callback for if initialising the canvas failed.\n     * @param {Object} [options] - a number of custom options which can be set on the VideoContext, generally best left as default.\n     * @param {boolean} [options.manualUpdate=false] - Make Video Context not use the updatable manager\n     * @param {boolean} [options.endOnLastSourceEnd=true] - Trigger an `ended` event when the current time goes above the duration of the composition\n     * @param {boolean} [options.useVideoElementCache=true] - Creates a pool of video element that will be all initialised at the same time. Important for mobile support\n     * @param {number} [options.videoElementCacheSize=6] - Number of video element in the pool\n     * @param {object} [options.webglContextAttributes] - A set of attributes used when getting the GL context. Alpha will always be `true`.\n     *\n     * @example\n     * var canvasElement = document.getElementById(\"canvas\");\n     * var ctx = new VideoContext(canvasElement, () => console.error(\"Sorry, your browser dosen\\'t support WebGL\"));\n     * var videoNode = ctx.video(\"video.mp4\");\n     * videoNode.connect(ctx.destination);\n     * videoNode.start(0);\n     * videoNode.stop(10);\n     * ctx.play();\n     *\n     */\n    function VideoContext(canvas, initErrorCallback) {\n        var _this = this;\n\n        var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n            _ref$manualUpdate = _ref.manualUpdate,\n            manualUpdate = _ref$manualUpdate === undefined ? false : _ref$manualUpdate,\n            _ref$endOnLastSourceE = _ref.endOnLastSourceEnd,\n            endOnLastSourceEnd = _ref$endOnLastSourceE === undefined ? true : _ref$endOnLastSourceE,\n            _ref$useVideoElementC = _ref.useVideoElementCache,\n            useVideoElementCache = _ref$useVideoElementC === undefined ? true : _ref$useVideoElementC,\n            _ref$videoElementCach = _ref.videoElementCacheSize,\n            videoElementCacheSize = _ref$videoElementCach === undefined ? 6 : _ref$videoElementCach,\n            _ref$webglContextAttr = _ref.webglContextAttributes,\n            webglContextAttributes = _ref$webglContextAttr === undefined ? {} : _ref$webglContextAttr;\n\n        _classCallCheck(this, VideoContext);\n\n        this._canvas = canvas;\n        this._endOnLastSourceEnd = endOnLastSourceEnd;\n\n        this._gl = canvas.getContext(\"webgl2\", Object.assign({ preserveDrawingBuffer: true }, // can be overriden\n        webglContextAttributes, { alpha: false // Can't be overriden because it is copied last\n        }));\n        if (this._gl === null) {\n            console.error(\"Failed to intialise WebGL.\");\n            if (initErrorCallback) initErrorCallback();\n            return;\n        }\n\n        // Initialise the video element cache\n        this._useVideoElementCache = useVideoElementCache;\n        if (this._useVideoElementCache) {\n            this._videoElementCache = new _videoelementcache2.default(videoElementCacheSize);\n        }\n\n        // Create a unique ID for this VideoContext which can be used in the debugger.\n        if (this._canvas.id) {\n            if (typeof this._canvas.id === \"string\" || this._canvas.id instanceof String) {\n                this._id = canvas.id;\n            }\n        }\n        if (this._id === undefined) this._id = (0, _utils.generateRandomId)();\n        if (window.__VIDEOCONTEXT_REFS__ === undefined) window.__VIDEOCONTEXT_REFS__ = {};\n        window.__VIDEOCONTEXT_REFS__[this._id] = this;\n\n        this._renderGraph = new _rendergraph2.default();\n        this._sourceNodes = [];\n        this._processingNodes = [];\n        this._timeline = [];\n        this._currentTime = 0;\n        this._state = VideoContext.STATE.PAUSED;\n        this._playbackRate = 1.0;\n        this._volume = 1.0;\n        this._sourcesPlaying = undefined;\n        this._destinationNode = new _destinationnode2.default(this._gl, this._renderGraph);\n\n        this._callbacks = new Map();\n        Object.keys(VideoContext.EVENTS).forEach(function (name) {\n            return _this._callbacks.set(VideoContext.EVENTS[name], []);\n        });\n\n        this._timelineCallbacks = [];\n\n        if (!manualUpdate) {\n            updateablesManager.register(this);\n        }\n    }\n\n    /**\n     * Returns an ID assigned to the VideoContext instance. This will either be the same id as the underlying canvas element,\n     * or a uniquely generated one.\n     */\n\n\n    _createClass(VideoContext, [{\n        key: \"registerTimelineCallback\",\n\n\n        /**\n         * Register a callback to happen at a specific point in time.\n         * @param {number} time - the time at which to trigger the callback.\n         * @param {Function} func - the callback to register.\n         * @param {number} ordering - the order in which to call the callback if more than one is registered for the same time.\n         */\n        value: function registerTimelineCallback(time, func) {\n            var ordering = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n            this._timelineCallbacks.push({\n                time: time,\n                func: func,\n                ordering: ordering\n            });\n        }\n\n        /**\n         * Unregister a callback which happens at a specific point in time.\n         * @param {Function} func - the callback to unregister.\n         */\n\n    }, {\n        key: \"unregisterTimelineCallback\",\n        value: function unregisterTimelineCallback(func) {\n            var toRemove = [];\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this._timelineCallbacks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var callback = _step.value;\n\n                    if (callback.func === func) {\n                        toRemove.push(callback);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = toRemove[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var _callback = _step2.value;\n\n                    var index = this._timelineCallbacks.indexOf(_callback);\n                    this._timelineCallbacks.splice(index, 1);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Register a callback to listen to one of the events defined in `VideoContext.EVENTS`\n         *\n         * @param {String} type - the event to register against.\n         * @param {Function} func - the callback to register.\n         *\n         * @example\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         * ctx.registerCallback(VideoContext.EVENTS.STALLED, () => console.log(\"Playback stalled\"));\n         * ctx.registerCallback(VideoContext.EVENTS.UPDATE, () => console.log(\"new frame\"));\n         * ctx.registerCallback(VideoContext.EVENTS.ENDED, () => console.log(\"Playback ended\"));\n         */\n\n    }, {\n        key: \"registerCallback\",\n        value: function registerCallback(type, func) {\n            if (!this._callbacks.has(type)) return false;\n            this._callbacks.get(type).push(func);\n        }\n\n        /**\n         * Remove a previously registered callback\n         *\n         * @param {Function} func - the callback to remove.\n         *\n         * @example\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         *\n         * //the callback\n         * var updateCallback = () => console.log(\"new frame\");\n         *\n         * //register the callback\n         * ctx.registerCallback(VideoContext.EVENTS.UPDATE, updateCallback);\n         * //then unregister it\n         * ctx.unregisterCallback(updateCallback);\n         *\n         */\n\n    }, {\n        key: \"unregisterCallback\",\n        value: function unregisterCallback(func) {\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this._callbacks.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var funcArray = _step3.value;\n\n                    var index = funcArray.indexOf(func);\n                    if (index !== -1) {\n                        funcArray.splice(index, 1);\n                        return true;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            return false;\n        }\n    }, {\n        key: \"_callCallbacks\",\n        value: function _callCallbacks(type) {\n            var funcArray = this._callbacks.get(type);\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n                for (var _iterator4 = funcArray[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var func = _step4.value;\n\n                    func(this._currentTime);\n                }\n            } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                    }\n                } finally {\n                    if (_didIteratorError4) {\n                        throw _iteratorError4;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Get the canvas that the VideoContext is using.\n         *\n         * @return {HTMLCanvasElement} The canvas that the VideoContext is using.\n         *\n         */\n\n    }, {\n        key: \"play\",\n\n\n        /**\n         * Start the VideoContext playing\n         * @example\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         * var videoNode = ctx.video(\"video.mp4\");\n         * videoNode.connect(ctx.destination);\n         * videoNode.start(0);\n         * videoNode.stop(10);\n         * ctx.play();\n         */\n        value: function play() {\n            console.debug(\"VideoContext - playing\");\n            //Initialise the video element cache\n            if (this._videoElementCache) this._videoElementCache.init();\n            // set the state.\n            this._state = VideoContext.STATE.PLAYING;\n            return true;\n        }\n\n        /**\n         * Pause playback of the VideoContext\n         * @example\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         * var videoNode = ctx.video(\"video.mp4\");\n         * videoNode.connect(ctx.destination);\n         * videoNode.start(0);\n         * videoNode.stop(20);\n         * ctx.currentTime = 10; // seek 10 seconds in\n         * ctx.play();\n         * setTimeout(() => ctx.pause(), 1000); //pause playback after roughly one second.\n         */\n\n    }, {\n        key: \"pause\",\n        value: function pause() {\n            console.debug(\"VideoContext - pausing\");\n            this._state = VideoContext.STATE.PAUSED;\n            return true;\n        }\n\n        /**\n         * Create a new node representing a video source\n         *\n         * @param {string|HTMLVideoElement|MediaStream} - The URL or video element to create the video from.\n         * @param {number} [sourceOffset=0] - Offset into the start of the source video to start playing from.\n         * @param {number} [preloadTime=4] - How many seconds before the video is to be played to start loading it.\n         * @param {Object} [videoElementAttributes] - A dictionary of attributes to map onto the underlying video element.\n         * @return {VideoNode} A new video node.\n         *\n         * @example\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         * var videoNode = ctx.video(\"bigbuckbunny.mp4\");\n         */\n\n    }, {\n        key: \"video\",\n        value: function video(src) {\n            var sourceOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var preloadTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n            var videoElementAttributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n            var videoNode = new _videonode2.default(src, this._gl, this._renderGraph, this._currentTime, this._playbackRate, sourceOffset, preloadTime, this._videoElementCache, videoElementAttributes);\n            this._sourceNodes.push(videoNode);\n            return videoNode;\n        }\n\n        /**\n         * Create a new node representing an audio source\n         * @param {string|HTMLAudioElement|MediaStream} src - The url or audio element to create the audio node from.\n         * @param {number} [sourceOffset=0] - Offset into the start of the source audio to start playing from.\n         * @param {number} [preloadTime=4] - How long before a node is to be displayed to attmept to load it.\n         * @param {Object} [imageElementAttributes] - Any attributes to be given to the underlying image element.\n         * @return {AudioNode} A new audio node.\n         *\n         * @example\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         * var audioNode = ctx.audio(\"ziggystardust.mp3\");\n         */\n\n    }, {\n        key: \"audio\",\n        value: function audio(src) {\n            var sourceOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var preloadTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n            var audioElementAttributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n            var audioNode = new _audionode2.default(src, this._gl, this._renderGraph, this._currentTime, this._playbackRate, sourceOffset, preloadTime, this._audioElementCache, audioElementAttributes);\n            this._sourceNodes.push(audioNode);\n            return audioNode;\n        }\n\n        /**\n         * @deprecated\n         */\n\n    }, {\n        key: \"createVideoSourceNode\",\n        value: function createVideoSourceNode(src) {\n            var sourceOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var preloadTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n            var videoElementAttributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n            this._deprecate(\"Warning: createVideoSourceNode will be deprecated in v1.0, please switch to using VideoContext.video()\");\n            return this.video(src, sourceOffset, preloadTime, videoElementAttributes);\n        }\n\n        /**\n         * Create a new node representing an image source\n         * @param {string|Image|ImageBitmap} src - The url or image element to create the image node from.\n         * @param {number} [preloadTime=4] - How long before a node is to be displayed to attmept to load it.\n         * @param {Object} [imageElementAttributes] - Any attributes to be given to the underlying image element.\n         * @return {ImageNode} A new image node.\n         *\n         * @example\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         * var imageNode = ctx.image(\"image.png\");\n         *\n         * @example\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var imageElement = document.getElementById(\"image\");\n         * var ctx = new VideoContext(canvasElement);\n         * var imageNode = ctx.image(imageElement);\n         */\n\n    }, {\n        key: \"image\",\n        value: function image(src) {\n            var preloadTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n            var imageElementAttributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n            var imageNode = new _imagenode2.default(src, this._gl, this._renderGraph, this._currentTime, preloadTime, imageElementAttributes);\n            this._sourceNodes.push(imageNode);\n            return imageNode;\n        }\n\n        /**\n         * @deprecated\n         */\n\n    }, {\n        key: \"createImageSourceNode\",\n        value: function createImageSourceNode(src) {\n            var sourceOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var preloadTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n            var imageElementAttributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n            this._deprecate(\"Warning: createImageSourceNode will be deprecated in v1.0, please switch to using VideoContext.image()\");\n            return this.image(src, sourceOffset, preloadTime, imageElementAttributes);\n        }\n\n        /**\n         * Create a new node representing a canvas source\n         * @param {Canvas} src - The canvas element to create the canvas node from.\n         * @return {CanvasNode} A new canvas node.\n         */\n\n    }, {\n        key: \"canvas\",\n        value: function canvas(_canvas) {\n            var canvasNode = new _canvasnode2.default(_canvas, this._gl, this._renderGraph, this._currentTime);\n            this._sourceNodes.push(canvasNode);\n            return canvasNode;\n        }\n\n        /**\n         * @deprecated\n         */\n\n    }, {\n        key: \"createCanvasSourceNode\",\n        value: function createCanvasSourceNode(canvas) {\n            var sourceOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var preloadTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n\n            this._deprecate(\"Warning: createCanvasSourceNode will be deprecated in v1.0, please switch to using VideoContext.canvas()\");\n            return this.canvas(canvas, sourceOffset, preloadTime);\n        }\n\n        /**\n         * Create a new effect node.\n         * @param {Object} definition - this is an object defining the shaders, inputs, and properties of the compositing node to create. Builtin definitions can be found by accessing VideoContext.DEFINITIONS.\n         * @return {EffectNode} A new effect node created from the passed definition\n         */\n\n    }, {\n        key: \"effect\",\n        value: function effect(definition) {\n            var effectNode = new _effectnode2.default(this._gl, this._renderGraph, definition);\n            this._processingNodes.push(effectNode);\n            return effectNode;\n        }\n\n        /**\n         * @deprecated\n         */\n\n    }, {\n        key: \"createEffectNode\",\n        value: function createEffectNode(definition) {\n            this._deprecate(\"Warning: createEffectNode will be deprecated in v1.0, please switch to using VideoContext.effect()\");\n            return this.effect(definition);\n        }\n\n        /**\n         * Create a new compositiing node.\n         *\n         * Compositing nodes are used for operations such as combining multiple video sources into a single track/connection for further processing in the graph.\n         *\n         * A compositing node is slightly different to other processing nodes in that it only has one input in it's definition but can have unlimited connections made to it.\n         * The shader in the definition is run for each input in turn, drawing them to the output buffer. This means there can be no interaction between the spearte inputs to a compositing node, as they are individually processed in seperate shader passes.\n         *\n         * @param {Object} definition - this is an object defining the shaders, inputs, and properties of the compositing node to create. Builtin definitions can be found by accessing VideoContext.DEFINITIONS\n         *\n         * @return {CompositingNode} A new compositing node created from the passed definition.\n         *\n         * @example\n         *\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         *\n         * //A simple compositing node definition which just renders all the inputs to the output buffer.\n         * var combineDefinition = {\n         *     vertexShader : \"\\\n         *         attribute vec2 a_position;\\\n         *         attribute vec2 a_texCoord;\\\n         *         varying vec2 v_texCoord;\\\n         *         void main() {\\\n         *             gl_Position = vec4(vec2(2.0,2.0)*vec2(1.0, 1.0), 0.0, 1.0);\\\n         *             v_texCoord = a_texCoord;\\\n         *         }\",\n         *     fragmentShader : \"\\\n         *         precision mediump float;\\\n         *         uniform sampler2D u_image;\\\n         *         uniform float a;\\\n         *         varying vec2 v_texCoord;\\\n         *         varying float v_progress;\\\n         *         void main(){\\\n         *             vec4 color = texture2D(u_image, v_texCoord);\\\n         *             gl_FragColor = color;\\\n         *         }\",\n         *     properties:{\n         *         \"a\":{type:\"uniform\", value:0.0},\n         *     },\n         *     inputs:[\"u_image\"]\n         * };\n         * //Create the node, passing in the definition.\n         * var trackNode = videoCtx.compositor(combineDefinition);\n         *\n         * //create two videos which will play at back to back\n         * var videoNode1 = ctx.video(\"video1.mp4\");\n         * videoNode1.play(0);\n         * videoNode1.stop(10);\n         * var videoNode2 = ctx.video(\"video2.mp4\");\n         * videoNode2.play(10);\n         * videoNode2.stop(20);\n         *\n         * //Connect the nodes to the combine node. This will give a single connection representing the two videos which can\n         * //be connected to other effects such as LUTs, chromakeyers, etc.\n         * videoNode1.connect(trackNode);\n         * videoNode2.connect(trackNode);\n         *\n         * //Don't do anything exciting, just connect it to the output.\n         * trackNode.connect(ctx.destination);\n         *\n         */\n\n    }, {\n        key: \"compositor\",\n        value: function compositor(definition) {\n            var compositingNode = new _compositingnode2.default(this._gl, this._renderGraph, definition);\n            this._processingNodes.push(compositingNode);\n            return compositingNode;\n        }\n\n        /**\n         * Instanciate a custom built source node\n         * @param {SourceNode} CustomSourceNode\n         * @param {Object} src\n         * @param  {...any} options\n         */\n\n    }, {\n        key: \"customSourceNode\",\n        value: function customSourceNode(CustomSourceNode, src) {\n            for (var _len = arguments.length, options = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n                options[_key - 2] = arguments[_key];\n            }\n\n            var customSourceNode = new (Function.prototype.bind.apply(CustomSourceNode, [null].concat([src, this._gl, this._renderGraph, this._currentTime], options)))();\n            this._sourceNodes.push(customSourceNode);\n            return customSourceNode;\n        }\n\n        /**\n         * @depricated\n         */\n\n    }, {\n        key: \"createCompositingNode\",\n        value: function createCompositingNode(definition) {\n            this._deprecate(\"Warning: createCompositingNode will be deprecated in v1.0, please switch to using VideoContext.compositor()\");\n            return this.compositor(definition);\n        }\n\n        /**\n         * Create a new transition node.\n         *\n         * Transistion nodes are a type of effect node which have parameters which can be changed as events on the timeline.\n         *\n         * For example a transition node which cross-fades between two videos could have a \"mix\" property which sets the\n         * progress through the transistion. Rather than having to write your own code to adjust this property at specfic\n         * points in time a transition node has a \"transition\" function which takes a startTime, stopTime, targetValue, and a\n         * propertyName (which will be \"mix\"). This will linearly interpolate the property from the curernt value to\n         * tragetValue between the startTime and stopTime.\n         *\n         * @param {Object} definition - this is an object defining the shaders, inputs, and properties of the transition node to create.\n         * @return {TransitionNode} A new transition node created from the passed definition.\n         * @example\n         *\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         *\n         * //A simple cross-fade node definition which cross-fades between two videos based on the mix property.\n         * var crossfadeDefinition = {\n         *     vertexShader : \"\\\n         *        attribute vec2 a_position;\\\n         *        attribute vec2 a_texCoord;\\\n         *        varying vec2 v_texCoord;\\\n         *        void main() {\\\n         *            gl_Position = vec4(vec2(2.0,2.0)*a_position-vec2(1.0, 1.0), 0.0, 1.0);\\\n         *            v_texCoord = a_texCoord;\\\n         *         }\",\n         *     fragmentShader : \"\\\n         *         precision mediump float;\\\n         *         uniform sampler2D u_image_a;\\\n         *         uniform sampler2D u_image_b;\\\n         *         uniform float mix;\\\n         *         varying vec2 v_texCoord;\\\n         *         varying float v_mix;\\\n         *         void main(){\\\n         *             vec4 color_a = texture2D(u_image_a, v_texCoord);\\\n         *             vec4 color_b = texture2D(u_image_b, v_texCoord);\\\n         *             color_a[0] *= mix;\\\n         *             color_a[1] *= mix;\\\n         *             color_a[2] *= mix;\\\n         *             color_a[3] *= mix;\\\n         *             color_b[0] *= (1.0 - mix);\\\n         *             color_b[1] *= (1.0 - mix);\\\n         *             color_b[2] *= (1.0 - mix);\\\n         *             color_b[3] *= (1.0 - mix);\\\n         *             gl_FragColor = color_a + color_b;\\\n         *         }\",\n         *     properties:{\n         *         \"mix\":{type:\"uniform\", value:0.0},\n         *     },\n         *     inputs:[\"u_image_a\",\"u_image_b\"]\n         * };\n         *\n         * //Create the node, passing in the definition.\n         * var transitionNode = videoCtx.transition(crossfadeDefinition);\n         *\n         * //create two videos which will overlap by two seconds\n         * var videoNode1 = ctx.video(\"video1.mp4\");\n         * videoNode1.play(0);\n         * videoNode1.stop(10);\n         * var videoNode2 = ctx.video(\"video2.mp4\");\n         * videoNode2.play(8);\n         * videoNode2.stop(18);\n         *\n         * //Connect the nodes to the transistion node.\n         * videoNode1.connect(transitionNode);\n         * videoNode2.connect(transitionNode);\n         *\n         * //Set-up a transition which happens at the crossover point of the playback of the two videos\n         * transitionNode.transition(8,10,1.0,\"mix\");\n         *\n         * //Connect the transition node to the output\n         * transitionNode.connect(ctx.destination);\n         *\n         * //start playback\n         * ctx.play();\n         */\n\n    }, {\n        key: \"transition\",\n        value: function transition(definition) {\n            var transitionNode = new _transitionnode2.default(this._gl, this._renderGraph, definition);\n            this._processingNodes.push(transitionNode);\n            return transitionNode;\n        }\n\n        /**\n         * @deprecated\n         */\n\n    }, {\n        key: \"createTransitionNode\",\n        value: function createTransitionNode(definition) {\n            this._deprecate(\"Warning: createTransitionNode will be deprecated in v1.0, please switch to using VideoContext.transition()\");\n            return this.transition(definition);\n        }\n    }, {\n        key: \"_isStalled\",\n        value: function _isStalled() {\n            for (var i = 0; i < this._sourceNodes.length; i++) {\n                var sourceNode = this._sourceNodes[i];\n                if (!sourceNode._isReady()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * This allows manual calling of the update loop of the videoContext.\n         *\n         * @param {Number} dt - The difference in seconds between this and the previous calling of update.\n         * @example\n         *\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement, undefined, {\"manualUpdate\" : true});\n         *\n         * var previousTime;\n         * function update(time){\n         *     if (previousTime === undefined) previousTime = time;\n         *     var dt = (time - previousTime)/1000;\n         *     ctx.update(dt);\n         *     previousTime = time;\n         *     requestAnimationFrame(update);\n         * }\n         * update();\n         *\n         */\n\n    }, {\n        key: \"update\",\n        value: function update(dt) {\n            this._update(dt);\n        }\n    }, {\n        key: \"_update\",\n        value: function _update(dt) {\n            //Remove any destroyed nodes\n            this._sourceNodes = this._sourceNodes.filter(function (sourceNode) {\n                if (!sourceNode.destroyed) return sourceNode;\n            });\n\n            this._processingNodes = this._processingNodes.filter(function (processingNode) {\n                if (!processingNode.destroyed) return processingNode;\n            });\n\n            if (this._state === VideoContext.STATE.PLAYING || this._state === VideoContext.STATE.STALLED || this._state === VideoContext.STATE.PAUSED) {\n                this._callCallbacks(VideoContext.EVENTS.UPDATE);\n\n                if (this._state !== VideoContext.STATE.PAUSED) {\n                    if (this._isStalled()) {\n                        this._callCallbacks(VideoContext.EVENTS.STALLED);\n                        this._state = VideoContext.STATE.STALLED;\n                    } else {\n                        this._state = VideoContext.STATE.PLAYING;\n                    }\n                }\n\n                if (this._state === VideoContext.STATE.PLAYING) {\n                    //Handle timeline callbacks.\n                    var activeCallbacks = new Map();\n                    var _iteratorNormalCompletion5 = true;\n                    var _didIteratorError5 = false;\n                    var _iteratorError5 = undefined;\n\n                    try {\n                        for (var _iterator5 = this._timelineCallbacks[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                            var callback = _step5.value;\n\n                            if (callback.time >= this.currentTime && callback.time < this._currentTime + dt * this._playbackRate) {\n                                //group the callbacks by time\n                                if (!activeCallbacks.has(callback.time)) activeCallbacks.set(callback.time, []);\n                                activeCallbacks.get(callback.time).push(callback);\n                            }\n                        }\n\n                        //Sort the groups of callbacks by the times of the groups\n                    } catch (err) {\n                        _didIteratorError5 = true;\n                        _iteratorError5 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                                _iterator5.return();\n                            }\n                        } finally {\n                            if (_didIteratorError5) {\n                                throw _iteratorError5;\n                            }\n                        }\n                    }\n\n                    var timeIntervals = Array.from(activeCallbacks.keys());\n                    timeIntervals.sort(function (a, b) {\n                        return a - b;\n                    });\n\n                    var _iteratorNormalCompletion6 = true;\n                    var _didIteratorError6 = false;\n                    var _iteratorError6 = undefined;\n\n                    try {\n                        for (var _iterator6 = timeIntervals[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                            var t = _step6.value;\n\n                            var callbacks = activeCallbacks.get(t);\n                            callbacks.sort(function (a, b) {\n                                return a.ordering - b.ordering;\n                            });\n                            var _iteratorNormalCompletion7 = true;\n                            var _didIteratorError7 = false;\n                            var _iteratorError7 = undefined;\n\n                            try {\n                                for (var _iterator7 = callbacks[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                                    var _callback2 = _step7.value;\n\n                                    _callback2.func();\n                                }\n                            } catch (err) {\n                                _didIteratorError7 = true;\n                                _iteratorError7 = err;\n                            } finally {\n                                try {\n                                    if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                                        _iterator7.return();\n                                    }\n                                } finally {\n                                    if (_didIteratorError7) {\n                                        throw _iteratorError7;\n                                    }\n                                }\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError6 = true;\n                        _iteratorError6 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                                _iterator6.return();\n                            }\n                        } finally {\n                            if (_didIteratorError6) {\n                                throw _iteratorError6;\n                            }\n                        }\n                    }\n\n                    this._currentTime += dt * this._playbackRate;\n                    if (this._currentTime > this.duration && this._endOnLastSourceEnd) {\n                        //Do an update od the sourcenodes in case anything in the \"ended\" callbacks modifes currentTime and sources haven't had a chance to stop.\n                        for (var i = 0; i < this._sourceNodes.length; i++) {\n                            this._sourceNodes[i]._update(this._currentTime);\n                        }\n                        this._state = VideoContext.STATE.ENDED;\n                        this._callCallbacks(VideoContext.EVENTS.ENDED);\n                    }\n                }\n\n                var sourcesPlaying = false;\n\n                for (var _i = 0; _i < this._sourceNodes.length; _i++) {\n                    var sourceNode = this._sourceNodes[_i];\n\n                    if (this._state === VideoContext.STATE.STALLED) {\n                        if (sourceNode._isReady() && sourceNode._state === _sourcenode.SOURCENODESTATE.playing) sourceNode._pause();\n                    }\n                    if (this._state === VideoContext.STATE.PAUSED) {\n                        sourceNode._pause();\n                    }\n                    if (this._state === VideoContext.STATE.PLAYING) {\n                        sourceNode._play();\n                    }\n                    sourceNode._update(this._currentTime);\n                    if (sourceNode._state === _sourcenode.SOURCENODESTATE.paused || sourceNode._state === _sourcenode.SOURCENODESTATE.playing) {\n                        sourcesPlaying = true;\n                    }\n                }\n\n                if (sourcesPlaying !== this._sourcesPlaying && this._state === VideoContext.STATE.PLAYING) {\n                    if (sourcesPlaying === true) {\n                        this._callCallbacks(VideoContext.EVENTS.CONTENT);\n                    } else {\n                        this._callCallbacks(VideoContext.EVENTS.NOCONTENT);\n                    }\n                    this._sourcesPlaying = sourcesPlaying;\n                }\n\n                /*\n                 * Itterate the directed acyclic graph using Khan's algorithm (KHAAAAAN!).\n                 *\n                 * This has highlighted a bunch of ineffencies in the rendergraph class about how its stores connections.\n                 * Mainly the fact that to get inputs for a node you have to iterate the full list of connections rather than\n                 * a node owning it's connections.\n                 * The trade off with changing this is making/removing connections becomes more costly performance wise, but\n                 * this is definitely worth while because getting the connnections is a much more common operation.\n                 *\n                 * TL;DR Future matt - refactor this.\n                 *\n                 */\n                var sortedNodes = [];\n                var connections = this._renderGraph.connections.slice();\n                var nodes = _rendergraph2.default.getInputlessNodes(connections);\n\n                while (nodes.length > 0) {\n                    var node = nodes.pop();\n                    sortedNodes.push(node);\n                    var _iteratorNormalCompletion8 = true;\n                    var _didIteratorError8 = false;\n                    var _iteratorError8 = undefined;\n\n                    try {\n                        for (var _iterator8 = _rendergraph2.default.outputEdgesFor(node, connections)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                            var edge = _step8.value;\n\n                            var index = connections.indexOf(edge);\n                            if (index > -1) connections.splice(index, 1);\n                            if (_rendergraph2.default.inputEdgesFor(edge.destination, connections).length === 0) {\n                                nodes.push(edge.destination);\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError8 = true;\n                        _iteratorError8 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                                _iterator8.return();\n                            }\n                        } finally {\n                            if (_didIteratorError8) {\n                                throw _iteratorError8;\n                            }\n                        }\n                    }\n                }\n\n                var _iteratorNormalCompletion9 = true;\n                var _didIteratorError9 = false;\n                var _iteratorError9 = undefined;\n\n                try {\n                    for (var _iterator9 = sortedNodes[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                        var _node = _step9.value;\n\n                        if (this._sourceNodes.indexOf(_node) === -1) {\n                            _node._update(this._currentTime);\n                            _node._render();\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError9 = true;\n                    _iteratorError9 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                            _iterator9.return();\n                        }\n                    } finally {\n                        if (_didIteratorError9) {\n                            throw _iteratorError9;\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Destroy all nodes in the graph and reset the timeline. After calling this any created nodes will be unusable.\n         */\n\n    }, {\n        key: \"reset\",\n        value: function reset() {\n            var _this2 = this;\n\n            var _iteratorNormalCompletion10 = true;\n            var _didIteratorError10 = false;\n            var _iteratorError10 = undefined;\n\n            try {\n                for (var _iterator10 = this._callbacks[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                    var callback = _step10.value;\n\n                    this.unregisterCallback(callback);\n                }\n            } catch (err) {\n                _didIteratorError10 = true;\n                _iteratorError10 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                        _iterator10.return();\n                    }\n                } finally {\n                    if (_didIteratorError10) {\n                        throw _iteratorError10;\n                    }\n                }\n            }\n\n            var _iteratorNormalCompletion11 = true;\n            var _didIteratorError11 = false;\n            var _iteratorError11 = undefined;\n\n            try {\n                for (var _iterator11 = this._sourceNodes[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n                    var node = _step11.value;\n\n                    node.destroy();\n                }\n            } catch (err) {\n                _didIteratorError11 = true;\n                _iteratorError11 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion11 && _iterator11.return) {\n                        _iterator11.return();\n                    }\n                } finally {\n                    if (_didIteratorError11) {\n                        throw _iteratorError11;\n                    }\n                }\n            }\n\n            var _iteratorNormalCompletion12 = true;\n            var _didIteratorError12 = false;\n            var _iteratorError12 = undefined;\n\n            try {\n                for (var _iterator12 = this._processingNodes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n                    var _node2 = _step12.value;\n\n                    _node2.destroy();\n                }\n            } catch (err) {\n                _didIteratorError12 = true;\n                _iteratorError12 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion12 && _iterator12.return) {\n                        _iterator12.return();\n                    }\n                } finally {\n                    if (_didIteratorError12) {\n                        throw _iteratorError12;\n                    }\n                }\n            }\n\n            this._update(0);\n            this._sourceNodes = [];\n            this._processingNodes = [];\n            this._timeline = [];\n            this._currentTime = 0;\n            this._state = VideoContext.STATE.PAUSED;\n            this._playbackRate = 1.0;\n            this._sourcesPlaying = undefined;\n            Object.keys(VideoContext.EVENTS).forEach(function (name) {\n                return _this2._callbacks.set(VideoContext.EVENTS[name], []);\n            });\n            this._timelineCallbacks = [];\n        }\n    }, {\n        key: \"_deprecate\",\n        value: function _deprecate(msg) {\n            console.log(msg);\n        }\n    }, {\n        key: \"snapshot\",\n\n\n        /**\n         * Get a JS Object containing the state of the VideoContext instance and all the created nodes.\n         */\n        value: function snapshot() {\n            return (0, _utils.snapshot)(this);\n        }\n    }, {\n        key: \"id\",\n        get: function get() {\n            return this._id;\n        }\n\n        /**\n         * Set the ID of the VideoContext instance. This should be unique.\n         */\n        ,\n        set: function set(newID) {\n            delete window.__VIDEOCONTEXT_REFS__[this._id];\n            if (window.__VIDEOCONTEXT_REFS__[newID] !== undefined) console.warn(\"Warning; setting id to that of an existing VideoContext instance.\");\n            window.__VIDEOCONTEXT_REFS__[newID] = this;\n            this._id = newID;\n        }\n    }, {\n        key: \"element\",\n        get: function get() {\n            return this._canvas;\n        }\n\n        /**\n         * Get the current state.\n         * @return {STATE} The number representing the state.\n         *\n         */\n\n    }, {\n        key: \"state\",\n        get: function get() {\n            return this._state;\n        }\n\n        /**\n         * Set the progress through the internal timeline.\n         * Setting this can be used as a way to implement a scrubbable timeline.\n         *\n         * @param {number} currentTime - this is the currentTime to set in seconds.\n         *\n         * @example\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         * var videoNode = ctx.video(\"video.mp4\");\n         * videoNode.connect(ctx.destination);\n         * videoNode.start(0);\n         * videoNode.stop(20);\n         * ctx.currentTime = 10; // seek 10 seconds in\n         * ctx.play();\n         *\n         */\n\n    }, {\n        key: \"currentTime\",\n        set: function set(currentTime) {\n            if (currentTime < this.duration && this._state === VideoContext.STATE.ENDED) this._state = VideoContext.STATE.PAUSED;\n\n            if (typeof currentTime === \"string\" || currentTime instanceof String) {\n                currentTime = parseFloat(currentTime);\n            }\n\n            for (var i = 0; i < this._sourceNodes.length; i++) {\n                this._sourceNodes[i]._seek(currentTime);\n            }\n            for (var _i2 = 0; _i2 < this._processingNodes.length; _i2++) {\n                this._processingNodes[_i2]._seek(currentTime);\n            }\n            this._currentTime = currentTime;\n        }\n\n        /**\n         * Get how far through the internal timeline has been played.\n         *\n         * Getting this value will give the current playhead position. Can be used for updating timelines.\n         * @return {number} The time in seconds through the current playlist.\n         *\n         * @example\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         * var videoNode = ctx.video(\"video.mp4\");\n         * videoNode.connect(ctx.destination);\n         * videoNode.start(0);\n         * videoNode.stop(10);\n         * ctx.play();\n         * setTimeout(() => console.log(ctx.currentTime),1000); //should print roughly 1.0\n         *\n         */\n        ,\n        get: function get() {\n            return this._currentTime;\n        }\n\n        /**\n         * Get the time at which the last node in the current internal timeline finishes playing.\n         *\n         * @return {number} The end time in seconds of the last video node to finish playing.\n         *\n         * @example\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         * console.log(ctx.duration); //prints 0\n         *\n         * var videoNode = ctx.video(\"video.mp4\");\n         * videoNode.connect(ctx.destination);\n         * videoNode.start(0);\n         * videoNode.stop(10);\n         *\n         * console.log(ctx.duration); //prints 10\n         *\n         * ctx.play();\n         */\n\n    }, {\n        key: \"duration\",\n        get: function get() {\n            var maxTime = 0;\n            for (var i = 0; i < this._sourceNodes.length; i++) {\n                if (this._sourceNodes[i].state !== _sourcenode.SOURCENODESTATE.waiting && this._sourceNodes[i]._stopTime > maxTime) {\n                    maxTime = this._sourceNodes[i]._stopTime;\n                }\n            }\n            return maxTime;\n        }\n\n        /**\n         * Get the final node in the render graph which represents the canvas to display content on to.\n         *\n         * This proprety is read-only and there can only ever be one destination node. Other nodes can connect to this but you cannot connect this node to anything.\n         *\n         * @return {DestinationNode} A graph node representing the canvas to display the content on.\n         * @example\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         * var videoNode = ctx.video(\"video.mp4\");\n         * videoNode.start(0);\n         * videoNode.stop(10);\n         * videoNode.connect(ctx.destination);\n         *\n         */\n\n    }, {\n        key: \"destination\",\n        get: function get() {\n            return this._destinationNode;\n        }\n\n        /**\n         * Set the playback rate of the VideoContext instance.\n         * This will alter the playback speed of all media elements played through the VideoContext.\n         *\n         * @param {number} rate - this is the playback rate.\n         *\n         * @example\n         * var canvasElement = document.getElementById(\"canvas\");\n         * var ctx = new VideoContext(canvasElement);\n         * var videoNode = ctx.video(\"video.mp4\");\n         * videoNode.start(0);\n         * videoNode.stop(10);\n         * videoNode.connect(ctx.destination);\n         * ctx.playbackRate = 2;\n         * ctx.play(); // Double playback rate means this will finish playing in 5 seconds.\n         */\n\n    }, {\n        key: \"playbackRate\",\n        set: function set(rate) {\n            if (rate <= 0) {\n                throw new RangeError(\"playbackRate must be greater than 0\");\n            }\n            var _iteratorNormalCompletion13 = true;\n            var _didIteratorError13 = false;\n            var _iteratorError13 = undefined;\n\n            try {\n                for (var _iterator13 = this._sourceNodes[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n                    var node = _step13.value;\n\n                    if (node.constructor.name === _videonode.VIDEOTYPE) {\n                        node._globalPlaybackRate = rate;\n                        node._playbackRateUpdated = true;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError13 = true;\n                _iteratorError13 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion13 && _iterator13.return) {\n                        _iterator13.return();\n                    }\n                } finally {\n                    if (_didIteratorError13) {\n                        throw _iteratorError13;\n                    }\n                }\n            }\n\n            this._playbackRate = rate;\n        }\n\n        /**\n         *  Return the current playbackRate of the video context.\n         * @return {number} A value representing the playbackRate. 1.0 by default.\n         */\n        ,\n        get: function get() {\n            return this._playbackRate;\n        }\n\n        /**\n         * Set the volume of all MediaNode created in the VideoContext.\n         * @param {number} volume - the volume to apply to the video nodes.\n         */\n\n    }, {\n        key: \"volume\",\n        set: function set(vol) {\n            var _iteratorNormalCompletion14 = true;\n            var _didIteratorError14 = false;\n            var _iteratorError14 = undefined;\n\n            try {\n                for (var _iterator14 = this._sourceNodes[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n                    var node = _step14.value;\n\n                    if (node instanceof _videonode2.default || node instanceof _audionode2.default) {\n                        node.volume = vol;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError14 = true;\n                _iteratorError14 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion14 && _iterator14.return) {\n                        _iterator14.return();\n                    }\n                } finally {\n                    if (_didIteratorError14) {\n                        throw _iteratorError14;\n                    }\n                }\n            }\n\n            this._volume = vol;\n        }\n\n        /**\n         * Return the current volume of the video context.\n         * @return {number} A value representing the volume. 1.0 by default.\n         */\n        ,\n        get: function get() {\n            return this._volume;\n        }\n    }], [{\n        key: \"DEFINITIONS\",\n        get: function get() {\n            return _definitions2.default;\n        }\n    }, {\n        key: \"NODES\",\n        get: function get() {\n            return _nodes2.default;\n        }\n    }]);\n\n    return VideoContext;\n}();\n\n/**\n * Video Context States\n * @readonly\n * @typedef {Object} STATE\n * @property {number} STATE.PLAYING - All sources are active\n * @property {number} STATE.PAUSED - All sources are paused\n * @property {number} STATE.STALLED - One or more sources is unable to play\n * @property {number} STATE.ENDED - All sources have finished playing\n * @property {number} STATE.BROKEN - The render graph is in a broken state\n */\n\n\nexports.default = VideoContext;\nvar STATE = Object.freeze({\n    PLAYING: 0,\n    PAUSED: 1,\n    STALLED: 2,\n    ENDED: 3,\n    BROKEN: 4\n});\nVideoContext.STATE = STATE;\n\n/**\n * Video Context Events\n * @readonly\n * @typedef {Object} STATE\n * @property {string} STATE.UPDATE - Called any time a frame is rendered to the screen.\n * @property {string} STATE.STALLED - happens anytime the playback is stopped due to buffer starvation for playing assets.\n * @property {string} STATE.ENDED - Called once plackback has finished (i.e ctx.currentTime == ctx.duration).\n * @property {string} STATE.CONTENT - Called at the start of a time region where there is content playing out of one or more sourceNodes.\n * @property {number} STATE.NOCONTENT - Called at the start of any time region where the VideoContext is still playing, but there are currently no active playing sources.\n */\nvar EVENTS = Object.freeze({\n    UPDATE: \"update\",\n    STALLED: \"stalled\",\n    ENDED: \"ended\",\n    CONTENT: \"content\",\n    NOCONTENT: \"nocontent\"\n});\nVideoContext.EVENTS = EVENTS;\n\nVideoContext.visualiseVideoContextTimeline = _utils.visualiseVideoContextTimeline;\nVideoContext.visualiseVideoContextGraph = _utils.visualiseVideoContextGraph;\nVideoContext.createControlFormForNode = _utils.createControlFormForNode;\nVideoContext.createSigmaGraphDataFromRenderGraph = _utils.createSigmaGraphDataFromRenderGraph;\nVideoContext.exportToJSON = _utils.exportToJSON;\nVideoContext.updateablesManager = updateablesManager;\nVideoContext.importSimpleEDL = _utils.importSimpleEDL;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/videoelementcache.js\":\n/*!**********************************!*\\\n  !*** ./src/videoelementcache.js ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_299683__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _videoelementcacheitem = __nested_webpack_require_299683__(/*! ./videoelementcacheitem */ \"./src/videoelementcacheitem.js\");\n\nvar _videoelementcacheitem2 = _interopRequireDefault(_videoelementcacheitem);\n\nvar _utils = __nested_webpack_require_299683__(/*! ./utils */ \"./src/utils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar VideoElementCache = function () {\n    function VideoElementCache() {\n        var cache_size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n\n        _classCallCheck(this, VideoElementCache);\n\n        this._cacheItems = [];\n        this._cacheItemsInitialised = false;\n        for (var i = 0; i < cache_size; i++) {\n            // Create a video element and cache\n            this._cacheItems.push(new _videoelementcacheitem2.default());\n        }\n    }\n\n    _createClass(VideoElementCache, [{\n        key: \"init\",\n        value: function init() {\n            if (!this._cacheItemsInitialised) {\n                var _loop = function _loop(cacheItem) {\n                    try {\n                        cacheItem.element.play().then(function () {\n                            // Pause any elements not in the \"playing\" state\n                            if (!cacheItem.isPlaying()) {\n                                cacheItem.element.pause();\n                            }\n                        }, function (e) {\n                            if (e.name !== \"NotSupportedError\") throw e;\n                        });\n                    } catch (e) {\n                        //console.log(e.name);\n                    }\n                };\n\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = this._cacheItems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var cacheItem = _step.value;\n\n                        _loop(cacheItem);\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            }\n            this._cacheItemsInitialised = true;\n        }\n\n        /**\n         * Find and return an empty initialised element or, if the cache is\n         * empty, create a new one.\n         *\n         * @param {Object} mediaNode A `MediaNode` instance\n         */\n\n    }, {\n        key: \"getElementAndLinkToNode\",\n        value: function getElementAndLinkToNode(mediaNode) {\n            // Try and get an already intialised element.\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this._cacheItems[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var _cacheItem = _step2.value;\n\n                    // For some reason an uninitialised videoElement has its sr attribute set to the windows href. Hence the below check.\n                    if (!(0, _utils.mediaElementHasSource)(_cacheItem.element)) {\n                        // attach node to the element\n                        _cacheItem.linkNode(mediaNode);\n                        return _cacheItem.element;\n                    }\n                }\n                // Fallback to creating a new element if none exist or are available\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            console.debug(\"No available video element in the cache, creating a new one. This may break mobile, make your initial cache larger.\");\n            var cacheItem = new _videoelementcacheitem2.default(mediaNode);\n            this._cacheItems.push(cacheItem);\n            this._cacheItemsInitialised = false;\n            return cacheItem.element;\n        }\n\n        /**\n         * Unlink any media node currently linked to a cached video element.\n         *\n         * @param {VideoElement} element The element to unlink from any media nodes\n         */\n\n    }, {\n        key: \"unlinkNodeFromElement\",\n        value: function unlinkNodeFromElement(element) {\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this._cacheItems[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var cacheItem = _step3.value;\n\n                    // Unlink the node from the element\n                    if (element === cacheItem._element) {\n                        cacheItem.unlinkNode();\n                    }\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"length\",\n        get: function get() {\n            return this._cacheItems.length;\n        }\n    }, {\n        key: \"unused\",\n        get: function get() {\n            var count = 0;\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n                for (var _iterator4 = this._cacheItems[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var cacheItem = _step4.value;\n\n                    // For some reason an uninitialised videoElement has its sr attribute set to the windows href. Hence the below check.\n                    if (!(0, _utils.mediaElementHasSource)(cacheItem.element)) count += 1;\n                }\n            } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                    }\n                } finally {\n                    if (_didIteratorError4) {\n                        throw _iteratorError4;\n                    }\n                }\n            }\n\n            return count;\n        }\n    }]);\n\n    return VideoElementCache;\n}();\n\nexports.default = VideoElementCache;\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/videoelementcacheitem.js\":\n/*!**************************************!*\\\n  !*** ./src/videoelementcacheitem.js ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_308436__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _sourcenode = __nested_webpack_require_308436__(/*! ./SourceNodes/sourcenode */ \"./src/SourceNodes/sourcenode.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A video element item created and managed by the `VideoElementCache`.\n *\n * This creates and stores a `<video />` element, which is assigned\n * to a `MediaNode` by the `VideoElementCache` for playback. Once\n * playback has completed the `MediaNode` association will be removed\n * and potentially replaced with another.\n */\nvar VideoElementCacheItem = function () {\n    function VideoElementCacheItem() {\n        var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        _classCallCheck(this, VideoElementCacheItem);\n\n        this._element = this._createElement();\n        this._node = node;\n    }\n\n    _createClass(VideoElementCacheItem, [{\n        key: \"_createElement\",\n        value: function _createElement() {\n            var videoElement = document.createElement(\"video\");\n            videoElement.setAttribute(\"crossorigin\", \"anonymous\");\n            videoElement.setAttribute(\"webkit-playsinline\", \"\");\n            videoElement.setAttribute(\"playsinline\", \"\");\n            return videoElement;\n        }\n    }, {\n        key: \"linkNode\",\n        value: function linkNode(node) {\n            this._node = node;\n        }\n    }, {\n        key: \"unlinkNode\",\n        value: function unlinkNode() {\n            this._node = null;\n        }\n    }, {\n        key: \"isPlaying\",\n        value: function isPlaying() {\n            return this._node && this._node._state === _sourcenode.SOURCENODESTATE.playing;\n        }\n    }, {\n        key: \"element\",\n        get: function get() {\n            return this._element;\n        },\n        set: function set(element) {\n            this._element = element;\n        }\n    }]);\n\n    return VideoElementCacheItem;\n}();\n\nexports.default = VideoElementCacheItem;\nmodule.exports = exports.default;\n\n/***/ })\n\n/******/ });\n});\n//# sourceMappingURL=videocontext.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmlkZW9jb250ZXh0L2Rpc3QvdmlkZW9jb250ZXh0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLNkI7QUFDbkMsQ0FBQztBQUNELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsOEJBQW1CO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixlQUFlLDhCQUFtQjtBQUNsQyxtREFBbUQsK0JBQStCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxpRUFBaUUsaUJBQWlCO0FBQ2xGO0FBQ0EsMERBQTBELGFBQWE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixnQ0FBZ0MsOEJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQW1CO0FBQzlCLGtEQUFrRCxnQ0FBZ0M7QUFDbEYsMEVBQTBFLDhCQUFtQiw0QkFBNEIsb0JBQW9CO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFLDBDQUEwQztBQUMxQyxXQUFXLDhCQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUFtQixDQUFDLDhCQUFtQjtB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QTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRDQUE0QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsNENBQTRDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztB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QUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FB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QUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0NBQWdDO0FBQzlEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUVBO0FBQ0EsbUZBQW1GLG1FQUFtRTtBQUN0Sjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpQ0FBaUMsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFampCLGtCQUFrQixpQ0FBbUI7O0FBRXJDLGtEQUFrRCwwQ0FBMEM7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQSxPQUFPOztBQUVQLFVBQVU7QUFDVixDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haXItc3RhcnQvLi9ub2RlX21vZHVsZXMvdmlkZW9jb250ZXh0L2Rpc3QvdmlkZW9jb250ZXh0LmpzPzExODIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiVmlkZW9Db250ZXh0XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlZpZGVvQ29udGV4dFwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL3ZpZGVvY29udGV4dC5qc1wiKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fY3JvcC9hYWZfdmlkZW9fY3JvcC5mcmFnXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX2Nyb3AvYWFmX3ZpZGVvX2Nyb3AuZnJhZyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gZmxvYXQgY3JvcExlZnQ7XFxudW5pZm9ybSBmbG9hdCBjcm9wUmlnaHQ7XFxudW5pZm9ybSBmbG9hdCBjcm9wVG9wO1xcbnVuaWZvcm0gZmxvYXQgY3JvcEJvdHRvbTtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG52b2lkIG1haW4oKXtcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG4gICAgaWYgKHZfdGV4Q29vcmRbMF0gPCAoY3JvcExlZnQrMS4wKS8yLjApIGNvbG9yID0gdmVjNCgwLjAsMC4wLDAuMCwwLjApO1xcbiAgICBpZiAodl90ZXhDb29yZFswXSA+IChjcm9wUmlnaHQrMS4wKS8yLjApIGNvbG9yID0gdmVjNCgwLjAsMC4wLDAuMCwwLjApO1xcbiAgICBpZiAodl90ZXhDb29yZFsxXSA8ICgtY3JvcEJvdHRvbSsxLjApLzIuMCkgY29sb3IgPSB2ZWM0KDAuMCwwLjAsMC4wLDAuMCk7XFxuICAgIGlmICh2X3RleENvb3JkWzFdID4gKC1jcm9wVG9wKzEuMCkvMi4wKSBjb2xvciA9IHZlYzQoMC4wLDAuMCwwLjAsMC4wKTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcblwiXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL2FhZl92aWRlb19jcm9wL2FhZl92aWRlb19jcm9wLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL2FhZl92aWRlb19jcm9wL2FhZl92aWRlb19jcm9wLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9hYWZfdmlkZW9fY3JvcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWFmX3ZpZGVvX2Nyb3AudmVydCAqLyBcIi4vc3JjL0RlZmluaXRpb25zL2FhZl92aWRlb19jcm9wL2FhZl92aWRlb19jcm9wLnZlcnRcIik7XG5cbnZhciBfYWFmX3ZpZGVvX2Nyb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWFmX3ZpZGVvX2Nyb3ApO1xuXG52YXIgX2FhZl92aWRlb19jcm9wMyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWFmX3ZpZGVvX2Nyb3AuZnJhZyAqLyBcIi4vc3JjL0RlZmluaXRpb25zL2FhZl92aWRlb19jcm9wL2FhZl92aWRlb19jcm9wLmZyYWdcIik7XG5cbnZhciBfYWFmX3ZpZGVvX2Nyb3A0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWFmX3ZpZGVvX2Nyb3AzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGFhZl92aWRlb19jcm9wID0ge1xuICAgIHRpdGxlOiBcIkFBRiBWaWRlbyBDcm9wIEVmZmVjdFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkEgY3JvcCBlZmZlY3QgYmFzZWQgb24gdGhlIEFBRiBzcGVjLlwiLFxuICAgIHZlcnRleFNoYWRlcjogX2FhZl92aWRlb19jcm9wMi5kZWZhdWx0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBfYWFmX3ZpZGVvX2Nyb3A0LmRlZmF1bHQsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBjcm9wTGVmdDogeyB0eXBlOiBcInVuaWZvcm1cIiwgdmFsdWU6IC0xLjAgfSxcbiAgICAgICAgY3JvcFJpZ2h0OiB7IHR5cGU6IFwidW5pZm9ybVwiLCB2YWx1ZTogMS4wIH0sXG4gICAgICAgIGNyb3BUb3A6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiAtMS4wIH0sXG4gICAgICAgIGNyb3BCb3R0b206IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiAxLjAgfVxuICAgIH0sXG4gICAgaW5wdXRzOiBbXCJ1X2ltYWdlXCJdXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhYWZfdmlkZW9fY3JvcDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fY3JvcC9hYWZfdmlkZW9fY3JvcC52ZXJ0XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX2Nyb3AvYWFmX3ZpZGVvX2Nyb3AudmVydCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVjMigyLjAsMi4wKSphX3Bvc2l0aW9uLXZlYzIoMS4wLCAxLjApLCAwLjAsIDEuMCk7XFxuICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fZmxpcC9hYWZfdmlkZW9fZmxpcC5mcmFnXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX2ZsaXAvYWFmX3ZpZGVvX2ZsaXAuZnJhZyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZvaWQgbWFpbigpe1xcbiAgICB2ZWMyIGNvb3JkID0gdmVjMih2X3RleENvb3JkWzBdICwxLjAgLSB2X3RleENvb3JkWzFdKTtcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCBjb29yZCk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fZmxpcC9hYWZfdmlkZW9fZmxpcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fZmxpcC9hYWZfdmlkZW9fZmxpcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfYWFmX3ZpZGVvX2ZsaXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FhZl92aWRlb19mbGlwLnZlcnQgKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fZmxpcC9hYWZfdmlkZW9fZmxpcC52ZXJ0XCIpO1xuXG52YXIgX2FhZl92aWRlb19mbGlwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FhZl92aWRlb19mbGlwKTtcblxudmFyIF9hYWZfdmlkZW9fZmxpcDMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FhZl92aWRlb19mbGlwLmZyYWcgKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fZmxpcC9hYWZfdmlkZW9fZmxpcC5mcmFnXCIpO1xuXG52YXIgX2FhZl92aWRlb19mbGlwNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FhZl92aWRlb19mbGlwMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBhYWZfdmlkZW9fZmxpcCA9IHtcbiAgICB0aXRsZTogXCJBQUYgVmlkZW8gRmxpcCBFZmZlY3RcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBIGZsaXAgZWZmZWN0IGJhc2VkIG9uIHRoZSBBQUYgc3BlYy4gTWlycm9ycyB0aGUgaW1hZ2UgaW4gdGhlIHgtYXhpc1wiLFxuICAgIHZlcnRleFNoYWRlcjogX2FhZl92aWRlb19mbGlwMi5kZWZhdWx0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBfYWFmX3ZpZGVvX2ZsaXA0LmRlZmF1bHQsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgaW5wdXRzOiBbXCJ1X2ltYWdlXCJdXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhYWZfdmlkZW9fZmxpcDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fZmxpcC9hYWZfdmlkZW9fZmxpcC52ZXJ0XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX2ZsaXAvYWFmX3ZpZGVvX2ZsaXAudmVydCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVjMigyLjAsMi4wKSphX3Bvc2l0aW9uLXZlYzIoMS4wLCAxLjApLCAwLjAsIDEuMCk7XFxuICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fZmxvcC9hYWZfdmlkZW9fZmxvcC5mcmFnXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX2Zsb3AvYWFmX3ZpZGVvX2Zsb3AuZnJhZyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZvaWQgbWFpbigpe1xcbiAgICB2ZWMyIGNvb3JkID0gdmVjMigxLjAgLSB2X3RleENvb3JkWzBdICx2X3RleENvb3JkWzFdKTtcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCBjb29yZCk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fZmxvcC9hYWZfdmlkZW9fZmxvcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fZmxvcC9hYWZfdmlkZW9fZmxvcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfYWFmX3ZpZGVvX2Zsb3AgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FhZl92aWRlb19mbG9wLnZlcnQgKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fZmxvcC9hYWZfdmlkZW9fZmxvcC52ZXJ0XCIpO1xuXG52YXIgX2FhZl92aWRlb19mbG9wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FhZl92aWRlb19mbG9wKTtcblxudmFyIF9hYWZfdmlkZW9fZmxvcDMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FhZl92aWRlb19mbG9wLmZyYWcgKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fZmxvcC9hYWZfdmlkZW9fZmxvcC5mcmFnXCIpO1xuXG52YXIgX2FhZl92aWRlb19mbG9wNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FhZl92aWRlb19mbG9wMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBhYWZfdmlkZW9fZmxvcCA9IHtcbiAgICB0aXRsZTogXCJBQUYgVmlkZW8gRmxvcCBFZmZlY3RcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBIGZsb3AgZWZmZWN0IGJhc2VkIG9uIHRoZSBBQUYgc3BlYy4gTWlycm9ycyB0aGUgaW1hZ2UgaW4gdGhlIHktYXhpc1wiLFxuICAgIHZlcnRleFNoYWRlcjogX2FhZl92aWRlb19mbG9wMi5kZWZhdWx0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBfYWFmX3ZpZGVvX2Zsb3A0LmRlZmF1bHQsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgaW5wdXRzOiBbXCJ1X2ltYWdlXCJdXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhYWZfdmlkZW9fZmxvcDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fZmxvcC9hYWZfdmlkZW9fZmxvcC52ZXJ0XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX2Zsb3AvYWFmX3ZpZGVvX2Zsb3AudmVydCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVjMigyLjAsMi4wKSphX3Bvc2l0aW9uLXZlYzIoMS4wLCAxLjApLCAwLjAsIDEuMCk7XFxuICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fcG9zaXRpb24vYWFmX3ZpZGVvX3Bvc2l0aW9uLmZyYWdcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL2FhZl92aWRlb19wb3NpdGlvbi9hYWZfdmlkZW9fcG9zaXRpb24uZnJhZyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudW5pZm9ybSBmbG9hdCBwb3NpdGlvbk9mZnNldFg7XFxudW5pZm9ybSBmbG9hdCBwb3NpdGlvbk9mZnNldFk7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudmFyeWluZyBmbG9hdCB2X3Byb2dyZXNzO1xcbnZvaWQgbWFpbigpe1xcbiAgICB2ZWMyIHBvcyA9IHZlYzIodl90ZXhDb29yZFswXSAtIHBvc2l0aW9uT2Zmc2V0WC8yLjAsIHZfdGV4Q29vcmRbMV0gLSAgcG9zaXRpb25PZmZzZXRZLzIuMCk7XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgcG9zKTtcXG4gICAgaWYgKHBvc1swXSA8IDAuMCB8fCBwb3NbMF0gPiAxLjAgfHwgcG9zWzFdIDwgMC4wIHx8IHBvc1sxXSA+IDEuMCl7XFxuICAgICAgICBjb2xvciA9IHZlYzQoMC4wLDAuMCwwLjAsMC4wKTtcXG4gICAgfVxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX3Bvc2l0aW9uL2FhZl92aWRlb19wb3NpdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL2FhZl92aWRlb19wb3NpdGlvbi9hYWZfdmlkZW9fcG9zaXRpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfYWFmX3ZpZGVvX3Bvc2l0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hYWZfdmlkZW9fcG9zaXRpb24udmVydCAqLyBcIi4vc3JjL0RlZmluaXRpb25zL2FhZl92aWRlb19wb3NpdGlvbi9hYWZfdmlkZW9fcG9zaXRpb24udmVydFwiKTtcblxudmFyIF9hYWZfdmlkZW9fcG9zaXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWFmX3ZpZGVvX3Bvc2l0aW9uKTtcblxudmFyIF9hYWZfdmlkZW9fcG9zaXRpb24zID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hYWZfdmlkZW9fcG9zaXRpb24uZnJhZyAqLyBcIi4vc3JjL0RlZmluaXRpb25zL2FhZl92aWRlb19wb3NpdGlvbi9hYWZfdmlkZW9fcG9zaXRpb24uZnJhZ1wiKTtcblxudmFyIF9hYWZfdmlkZW9fcG9zaXRpb240ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWFmX3ZpZGVvX3Bvc2l0aW9uMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBhYWZfdmlkZW9fcG9zaXRpb24gPSB7XG4gICAgdGl0bGU6IFwiQUFGIFZpZGVvIFBvc2l0aW9uIEVmZmVjdFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkEgcG9zaXRpb24gZWZmZWN0IGJhc2VkIG9uIHRoZSBBQUYgc3BlYy5cIixcbiAgICB2ZXJ0ZXhTaGFkZXI6IF9hYWZfdmlkZW9fcG9zaXRpb24yLmRlZmF1bHQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IF9hYWZfdmlkZW9fcG9zaXRpb240LmRlZmF1bHQsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBwb3NpdGlvbk9mZnNldFg6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiAwLjAgfSxcbiAgICAgICAgcG9zaXRpb25PZmZzZXRZOiB7IHR5cGU6IFwidW5pZm9ybVwiLCB2YWx1ZTogMC4wIH1cbiAgICB9LFxuICAgIGlucHV0czogW1widV9pbWFnZVwiXVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gYWFmX3ZpZGVvX3Bvc2l0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL2FhZl92aWRlb19wb3NpdGlvbi9hYWZfdmlkZW9fcG9zaXRpb24udmVydFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX3Bvc2l0aW9uL2FhZl92aWRlb19wb3NpdGlvbi52ZXJ0ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHZlYzIoMi4wLDIuMCkqYV9wb3NpdGlvbi12ZWMyKDEuMCwgMS4wKSwgMC4wLCAxLjApO1xcbiAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX3NjYWxlL2FhZl92aWRlb19zY2FsZS5mcmFnXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fc2NhbGUvYWFmX3ZpZGVvX3NjYWxlLmZyYWcgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gZmxvYXQgc2NhbGVYO1xcbnVuaWZvcm0gZmxvYXQgc2NhbGVZO1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZhcnlpbmcgZmxvYXQgdl9wcm9ncmVzcztcXG52b2lkIG1haW4oKXtcXG4gICAgdmVjMiBwb3MgPSB2ZWMyKHZfdGV4Q29vcmRbMF0qMS4wL3NjYWxlWCAtICgxLjAvc2NhbGVYLzIuMCAtMC41KSwgdl90ZXhDb29yZFsxXSoxLjAvc2NhbGVZIC0gKDEuMC9zY2FsZVkvMi4wIC0wLjUpKTtcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCBwb3MpO1xcbiAgICBpZiAocG9zWzBdIDwgMC4wIHx8IHBvc1swXSA+IDEuMCB8fCBwb3NbMV0gPCAwLjAgfHwgcG9zWzFdID4gMS4wKXtcXG4gICAgICAgIGNvbG9yID0gdmVjNCgwLjAsMC4wLDAuMCwwLjApO1xcbiAgICB9XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fc2NhbGUvYWFmX3ZpZGVvX3NjYWxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX3NjYWxlL2FhZl92aWRlb19zY2FsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9hYWZfdmlkZW9fc2NhbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FhZl92aWRlb19zY2FsZS52ZXJ0ICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX3NjYWxlL2FhZl92aWRlb19zY2FsZS52ZXJ0XCIpO1xuXG52YXIgX2FhZl92aWRlb19zY2FsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hYWZfdmlkZW9fc2NhbGUpO1xuXG52YXIgX2FhZl92aWRlb19zY2FsZTMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FhZl92aWRlb19zY2FsZS5mcmFnICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX3NjYWxlL2FhZl92aWRlb19zY2FsZS5mcmFnXCIpO1xuXG52YXIgX2FhZl92aWRlb19zY2FsZTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hYWZfdmlkZW9fc2NhbGUzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGFhZl92aWRlb19zY2FsZSA9IHtcbiAgICB0aXRsZTogXCJBQUYgVmlkZW8gU2NhbGUgRWZmZWN0XCIsXG4gICAgZGVzY3JpcHRpb246IFwiQSBzY2FsZSBlZmZlY3QgYmFzZWQgb24gdGhlIEFBRiBzcGVjLlwiLFxuICAgIHZlcnRleFNoYWRlcjogX2FhZl92aWRlb19zY2FsZTIuZGVmYXVsdCxcbiAgICBmcmFnbWVudFNoYWRlcjogX2FhZl92aWRlb19zY2FsZTQuZGVmYXVsdCxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHNjYWxlWDogeyB0eXBlOiBcInVuaWZvcm1cIiwgdmFsdWU6IDEuMCB9LFxuICAgICAgICBzY2FsZVk6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiAxLjAgfVxuICAgIH0sXG4gICAgaW5wdXRzOiBbXCJ1X2ltYWdlXCJdXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhYWZfdmlkZW9fc2NhbGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX3NjYWxlL2FhZl92aWRlb19zY2FsZS52ZXJ0XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fc2NhbGUvYWFmX3ZpZGVvX3NjYWxlLnZlcnQgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVjMigyLjAsMi4wKSphX3Bvc2l0aW9uLXZlYzIoMS4wLCAxLjApLCAwLjAsIDEuMCk7XFxuICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9jb2xvclRocmVzaG9sZC9jb2xvclRocmVzaG9sZC5mcmFnXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvY29sb3JUaHJlc2hvbGQvY29sb3JUaHJlc2hvbGQuZnJhZyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gZmxvYXQgYTtcXG51bmlmb3JtIHZlYzMgY29sb3JBbHBoYVRocmVzaG9sZDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG52YXJ5aW5nIGZsb2F0IHZfbWl4O1xcbnZvaWQgbWFpbigpe1xcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgICBpZiAoY29sb3JbMF0gPiBjb2xvckFscGhhVGhyZXNob2xkWzBdICYmIGNvbG9yWzFdPiBjb2xvckFscGhhVGhyZXNob2xkWzFdICYmIGNvbG9yWzJdPiBjb2xvckFscGhhVGhyZXNob2xkWzJdKXtcXG4gICAgICAgIGNvbG9yID0gdmVjNCgwLjAsMC4wLDAuMCwwLjApO1xcbiAgICB9XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9jb2xvclRocmVzaG9sZC9jb2xvclRocmVzaG9sZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9jb2xvclRocmVzaG9sZC9jb2xvclRocmVzaG9sZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY29sb3JUaHJlc2hvbGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbG9yVGhyZXNob2xkLnZlcnQgKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9jb2xvclRocmVzaG9sZC9jb2xvclRocmVzaG9sZC52ZXJ0XCIpO1xuXG52YXIgX2NvbG9yVGhyZXNob2xkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbG9yVGhyZXNob2xkKTtcblxudmFyIF9jb2xvclRocmVzaG9sZDMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbG9yVGhyZXNob2xkLmZyYWcgKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9jb2xvclRocmVzaG9sZC9jb2xvclRocmVzaG9sZC5mcmFnXCIpO1xuXG52YXIgX2NvbG9yVGhyZXNob2xkNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbG9yVGhyZXNob2xkMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjb2xvclRocmVzaG9sZCA9IHtcbiAgICB0aXRsZTogXCJDb2xvciBUaHJlc2hvbGRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUdXJucyBhbGwgcGl4ZWxzIHdpdGggYSBncmVhdGVyIHZhbHVlIHRoYW4gdGhlIHNwZWNpZmllZCB0aHJlc2hvbGQgdHJhbnNwYXJlbnQuXCIsXG4gICAgdmVydGV4U2hhZGVyOiBfY29sb3JUaHJlc2hvbGQyLmRlZmF1bHQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IF9jb2xvclRocmVzaG9sZDQuZGVmYXVsdCxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGE6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiAwLjAgfSxcbiAgICAgICAgY29sb3JBbHBoYVRocmVzaG9sZDogeyB0eXBlOiBcInVuaWZvcm1cIiwgdmFsdWU6IFswLjAsIDAuNTUsIDAuMF0gfVxuICAgIH0sXG4gICAgaW5wdXRzOiBbXCJ1X2ltYWdlXCJdXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjb2xvclRocmVzaG9sZDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9jb2xvclRocmVzaG9sZC9jb2xvclRocmVzaG9sZC52ZXJ0XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvY29sb3JUaHJlc2hvbGQvY29sb3JUaHJlc2hvbGQudmVydCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVjMigyLjAsMi4wKSphX3Bvc2l0aW9uLXZlYzIoMS4wLCAxLjApLCAwLjAsIDEuMCk7XFxuICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9jb21iaW5lL2NvbWJpbmUuZnJhZ1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9jb21iaW5lL2NvbWJpbmUuZnJhZyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG51bmlmb3JtIGZsb2F0IGE7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudmFyeWluZyBmbG9hdCB2X21peDtcXG52b2lkIG1haW4oKXtcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcblwiXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL2NvbWJpbmUvY29tYmluZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvY29tYmluZS9jb21iaW5lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY29tYmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29tYmluZS52ZXJ0ICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvY29tYmluZS9jb21iaW5lLnZlcnRcIik7XG5cbnZhciBfY29tYmluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21iaW5lKTtcblxudmFyIF9jb21iaW5lMyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29tYmluZS5mcmFnICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvY29tYmluZS9jb21iaW5lLmZyYWdcIik7XG5cbnZhciBfY29tYmluZTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21iaW5lMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjb21iaW5lID0ge1xuICAgIHRpdGxlOiBcIkNvbWJpbmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBIGJhc2ljIGVmZmVjdCB3aGljaCByZW5kZXJzIHRoZSBpbnB1dCB0byB0aGUgb3V0cHV0LCBUeXBpY2FsbHkgdXNlZCBhcyBhIGNvbWJpbmUgbm9kZSBmb3IgbGF5ZXJpbmcgdXAgbWVkaWEgd2l0aCBhbHBoYSB0cmFuc3BhcmVuY3kuXCIsXG4gICAgdmVydGV4U2hhZGVyOiBfY29tYmluZTIuZGVmYXVsdCxcbiAgICBmcmFnbWVudFNoYWRlcjogX2NvbWJpbmU0LmRlZmF1bHQsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBhOiB7IHR5cGU6IFwidW5pZm9ybVwiLCB2YWx1ZTogMC4wIH1cbiAgICB9LFxuICAgIGlucHV0czogW1widV9pbWFnZVwiXVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY29tYmluZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9jb21iaW5lL2NvbWJpbmUudmVydFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9jb21iaW5lL2NvbWJpbmUudmVydCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHZlYzIoMi4wLDIuMCkqYV9wb3NpdGlvbi12ZWMyKDEuMCwgMS4wKSwgMC4wLCAxLjApO1xcbiAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvY3JvcC9jcm9wLmZyYWdcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvY3JvcC9jcm9wLmZyYWcgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudW5pZm9ybSBmbG9hdCB4O1xcbnVuaWZvcm0gZmxvYXQgeTtcXG51bmlmb3JtIGZsb2F0IHdpZHRoO1xcbnVuaWZvcm0gZmxvYXQgaGVpZ2h0O1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZhcnlpbmcgZmxvYXQgdl9wcm9ncmVzcztcXG52b2lkIG1haW4oKXtcXG4gICAgdmVjMiBwb3MgPSAoKCh2X3RleENvb3JkKSp2ZWMyKHdpZHRoLCBoZWlnaHQpKSArIHZlYzIoMCwgMS4wLWhlaWdodCkpICt2ZWMyKHgsLXkpO1xcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHBvcyk7XFxuICAgIGlmIChwb3NbMF0gPCAwLjAgfHwgcG9zWzBdID4gMS4wIHx8IHBvc1sxXSA8IDAuMCB8fCBwb3NbMV0gPiAxLjApe1xcbiAgICAgICAgY29sb3IgPSB2ZWM0KDAuMCwwLjAsMC4wLDAuMCk7XFxuICAgIH1cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcblwiXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL2Nyb3AvY3JvcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvY3JvcC9jcm9wLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JvcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY3JvcC52ZXJ0ICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvY3JvcC9jcm9wLnZlcnRcIik7XG5cbnZhciBfY3JvcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcm9wKTtcblxudmFyIF9jcm9wMyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY3JvcC5mcmFnICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvY3JvcC9jcm9wLmZyYWdcIik7XG5cbnZhciBfY3JvcDQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcm9wMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjcm9wID0ge1xuICAgIHRpdGxlOiBcIlByaW1lciBTaW1wbGUgQ3JvcFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkEgc2ltcGxlIGNyb3AgcHJvY2Vzc29ycyBmb3IgcHJpbWVyXCIsXG4gICAgdmVydGV4U2hhZGVyOiBfY3JvcDIuZGVmYXVsdCxcbiAgICBmcmFnbWVudFNoYWRlcjogX2Nyb3A0LmRlZmF1bHQsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICB4OiB7IHR5cGU6IFwidW5pZm9ybVwiLCB2YWx1ZTogMC4wIH0sXG4gICAgICAgIHk6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiAwLjAgfSxcbiAgICAgICAgd2lkdGg6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiAxLjAgfSxcbiAgICAgICAgaGVpZ2h0OiB7IHR5cGU6IFwidW5pZm9ybVwiLCB2YWx1ZTogMS4wIH1cbiAgICB9LFxuICAgIGlucHV0czogW1widV9pbWFnZVwiXVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JvcDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9jcm9wL2Nyb3AudmVydFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9jcm9wL2Nyb3AudmVydCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHZlYzIoMi4wLDIuMCkqYV9wb3NpdGlvbi12ZWMyKDEuMCwgMS4wKSwgMC4wLCAxLjApO1xcbiAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvY3Jvc3NmYWRlL2Nyb3NzZmFkZS5mcmFnXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9jcm9zc2ZhZGUvY3Jvc3NmYWRlLmZyYWcgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlX2E7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZV9iO1xcbnVuaWZvcm0gZmxvYXQgbWl4O1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZhcnlpbmcgZmxvYXQgdl9taXg7XFxudm9pZCBtYWluKCl7XFxuICAgIHZlYzQgY29sb3JfYSA9IHRleHR1cmUyRCh1X2ltYWdlX2EsIHZfdGV4Q29vcmQpO1xcbiAgICB2ZWM0IGNvbG9yX2IgPSB0ZXh0dXJlMkQodV9pbWFnZV9iLCB2X3RleENvb3JkKTtcXG4gICAgY29sb3JfYVswXSAqPSAoMS4wIC0gbWl4KTtcXG4gICAgY29sb3JfYVsxXSAqPSAoMS4wIC0gbWl4KTtcXG4gICAgY29sb3JfYVsyXSAqPSAoMS4wIC0gbWl4KTtcXG4gICAgY29sb3JfYVszXSAqPSAoMS4wIC0gbWl4KTtcXG4gICAgY29sb3JfYlswXSAqPSBtaXg7XFxuICAgIGNvbG9yX2JbMV0gKj0gbWl4O1xcbiAgICBjb2xvcl9iWzJdICo9IG1peDtcXG4gICAgY29sb3JfYlszXSAqPSBtaXg7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yX2EgKyBjb2xvcl9iO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9jcm9zc2ZhZGUvY3Jvc3NmYWRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvY3Jvc3NmYWRlL2Nyb3NzZmFkZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcm9zc2ZhZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Nyb3NzZmFkZS52ZXJ0ICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvY3Jvc3NmYWRlL2Nyb3NzZmFkZS52ZXJ0XCIpO1xuXG52YXIgX2Nyb3NzZmFkZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcm9zc2ZhZGUpO1xuXG52YXIgX2Nyb3NzZmFkZTMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Nyb3NzZmFkZS5mcmFnICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvY3Jvc3NmYWRlL2Nyb3NzZmFkZS5mcmFnXCIpO1xuXG52YXIgX2Nyb3NzZmFkZTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcm9zc2ZhZGUzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNyb3NzZmFkZSA9IHtcbiAgICB0aXRsZTogXCJDcm9zcy1GYWRlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQSBjcm9zcy1mYWRlIGVmZmVjdC4gVHlwaWNhbGx5IHVzZWQgYXMgYSB0cmFuc2lzdGlvbi5cIixcbiAgICB2ZXJ0ZXhTaGFkZXI6IF9jcm9zc2ZhZGUyLmRlZmF1bHQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IF9jcm9zc2ZhZGU0LmRlZmF1bHQsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBtaXg6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiAwLjAgfVxuICAgIH0sXG4gICAgaW5wdXRzOiBbXCJ1X2ltYWdlX2FcIiwgXCJ1X2ltYWdlX2JcIl1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyb3NzZmFkZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9jcm9zc2ZhZGUvY3Jvc3NmYWRlLnZlcnRcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL2Nyb3NzZmFkZS9jcm9zc2ZhZGUudmVydCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh2ZWMyKDIuMCwyLjApKmFfcG9zaXRpb24tdmVjMigxLjAsIDEuMCksIDAuMCwgMS4wKTtcXG4gICAgdl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7XFxufVxcblwiXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL2RlZmluaXRpb25zLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL2RlZmluaXRpb25zLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9hYWZfdmlkZW9fc2NhbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FhZl92aWRlb19zY2FsZSAqLyBcIi4vc3JjL0RlZmluaXRpb25zL2FhZl92aWRlb19zY2FsZS9hYWZfdmlkZW9fc2NhbGUuanNcIik7XG5cbnZhciBfYWFmX3ZpZGVvX3NjYWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FhZl92aWRlb19zY2FsZSk7XG5cbnZhciBfY3Jvc3NmYWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jcm9zc2ZhZGUgKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9jcm9zc2ZhZGUvY3Jvc3NmYWRlLmpzXCIpO1xuXG52YXIgX2Nyb3NzZmFkZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcm9zc2ZhZGUpO1xuXG52YXIgX2hvcml6b250YWxXaXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ob3Jpem9udGFsV2lwZSAqLyBcIi4vc3JjL0RlZmluaXRpb25zL2hvcml6b250YWxXaXBlL2hvcml6b250YWxXaXBlLmpzXCIpO1xuXG52YXIgX2hvcml6b250YWxXaXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hvcml6b250YWxXaXBlKTtcblxudmFyIF92ZXJ0aWNhbFdpcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ZlcnRpY2FsV2lwZSAqLyBcIi4vc3JjL0RlZmluaXRpb25zL3ZlcnRpY2FsV2lwZS92ZXJ0aWNhbFdpcGUuanNcIik7XG5cbnZhciBfdmVydGljYWxXaXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZlcnRpY2FsV2lwZSk7XG5cbnZhciBfcmFuZG9tRGlzc29sdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JhbmRvbURpc3NvbHZlICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvcmFuZG9tRGlzc29sdmUvcmFuZG9tRGlzc29sdmUuanNcIik7XG5cbnZhciBfcmFuZG9tRGlzc29sdmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmFuZG9tRGlzc29sdmUpO1xuXG52YXIgX3RvQ29sb3JBbmRCYWNrRmFkZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG9Db2xvckFuZEJhY2tGYWRlICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvdG9Db2xvckFuZEJhY2tGYWRlL3RvQ29sb3JBbmRCYWNrRmFkZS5qc1wiKTtcblxudmFyIF90b0NvbG9yQW5kQmFja0ZhZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9Db2xvckFuZEJhY2tGYWRlKTtcblxudmFyIF9zdGFyV2lwZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3RhcldpcGUgKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9zdGFyV2lwZS9zdGFyV2lwZS5qc1wiKTtcblxudmFyIF9zdGFyV2lwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdGFyV2lwZSk7XG5cbnZhciBfY29tYmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29tYmluZSAqLyBcIi4vc3JjL0RlZmluaXRpb25zL2NvbWJpbmUvY29tYmluZS5qc1wiKTtcblxudmFyIF9jb21iaW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbWJpbmUpO1xuXG52YXIgX2NvbG9yVGhyZXNob2xkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb2xvclRocmVzaG9sZCAqLyBcIi4vc3JjL0RlZmluaXRpb25zL2NvbG9yVGhyZXNob2xkL2NvbG9yVGhyZXNob2xkLmpzXCIpO1xuXG52YXIgX2NvbG9yVGhyZXNob2xkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbG9yVGhyZXNob2xkKTtcblxudmFyIF9tb25vY2hyb21lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb25vY2hyb21lICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvbW9ub2Nocm9tZS9tb25vY2hyb21lLmpzXCIpO1xuXG52YXIgX21vbm9jaHJvbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9ub2Nocm9tZSk7XG5cbnZhciBfaG9yaXpvbnRhbEJsdXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hvcml6b250YWxCbHVyICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvaG9yaXpvbnRhbEJsdXIvaG9yaXpvbnRhbEJsdXIuanNcIik7XG5cbnZhciBfaG9yaXpvbnRhbEJsdXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaG9yaXpvbnRhbEJsdXIpO1xuXG52YXIgX3ZlcnRpY2FsQmx1ciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdmVydGljYWxCbHVyICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvdmVydGljYWxCbHVyL3ZlcnRpY2FsQmx1ci5qc1wiKTtcblxudmFyIF92ZXJ0aWNhbEJsdXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmVydGljYWxCbHVyKTtcblxudmFyIF9hYWZfdmlkZW9fZmxvcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWFmX3ZpZGVvX2Zsb3AgKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fZmxvcC9hYWZfdmlkZW9fZmxvcC5qc1wiKTtcblxudmFyIF9hYWZfdmlkZW9fZmxvcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hYWZfdmlkZW9fZmxvcCk7XG5cbnZhciBfYWFmX3ZpZGVvX2ZsaXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FhZl92aWRlb19mbGlwICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX2ZsaXAvYWFmX3ZpZGVvX2ZsaXAuanNcIik7XG5cbnZhciBfYWFmX3ZpZGVvX2ZsaXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWFmX3ZpZGVvX2ZsaXApO1xuXG52YXIgX2FhZl92aWRlb19wb3NpdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWFmX3ZpZGVvX3Bvc2l0aW9uICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvYWFmX3ZpZGVvX3Bvc2l0aW9uL2FhZl92aWRlb19wb3NpdGlvbi5qc1wiKTtcblxudmFyIF9hYWZfdmlkZW9fcG9zaXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWFmX3ZpZGVvX3Bvc2l0aW9uKTtcblxudmFyIF9hYWZfdmlkZW9fY3JvcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWFmX3ZpZGVvX2Nyb3AgKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9hYWZfdmlkZW9fY3JvcC9hYWZfdmlkZW9fY3JvcC5qc1wiKTtcblxudmFyIF9hYWZfdmlkZW9fY3JvcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hYWZfdmlkZW9fY3JvcCk7XG5cbnZhciBfc3RhdGljRGlzc29sdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0YXRpY0Rpc3NvbHZlICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvc3RhdGljRGlzc29sdmUvc3RhdGljRGlzc29sdmUuanNcIik7XG5cbnZhciBfc3RhdGljRGlzc29sdmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RhdGljRGlzc29sdmUpO1xuXG52YXIgX3N0YXRpY0VmZmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3RhdGljRWZmZWN0ICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvc3RhdGljRWZmZWN0L3N0YXRpY0VmZmVjdC5qc1wiKTtcblxudmFyIF9zdGF0aWNFZmZlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RhdGljRWZmZWN0KTtcblxudmFyIF9kcmVhbWZhZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RyZWFtZmFkZSAqLyBcIi4vc3JjL0RlZmluaXRpb25zL2RyZWFtZmFkZS9kcmVhbWZhZGUuanNcIik7XG5cbnZhciBfZHJlYW1mYWRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RyZWFtZmFkZSk7XG5cbnZhciBfb3BhY2l0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vb3BhY2l0eSAqLyBcIi4vc3JjL0RlZmluaXRpb25zL29wYWNpdHkvb3BhY2l0eS5qc1wiKTtcblxudmFyIF9vcGFjaXR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29wYWNpdHkpO1xuXG52YXIgX2Nyb3AgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Nyb3AgKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9jcm9wL2Nyb3AuanNcIik7XG5cbnZhciBfY3JvcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcm9wKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIERFRklOSVRJT05TID0ge1xuICAgIEFBRl9WSURFT19TQ0FMRTogX2FhZl92aWRlb19zY2FsZTIuZGVmYXVsdCxcbiAgICBDUk9TU0ZBREU6IF9jcm9zc2ZhZGUyLmRlZmF1bHQsXG4gICAgRFJFQU1GQURFOiBfZHJlYW1mYWRlMi5kZWZhdWx0LFxuICAgIEhPUklaT05UQUxfV0lQRTogX2hvcml6b250YWxXaXBlMi5kZWZhdWx0LFxuICAgIFZFUlRJQ0FMX1dJUEU6IF92ZXJ0aWNhbFdpcGUyLmRlZmF1bHQsXG4gICAgUkFORE9NX0RJU1NPTFZFOiBfcmFuZG9tRGlzc29sdmUyLmRlZmF1bHQsXG4gICAgU1RBVElDX0RJU1NPTFZFOiBfc3RhdGljRGlzc29sdmUyLmRlZmF1bHQsXG4gICAgU1RBVElDX0VGRkVDVDogX3N0YXRpY0VmZmVjdDIuZGVmYXVsdCxcbiAgICBUT19DT0xPUl9BTkRfQkFDSzogX3RvQ29sb3JBbmRCYWNrRmFkZTIuZGVmYXVsdCxcbiAgICBTVEFSX1dJUEU6IF9zdGFyV2lwZTIuZGVmYXVsdCxcbiAgICBDT01CSU5FOiBfY29tYmluZTIuZGVmYXVsdCxcbiAgICBDT0xPUlRIUkVTSE9MRDogX2NvbG9yVGhyZXNob2xkMi5kZWZhdWx0LFxuICAgIE1PTk9DSFJPTUU6IF9tb25vY2hyb21lMi5kZWZhdWx0LFxuICAgIEhPUklaT05UQUxfQkxVUjogX2hvcml6b250YWxCbHVyMi5kZWZhdWx0LFxuICAgIFZFUlRJQ0FMX0JMVVI6IF92ZXJ0aWNhbEJsdXIyLmRlZmF1bHQsXG4gICAgQUFGX1ZJREVPX0NST1A6IF9hYWZfdmlkZW9fY3JvcDIuZGVmYXVsdCxcbiAgICBBQUZfVklERU9fUE9TSVRJT046IF9hYWZfdmlkZW9fcG9zaXRpb24yLmRlZmF1bHQsXG4gICAgQUFGX1ZJREVPX0ZMSVA6IF9hYWZfdmlkZW9fZmxpcDIuZGVmYXVsdCxcbiAgICBBQUZfVklERU9fRkxPUDogX2FhZl92aWRlb19mbG9wMi5kZWZhdWx0LFxuICAgIE9QQUNJVFk6IF9vcGFjaXR5Mi5kZWZhdWx0LFxuICAgIENST1A6IF9jcm9wMi5kZWZhdWx0XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBERUZJTklUSU9OUztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9kcmVhbWZhZGUvZHJlYW1mYWRlLmZyYWdcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL2RyZWFtZmFkZS9kcmVhbWZhZGUuZnJhZyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2VfYTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlX2I7XFxudW5pZm9ybSBmbG9hdCBtaXg7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudmFyeWluZyBmbG9hdCB2X21peDtcXG52b2lkIG1haW4oKXtcXG4gICAgZmxvYXQgd29iYmxlID0gMS4wIC0gYWJzKChtaXgqMi4wKS0xLjApO1xcbiAgICB2ZWMyIHBvcyA9IHZlYzIodl90ZXhDb29yZFswXSArICgoc2luKHZfdGV4Q29vcmRbMV0qKDEwLjAqd29iYmxlKjMuMTQpICsgd29iYmxlKjEwLjApLzEzLjApKSwgdl90ZXhDb29yZFsxXSk7XFxuICAgIHZlYzQgY29sb3JfYSA9IHRleHR1cmUyRCh1X2ltYWdlX2EsIHBvcyk7XFxuICAgIHZlYzQgY29sb3JfYiA9IHRleHR1cmUyRCh1X2ltYWdlX2IsIHBvcyk7XFxuICAgIGNvbG9yX2FbMF0gKj0gKDEuMCAtIG1peCk7XFxuICAgIGNvbG9yX2FbMV0gKj0gKDEuMCAtIG1peCk7XFxuICAgIGNvbG9yX2FbMl0gKj0gKDEuMCAtIG1peCk7XFxuICAgIGNvbG9yX2FbM10gKj0gKDEuMCAtIG1peCk7XFxuICAgIGNvbG9yX2JbMF0gKj0gbWl4O1xcbiAgICBjb2xvcl9iWzFdICo9IG1peDtcXG4gICAgY29sb3JfYlsyXSAqPSBtaXg7XFxuICAgIGNvbG9yX2JbM10gKj0gbWl4O1xcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcl9hICsgY29sb3JfYjtcXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvZHJlYW1mYWRlL2RyZWFtZmFkZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL2RyZWFtZmFkZS9kcmVhbWZhZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZHJlYW1mYWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kcmVhbWZhZGUudmVydCAqLyBcIi4vc3JjL0RlZmluaXRpb25zL2RyZWFtZmFkZS9kcmVhbWZhZGUudmVydFwiKTtcblxudmFyIF9kcmVhbWZhZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZHJlYW1mYWRlKTtcblxudmFyIF9kcmVhbWZhZGUzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kcmVhbWZhZGUuZnJhZyAqLyBcIi4vc3JjL0RlZmluaXRpb25zL2RyZWFtZmFkZS9kcmVhbWZhZGUuZnJhZ1wiKTtcblxudmFyIF9kcmVhbWZhZGU0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZHJlYW1mYWRlMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkcmVhbWZhZGUgPSB7XG4gICAgdGl0bGU6IFwiRHJlYW0tRmFkZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkEgd29iYmx5IGRyZWFtIGVmZmVjdC4gVHlwaWNhbGx5IHVzZWQgYXMgYSB0cmFuc2lzdGlvbi5cIixcbiAgICB2ZXJ0ZXhTaGFkZXI6IF9kcmVhbWZhZGUyLmRlZmF1bHQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IF9kcmVhbWZhZGU0LmRlZmF1bHQsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBtaXg6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiAwLjAgfVxuICAgIH0sXG4gICAgaW5wdXRzOiBbXCJ1X2ltYWdlX2FcIiwgXCJ1X2ltYWdlX2JcIl1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGRyZWFtZmFkZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9kcmVhbWZhZGUvZHJlYW1mYWRlLnZlcnRcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL2RyZWFtZmFkZS9kcmVhbWZhZGUudmVydCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh2ZWMyKDIuMCwyLjApKmFfcG9zaXRpb24tdmVjMigxLjAsIDEuMCksIDAuMCwgMS4wKTtcXG4gICAgdl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7XFxufVxcblwiXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL2hvcml6b250YWxCbHVyL2hvcml6b250YWxCbHVyLmZyYWdcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9ob3Jpem9udGFsQmx1ci9ob3Jpem9udGFsQmx1ci5mcmFnICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudmFyeWluZyB2ZWMyIHZfYmx1clRleENvb3Jkc1sxNF07XFxudm9pZCBtYWluKCl7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wKTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDBdKSowLjAwNDQyOTkxMjEwNTUxMTMyNjU7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl9ibHVyVGV4Q29vcmRzWyAxXSkqMC4wMDg5NTc4MTIxMTc5NDtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDJdKSowLjAyMTU5NjM4NjYwNTM7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl9ibHVyVGV4Q29vcmRzWyAzXSkqMC4wNDQzNjgzMzM4NzE4O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfYmx1clRleENvb3Jkc1sgNF0pKjAuMDc3Njc0NDIxOTkzMztcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDVdKSowLjExNTg3NjYyMTEwNTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDZdKSowLjE0NzMwODA1NjEyMTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkICAgICAgICAgKSowLjE1OTU3NjkxMjE2MTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDddKSowLjE0NzMwODA1NjEyMTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDhdKSowLjExNTg3NjYyMTEwNTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDldKSowLjA3NzY3NDQyMTk5MzM7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl9ibHVyVGV4Q29vcmRzWzEwXSkqMC4wNDQzNjgzMzM4NzE4O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfYmx1clRleENvb3Jkc1sxMV0pKjAuMDIxNTk2Mzg2NjA1MztcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbMTJdKSowLjAwODk1NzgxMjExNzk0O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfYmx1clRleENvb3Jkc1sxM10pKjAuMDA0NDI5OTEyMTA1NTExMzI2NTtcXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvaG9yaXpvbnRhbEJsdXIvaG9yaXpvbnRhbEJsdXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvaG9yaXpvbnRhbEJsdXIvaG9yaXpvbnRhbEJsdXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2hvcml6b250YWxCbHVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ob3Jpem9udGFsQmx1ci52ZXJ0ICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvaG9yaXpvbnRhbEJsdXIvaG9yaXpvbnRhbEJsdXIudmVydFwiKTtcblxudmFyIF9ob3Jpem9udGFsQmx1cjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ob3Jpem9udGFsQmx1cik7XG5cbnZhciBfaG9yaXpvbnRhbEJsdXIzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ob3Jpem9udGFsQmx1ci5mcmFnICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvaG9yaXpvbnRhbEJsdXIvaG9yaXpvbnRhbEJsdXIuZnJhZ1wiKTtcblxudmFyIF9ob3Jpem9udGFsQmx1cjQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ob3Jpem9udGFsQmx1cjMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaG9yaXpvbnRhbF9ibHVyID0ge1xuICAgIHRpdGxlOiBcIkhvcml6b250YWwgQmx1clwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkEgaG9yaXpvbnRhbCBibHVyIGVmZmVjdC4gQWRwYXRlZCBmcm9tIGh0dHA6Ly94aXNzYnVyZy5jb20vZmFzdGVyLWdhdXNzaWFuLWJsdXItaW4tZ2xzbC9cIixcbiAgICB2ZXJ0ZXhTaGFkZXI6IF9ob3Jpem9udGFsQmx1cjIuZGVmYXVsdCxcbiAgICBmcmFnbWVudFNoYWRlcjogX2hvcml6b250YWxCbHVyNC5kZWZhdWx0LFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgYmx1ckFtb3VudDogeyB0eXBlOiBcInVuaWZvcm1cIiwgdmFsdWU6IDEuMCB9XG4gICAgfSxcbiAgICBpbnB1dHM6IFtcInVfaW1hZ2VcIl1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGhvcml6b250YWxfYmx1cjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9ob3Jpem9udGFsQmx1ci9ob3Jpem9udGFsQmx1ci52ZXJ0XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvaG9yaXpvbnRhbEJsdXIvaG9yaXpvbnRhbEJsdXIudmVydCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxudW5pZm9ybSBmbG9hdCBibHVyQW1vdW50O1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZhcnlpbmcgdmVjMiB2X2JsdXJUZXhDb29yZHNbMTRdO1xcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHZlYzIoMi4wLDIuMCkqYV9wb3NpdGlvbi12ZWMyKDEuMCwgMS4wKSwgMC4wLCAxLjApO1xcbiAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcXG4gICAgdl9ibHVyVGV4Q29vcmRzWyAwXSA9IHZfdGV4Q29vcmQgKyB2ZWMyKC0wLjAyOCAqIGJsdXJBbW91bnQsIDAuMCk7XFxuICAgIHZfYmx1clRleENvb3Jkc1sgMV0gPSB2X3RleENvb3JkICsgdmVjMigtMC4wMjQgKiBibHVyQW1vdW50LCAwLjApO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbIDJdID0gdl90ZXhDb29yZCArIHZlYzIoLTAuMDIwICogYmx1ckFtb3VudCwgMC4wKTtcXG4gICAgdl9ibHVyVGV4Q29vcmRzWyAzXSA9IHZfdGV4Q29vcmQgKyB2ZWMyKC0wLjAxNiAqIGJsdXJBbW91bnQsIDAuMCk7XFxuICAgIHZfYmx1clRleENvb3Jkc1sgNF0gPSB2X3RleENvb3JkICsgdmVjMigtMC4wMTIgKiBibHVyQW1vdW50LCAwLjApO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbIDVdID0gdl90ZXhDb29yZCArIHZlYzIoLTAuMDA4ICogYmx1ckFtb3VudCwgMC4wKTtcXG4gICAgdl9ibHVyVGV4Q29vcmRzWyA2XSA9IHZfdGV4Q29vcmQgKyB2ZWMyKC0wLjAwNCAqIGJsdXJBbW91bnQsIDAuMCk7XFxuICAgIHZfYmx1clRleENvb3Jkc1sgN10gPSB2X3RleENvb3JkICsgdmVjMiggMC4wMDQgKiBibHVyQW1vdW50LCAwLjApO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbIDhdID0gdl90ZXhDb29yZCArIHZlYzIoIDAuMDA4ICogYmx1ckFtb3VudCwgMC4wKTtcXG4gICAgdl9ibHVyVGV4Q29vcmRzWyA5XSA9IHZfdGV4Q29vcmQgKyB2ZWMyKCAwLjAxMiAqIGJsdXJBbW91bnQsIDAuMCk7XFxuICAgIHZfYmx1clRleENvb3Jkc1sxMF0gPSB2X3RleENvb3JkICsgdmVjMiggMC4wMTYgKiBibHVyQW1vdW50LCAwLjApO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbMTFdID0gdl90ZXhDb29yZCArIHZlYzIoIDAuMDIwICogYmx1ckFtb3VudCwgMC4wKTtcXG4gICAgdl9ibHVyVGV4Q29vcmRzWzEyXSA9IHZfdGV4Q29vcmQgKyB2ZWMyKCAwLjAyNCAqIGJsdXJBbW91bnQsIDAuMCk7XFxuICAgIHZfYmx1clRleENvb3Jkc1sxM10gPSB2X3RleENvb3JkICsgdmVjMiggMC4wMjggKiBibHVyQW1vdW50LCAwLjApO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9ob3Jpem9udGFsV2lwZS9ob3Jpem9udGFsV2lwZS5mcmFnXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvaG9yaXpvbnRhbFdpcGUvaG9yaXpvbnRhbFdpcGUuZnJhZyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlX2E7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZV9iO1xcbnVuaWZvcm0gZmxvYXQgbWl4O1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZhcnlpbmcgZmxvYXQgdl9taXg7XFxudm9pZCBtYWluKCl7XFxuICAgIHZlYzQgY29sb3JfYSA9IHRleHR1cmUyRCh1X2ltYWdlX2EsIHZfdGV4Q29vcmQpO1xcbiAgICB2ZWM0IGNvbG9yX2IgPSB0ZXh0dXJlMkQodV9pbWFnZV9iLCB2X3RleENvb3JkKTtcXG4gICAgaWYgKHZfdGV4Q29vcmRbMF0gPiBtaXgpe1xcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3JfYTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yX2I7XFxuICAgIH1cXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvaG9yaXpvbnRhbFdpcGUvaG9yaXpvbnRhbFdpcGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvaG9yaXpvbnRhbFdpcGUvaG9yaXpvbnRhbFdpcGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2hvcml6b250YWxXaXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ob3Jpem9udGFsV2lwZS52ZXJ0ICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvaG9yaXpvbnRhbFdpcGUvaG9yaXpvbnRhbFdpcGUudmVydFwiKTtcblxudmFyIF9ob3Jpem9udGFsV2lwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ob3Jpem9udGFsV2lwZSk7XG5cbnZhciBfaG9yaXpvbnRhbFdpcGUzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ob3Jpem9udGFsV2lwZS5mcmFnICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvaG9yaXpvbnRhbFdpcGUvaG9yaXpvbnRhbFdpcGUuZnJhZ1wiKTtcblxudmFyIF9ob3Jpem9udGFsV2lwZTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ob3Jpem9udGFsV2lwZTMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaG9yaXpvbnRhbF93aXBlID0ge1xuICAgIHRpdGxlOiBcIkhvcml6b250YWwgV2lwZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkEgaG9yaXpvbnRhbCB3aXBlIGVmZmVjdC4gVHlwaWNhbGx5IHVzZWQgYXMgYSB0cmFuc2lzdGlvbi5cIixcbiAgICB2ZXJ0ZXhTaGFkZXI6IF9ob3Jpem9udGFsV2lwZTIuZGVmYXVsdCxcbiAgICBmcmFnbWVudFNoYWRlcjogX2hvcml6b250YWxXaXBlNC5kZWZhdWx0LFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgbWl4OiB7IHR5cGU6IFwidW5pZm9ybVwiLCB2YWx1ZTogMC4wIH1cbiAgICB9LFxuICAgIGlucHV0czogW1widV9pbWFnZV9hXCIsIFwidV9pbWFnZV9iXCJdXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBob3Jpem9udGFsX3dpcGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvaG9yaXpvbnRhbFdpcGUvaG9yaXpvbnRhbFdpcGUudmVydFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL2hvcml6b250YWxXaXBlL2hvcml6b250YWxXaXBlLnZlcnQgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHZlYzIoMi4wLDIuMCkqYV9wb3NpdGlvbi12ZWMyKDEuMCwgMS4wKSwgMC4wLCAxLjApO1xcbiAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvbW9ub2Nocm9tZS9tb25vY2hyb21lLmZyYWdcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvbW9ub2Nocm9tZS9tb25vY2hyb21lLmZyYWcgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudW5pZm9ybSB2ZWMzIGlucHV0TWl4O1xcbnVuaWZvcm0gdmVjMyBvdXRwdXRNaXg7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudmFyeWluZyBmbG9hdCB2X21peDtcXG52b2lkIG1haW4oKXtcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG4gICAgZmxvYXQgbW9ubyA9IGNvbG9yWzBdKmlucHV0TWl4WzBdICsgY29sb3JbMV0qaW5wdXRNaXhbMV0gKyBjb2xvclsyXSppbnB1dE1peFsyXTtcXG4gICAgY29sb3JbMF0gPSBtb25vICogb3V0cHV0TWl4WzBdO1xcbiAgICBjb2xvclsxXSA9IG1vbm8gKiBvdXRwdXRNaXhbMV07XFxuICAgIGNvbG9yWzJdID0gbW9ubyAqIG91dHB1dE1peFsyXTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcblwiXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL21vbm9jaHJvbWUvbW9ub2Nocm9tZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvbW9ub2Nocm9tZS9tb25vY2hyb21lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbW9ub2Nocm9tZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9ub2Nocm9tZS52ZXJ0ICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvbW9ub2Nocm9tZS9tb25vY2hyb21lLnZlcnRcIik7XG5cbnZhciBfbW9ub2Nocm9tZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb25vY2hyb21lKTtcblxudmFyIF9tb25vY2hyb21lMyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9ub2Nocm9tZS5mcmFnICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvbW9ub2Nocm9tZS9tb25vY2hyb21lLmZyYWdcIik7XG5cbnZhciBfbW9ub2Nocm9tZTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb25vY2hyb21lMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBtb25vY2hyb21lID0ge1xuICAgIHRpdGxlOiBcIk1vbm9jaHJvbWVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJDaGFuZ2UgaW1hZ2VzIHRvIGEgc2luZ2xlIGNocm9tYSAoZS5nIGNhbiBiZSB1c2VkIHRvIG1ha2UgYSBibGFjayAmIHdoaXRlIGZpbHRlcikuIElucHV0IGNvbG9yIG1peCBhbmQgb3V0cHV0IGNvbG9yIG1peCBjYW4gYmUgYWRqdXN0ZWQuXCIsXG4gICAgdmVydGV4U2hhZGVyOiBfbW9ub2Nocm9tZTIuZGVmYXVsdCxcbiAgICBmcmFnbWVudFNoYWRlcjogX21vbm9jaHJvbWU0LmRlZmF1bHQsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBpbnB1dE1peDogeyB0eXBlOiBcInVuaWZvcm1cIiwgdmFsdWU6IFswLjQsIDAuNiwgMC4yXSB9LFxuICAgICAgICBvdXRwdXRNaXg6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiBbMS4wLCAxLjAsIDEuMF0gfVxuICAgIH0sXG4gICAgaW5wdXRzOiBbXCJ1X2ltYWdlXCJdXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBtb25vY2hyb21lO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL21vbm9jaHJvbWUvbW9ub2Nocm9tZS52ZXJ0XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL21vbm9jaHJvbWUvbW9ub2Nocm9tZS52ZXJ0ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVjMigyLjAsMi4wKSphX3Bvc2l0aW9uLXZlYzIoMS4wLCAxLjApLCAwLjAsIDEuMCk7XFxuICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9vcGFjaXR5L29wYWNpdHkuZnJhZ1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9vcGFjaXR5L29wYWNpdHkuZnJhZyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudmFyeWluZyBmbG9hdCB2X29wYWNpdHk7XFxudm9pZCBtYWluKCl7XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuICAgIGNvbG9yWzNdICo9IG9wYWNpdHk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9vcGFjaXR5L29wYWNpdHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL29wYWNpdHkvb3BhY2l0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX29wYWNpdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29wYWNpdHkudmVydCAqLyBcIi4vc3JjL0RlZmluaXRpb25zL29wYWNpdHkvb3BhY2l0eS52ZXJ0XCIpO1xuXG52YXIgX29wYWNpdHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb3BhY2l0eSk7XG5cbnZhciBfb3BhY2l0eTMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29wYWNpdHkuZnJhZyAqLyBcIi4vc3JjL0RlZmluaXRpb25zL29wYWNpdHkvb3BhY2l0eS5mcmFnXCIpO1xuXG52YXIgX29wYWNpdHk0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb3BhY2l0eTMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgb3BhY2l0eSA9IHtcbiAgICB0aXRsZTogXCJPcGFjaXR5XCIsXG4gICAgZGVzY3JpcHRpb246IFwiU2V0cyB0aGUgb3BhY2l0eSBvZiBhbiBpbnB1dC5cIixcbiAgICB2ZXJ0ZXhTaGFkZXI6IF9vcGFjaXR5Mi5kZWZhdWx0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBfb3BhY2l0eTQuZGVmYXVsdCxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIG9wYWNpdHk6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiAwLjcgfVxuICAgIH0sXG4gICAgaW5wdXRzOiBbXCJ1X2ltYWdlXCJdXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBvcGFjaXR5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL29wYWNpdHkvb3BhY2l0eS52ZXJ0XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL29wYWNpdHkvb3BhY2l0eS52ZXJ0ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVjMigyLjAsMi4wKSphX3Bvc2l0aW9uLXZlYzIoMS4wLCAxLjApLCAwLjAsIDEuMCk7XFxuICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9yYW5kb21EaXNzb2x2ZS9yYW5kb21EaXNzb2x2ZS5mcmFnXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvcmFuZG9tRGlzc29sdmUvcmFuZG9tRGlzc29sdmUuZnJhZyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlX2E7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZV9iO1xcbnVuaWZvcm0gZmxvYXQgbWl4O1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZhcnlpbmcgZmxvYXQgdl9taXg7XFxuZmxvYXQgcmFuZCh2ZWMyIGNvKXtcXG4gICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoY28ueHkgLHZlYzIoMTIuOTg5OCw3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcXG59XFxudm9pZCBtYWluKCl7XFxuICAgIHZlYzQgY29sb3JfYSA9IHRleHR1cmUyRCh1X2ltYWdlX2EsIHZfdGV4Q29vcmQpO1xcbiAgICB2ZWM0IGNvbG9yX2IgPSB0ZXh0dXJlMkQodV9pbWFnZV9iLCB2X3RleENvb3JkKTtcXG4gICAgaWYgKGNsYW1wKHJhbmQodl90ZXhDb29yZCksICAwLjAxLCAxLjAwMSkgPiBtaXgpe1xcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3JfYTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yX2I7XFxuICAgIH1cXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvcmFuZG9tRGlzc29sdmUvcmFuZG9tRGlzc29sdmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvcmFuZG9tRGlzc29sdmUvcmFuZG9tRGlzc29sdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JhbmRvbURpc3NvbHZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yYW5kb21EaXNzb2x2ZS52ZXJ0ICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvcmFuZG9tRGlzc29sdmUvcmFuZG9tRGlzc29sdmUudmVydFwiKTtcblxudmFyIF9yYW5kb21EaXNzb2x2ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yYW5kb21EaXNzb2x2ZSk7XG5cbnZhciBfcmFuZG9tRGlzc29sdmUzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yYW5kb21EaXNzb2x2ZS5mcmFnICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvcmFuZG9tRGlzc29sdmUvcmFuZG9tRGlzc29sdmUuZnJhZ1wiKTtcblxudmFyIF9yYW5kb21EaXNzb2x2ZTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yYW5kb21EaXNzb2x2ZTMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgcmFuZG9tRGlzc29sdmUgPSB7XG4gICAgdGl0bGU6IFwiUmFuZG9tIERpc3NvbHZlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQSByYW5kb20gZGlzc29sdmUgZWZmZWN0LiBUeXBpY2FsbHkgdXNlZCBhcyBhIHRyYW5zaXN0aW9uLlwiLFxuICAgIHZlcnRleFNoYWRlcjogX3JhbmRvbURpc3NvbHZlMi5kZWZhdWx0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBfcmFuZG9tRGlzc29sdmU0LmRlZmF1bHQsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBtaXg6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiAwLjAgfVxuICAgIH0sXG4gICAgaW5wdXRzOiBbXCJ1X2ltYWdlX2FcIiwgXCJ1X2ltYWdlX2JcIl1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHJhbmRvbURpc3NvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL3JhbmRvbURpc3NvbHZlL3JhbmRvbURpc3NvbHZlLnZlcnRcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9yYW5kb21EaXNzb2x2ZS9yYW5kb21EaXNzb2x2ZS52ZXJ0ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh2ZWMyKDIuMCwyLjApKmFfcG9zaXRpb24tdmVjMigxLjAsIDEuMCksIDAuMCwgMS4wKTtcXG4gICAgdl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7XFxufVxcblwiXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL3N0YXJXaXBlL3N0YXJXaXBlLmZyYWdcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9zdGFyV2lwZS9zdGFyV2lwZS5mcmFnICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2VfYTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlX2I7XFxudW5pZm9ybSBmbG9hdCBtaXg7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudmFyeWluZyBmbG9hdCB2X21peDtcXG5mbG9hdCBzaWduICh2ZWMyIHAxLCB2ZWMyIHAyLCB2ZWMyIHAzKXtcXG4gICAgcmV0dXJuIChwMVswXSAtIHAzWzBdKSAqIChwMlsxXSAtIHAzWzFdKSAtIChwMlswXSAtIHAzWzBdKSAqIChwMVsxXSAtIHAzWzFdKTtcXG59XFxuYm9vbCBwb2ludEluVHJpYW5nbGUodmVjMiBwdCwgdmVjMiB2MSwgdmVjMiB2MiwgdmVjMiB2Myl7XFxuICAgIGJvb2wgYjEsIGIyLCBiMztcXG4gICAgYjEgPSBzaWduKHB0LCB2MSwgdjIpIDwgMC4wO1xcbiAgICBiMiA9IHNpZ24ocHQsIHYyLCB2MykgPCAwLjA7XFxuICAgIGIzID0gc2lnbihwdCwgdjMsIHYxKSA8IDAuMDtcXG4gICAgcmV0dXJuICgoYjEgPT0gYjIpICYmIChiMiA9PSBiMykpO1xcbn1cXG52ZWMyIHJvdGF0ZVBvaW50QWJvdXRQb2ludCh2ZWMyIHBvaW50LCB2ZWMyIHBpdm90LCBmbG9hdCBhbmdsZSl7XFxuICAgIGZsb2F0IHMgPSBzaW4oYW5nbGUpO1xcbiAgICBmbG9hdCBjID0gY29zKGFuZ2xlKTtcXG4gICAgZmxvYXQgeCA9IHBvaW50WzBdIC0gcGl2b3RbMF07XFxuICAgIGZsb2F0IHkgPSBwb2ludFsxXSAtIHBpdm90WzFdO1xcbiAgICBmbG9hdCBuZXdfeCA9IHggKiBjIC0geSAqIHM7XFxuICAgIGZsb2F0IG5ld195ID0geCAqIHMgKyB5ICogYztcXG4gICAgcmV0dXJuIHZlYzIobmV3X3ggKyBwaXZvdFswXSwgbmV3X3krcGl2b3RbMV0pO1xcbn1cXG5cXG52b2lkIG1haW4oKXtcXG4gICAgdmVjNCBjb2xvcl9hID0gdGV4dHVyZTJEKHVfaW1hZ2VfYiwgdl90ZXhDb29yZCk7XFxuICAgIHZlYzQgY29sb3JfYiA9IHRleHR1cmUyRCh1X2ltYWdlX2EsIHZfdGV4Q29vcmQpO1xcbiAgICB2ZWMyIHQwX3AwLHQwX3AxLHQwX3AyLHQxX3AwLHQxX3AxLHQxX3AyLHQyX3AwLHQyX3AxLHQyX3AyLHQzX3AwLHQzX3AxLHQzX3AyO1xcbiAgICB2ZWMyIHQ0X3AwLHQ0X3AxLHQ0X3AyLHQ1X3AwLHQ1X3AxLHQ1X3AyLHQ2X3AwLHQ2X3AxLHQ2X3AyLHQ3X3AwLHQ3X3AxLHQ3X3AyO1xcblxcblxcbiAgICB0MF9wMCA9IHZlYzIoMC4wLCAwLjI1KSAqIGNsYW1wKG1peCwwLjAsMS4wKSAqIDIuMCArIHZlYzIoMC41LDAuNSk7XFxuICAgIHQwX3AxID0gdmVjMigwLjAsIC0wLjI1KSAqIGNsYW1wKG1peCwwLjAsMS4wKSAqIDIuMCArIHZlYzIoMC41LDAuNSk7XFxuICAgIHQwX3AyID0gdmVjMigxLjAsIDAuMCkgKiBjbGFtcChtaXgsMC4wLDEuMCkgKiAyLjAgKyB2ZWMyKDAuNSwwLjUpO1xcblxcbiAgICB0MV9wMCA9IHJvdGF0ZVBvaW50QWJvdXRQb2ludCh0MF9wMCwgdmVjMigwLjUsMC41KSwgMC43ODU0KTtcXG4gICAgdDFfcDEgPSByb3RhdGVQb2ludEFib3V0UG9pbnQodDBfcDEsIHZlYzIoMC41LDAuNSksIDAuNzg1NCk7XFxuICAgIHQxX3AyID0gcm90YXRlUG9pbnRBYm91dFBvaW50KHQwX3AyLCB2ZWMyKDAuNSwwLjUpLCAwLjc4NTQpO1xcblxcbiAgICB0Ml9wMCA9IHJvdGF0ZVBvaW50QWJvdXRQb2ludCh0MF9wMCwgdmVjMigwLjUsMC41KSwgMC43ODU0ICogMi4wKTtcXG4gICAgdDJfcDEgPSByb3RhdGVQb2ludEFib3V0UG9pbnQodDBfcDEsIHZlYzIoMC41LDAuNSksIDAuNzg1NCAqIDIuMCk7XFxuICAgIHQyX3AyID0gcm90YXRlUG9pbnRBYm91dFBvaW50KHQwX3AyLCB2ZWMyKDAuNSwwLjUpLCAwLjc4NTQgKiAyLjApO1xcblxcbiAgICB0M19wMCA9IHJvdGF0ZVBvaW50QWJvdXRQb2ludCh0MF9wMCwgdmVjMigwLjUsMC41KSwgMC43ODU0ICogMy4wKTtcXG4gICAgdDNfcDEgPSByb3RhdGVQb2ludEFib3V0UG9pbnQodDBfcDEsIHZlYzIoMC41LDAuNSksIDAuNzg1NCAqIDMuMCk7XFxuICAgIHQzX3AyID0gcm90YXRlUG9pbnRBYm91dFBvaW50KHQwX3AyLCB2ZWMyKDAuNSwwLjUpLCAwLjc4NTQgKiAzLjApO1xcblxcbiAgICB0NF9wMCA9IHJvdGF0ZVBvaW50QWJvdXRQb2ludCh0MF9wMCwgdmVjMigwLjUsMC41KSwgMC43ODU0ICogNC4wKTtcXG4gICAgdDRfcDEgPSByb3RhdGVQb2ludEFib3V0UG9pbnQodDBfcDEsIHZlYzIoMC41LDAuNSksIDAuNzg1NCAqIDQuMCk7XFxuICAgIHQ0X3AyID0gcm90YXRlUG9pbnRBYm91dFBvaW50KHQwX3AyLCB2ZWMyKDAuNSwwLjUpLCAwLjc4NTQgKiA0LjApO1xcblxcbiAgICB0NV9wMCA9IHJvdGF0ZVBvaW50QWJvdXRQb2ludCh0MF9wMCwgdmVjMigwLjUsMC41KSwgMC43ODU0ICogNS4wKTtcXG4gICAgdDVfcDEgPSByb3RhdGVQb2ludEFib3V0UG9pbnQodDBfcDEsIHZlYzIoMC41LDAuNSksIDAuNzg1NCAqIDUuMCk7XFxuICAgIHQ1X3AyID0gcm90YXRlUG9pbnRBYm91dFBvaW50KHQwX3AyLCB2ZWMyKDAuNSwwLjUpLCAwLjc4NTQgKiA1LjApO1xcblxcbiAgICB0Nl9wMCA9IHJvdGF0ZVBvaW50QWJvdXRQb2ludCh0MF9wMCwgdmVjMigwLjUsMC41KSwgMC43ODU0ICogNi4wKTtcXG4gICAgdDZfcDEgPSByb3RhdGVQb2ludEFib3V0UG9pbnQodDBfcDEsIHZlYzIoMC41LDAuNSksIDAuNzg1NCAqIDYuMCk7XFxuICAgIHQ2X3AyID0gcm90YXRlUG9pbnRBYm91dFBvaW50KHQwX3AyLCB2ZWMyKDAuNSwwLjUpLCAwLjc4NTQgKiA2LjApO1xcblxcbiAgICB0N19wMCA9IHJvdGF0ZVBvaW50QWJvdXRQb2ludCh0MF9wMCwgdmVjMigwLjUsMC41KSwgMC43ODU0ICogNy4wKTtcXG4gICAgdDdfcDEgPSByb3RhdGVQb2ludEFib3V0UG9pbnQodDBfcDEsIHZlYzIoMC41LDAuNSksIDAuNzg1NCAqIDcuMCk7XFxuICAgIHQ3X3AyID0gcm90YXRlUG9pbnRBYm91dFBvaW50KHQwX3AyLCB2ZWMyKDAuNSwwLjUpLCAwLjc4NTQgKiA3LjApO1xcblxcbiAgICBpZihtaXggPiAwLjk5KXtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yX2E7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgaWYobWl4IDwgMC4wMSl7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcl9iO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGlmKHBvaW50SW5UcmlhbmdsZSh2X3RleENvb3JkLCB0MF9wMCwgdDBfcDEsIHQwX3AyKSB8fCBwb2ludEluVHJpYW5nbGUodl90ZXhDb29yZCwgdDFfcDAsIHQxX3AxLCB0MV9wMikgfHwgcG9pbnRJblRyaWFuZ2xlKHZfdGV4Q29vcmQsIHQyX3AwLCB0Ml9wMSwgdDJfcDIpIHx8IHBvaW50SW5UcmlhbmdsZSh2X3RleENvb3JkLCB0M19wMCwgdDNfcDEsIHQzX3AyKSB8fCBwb2ludEluVHJpYW5nbGUodl90ZXhDb29yZCwgdDRfcDAsIHQ0X3AxLCB0NF9wMikgfHwgcG9pbnRJblRyaWFuZ2xlKHZfdGV4Q29vcmQsIHQ1X3AwLCB0NV9wMSwgdDVfcDIpIHx8IHBvaW50SW5UcmlhbmdsZSh2X3RleENvb3JkLCB0Nl9wMCwgdDZfcDEsIHQ2X3AyKSB8fCBwb2ludEluVHJpYW5nbGUodl90ZXhDb29yZCwgdDdfcDAsIHQ3X3AxLCB0N19wMikpe1xcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3JfYTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yX2I7XFxuICAgIH1cXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvc3RhcldpcGUvc3RhcldpcGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvc3RhcldpcGUvc3RhcldpcGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3N0YXJXaXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdGFyV2lwZS52ZXJ0ICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvc3RhcldpcGUvc3RhcldpcGUudmVydFwiKTtcblxudmFyIF9zdGFyV2lwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdGFyV2lwZSk7XG5cbnZhciBfc3RhcldpcGUzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdGFyV2lwZS5mcmFnICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvc3RhcldpcGUvc3RhcldpcGUuZnJhZ1wiKTtcblxudmFyIF9zdGFyV2lwZTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdGFyV2lwZTMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc3RhcldpcGUgPSB7XG4gICAgdGl0bGU6IFwiU3RhciBXaXBlIEZhZGVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBIGNsYXNzaWMgc3RhciB3aXBlIHRyYW5zaXN0aW9uLiBUeXBpY2FsbHkgdXNlZCBhcyBhIHRyYW5zaXN0aW9uLlwiLFxuICAgIHZlcnRleFNoYWRlcjogX3N0YXJXaXBlMi5kZWZhdWx0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBfc3RhcldpcGU0LmRlZmF1bHQsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBtaXg6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiAxLjAgfVxuICAgIH0sXG4gICAgaW5wdXRzOiBbXCJ1X2ltYWdlX2FcIiwgXCJ1X2ltYWdlX2JcIl1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHN0YXJXaXBlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL3N0YXJXaXBlL3N0YXJXaXBlLnZlcnRcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9zdGFyV2lwZS9zdGFyV2lwZS52ZXJ0ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh2ZWMyKDIuMCwyLjApKmFfcG9zaXRpb24tdmVjMigxLjAsIDEuMCksIDAuMCwgMS4wKTtcXG4gICAgdl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7XFxufVxcblwiXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL3N0YXRpY0Rpc3NvbHZlL3N0YXRpY0Rpc3NvbHZlLmZyYWdcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9zdGF0aWNEaXNzb2x2ZS9zdGF0aWNEaXNzb2x2ZS5mcmFnICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2VfYTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlX2I7XFxudW5pZm9ybSBmbG9hdCBtaXg7XFxudW5pZm9ybSBmbG9hdCBjdXJyZW50VGltZTtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG52YXJ5aW5nIGZsb2F0IHZfbWl4O1xcbmZsb2F0IHJhbmQodmVjMiBjbywgZmxvYXQgY3VycmVudFRpbWUpe1xcbiAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChjby54eSx2ZWMyKDEyLjk4OTgsNzguMjMzKSkrY3VycmVudFRpbWUpICogNDM3NTguNTQ1Myk7XFxufVxcbnZvaWQgbWFpbigpe1xcbiAgICB2ZWM0IGNvbG9yX2EgPSB0ZXh0dXJlMkQodV9pbWFnZV9hLCB2X3RleENvb3JkKTtcXG4gICAgdmVjNCBjb2xvcl9iID0gdGV4dHVyZTJEKHVfaW1hZ2VfYiwgdl90ZXhDb29yZCk7XFxuICAgIGlmIChjbGFtcChyYW5kKHZfdGV4Q29vcmQsIGN1cnJlbnRUaW1lKSwgIDAuMDEsIDEuMDAxKSA+IG1peCl7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcl9hO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3JfYjtcXG4gICAgfVxcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9zdGF0aWNEaXNzb2x2ZS9zdGF0aWNEaXNzb2x2ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9zdGF0aWNEaXNzb2x2ZS9zdGF0aWNEaXNzb2x2ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3RhdGljRGlzc29sdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0YXRpY0Rpc3NvbHZlLnZlcnQgKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9zdGF0aWNEaXNzb2x2ZS9zdGF0aWNEaXNzb2x2ZS52ZXJ0XCIpO1xuXG52YXIgX3N0YXRpY0Rpc3NvbHZlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0YXRpY0Rpc3NvbHZlKTtcblxudmFyIF9zdGF0aWNEaXNzb2x2ZTMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0YXRpY0Rpc3NvbHZlLmZyYWcgKi8gXCIuL3NyYy9EZWZpbml0aW9ucy9zdGF0aWNEaXNzb2x2ZS9zdGF0aWNEaXNzb2x2ZS5mcmFnXCIpO1xuXG52YXIgX3N0YXRpY0Rpc3NvbHZlNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0YXRpY0Rpc3NvbHZlMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzdGF0aWNEaXNzb2x2ZSA9IHtcbiAgICB0aXRsZTogXCJTdGF0aWMgRGlzc29sdmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBIHN0YXRpYyBkaXNzb2x2ZSBlZmZlY3QuIFR5cGljYWxseSB1c2VkIGFzIGEgdHJhbnNpc3Rpb24uXCIsXG4gICAgdmVydGV4U2hhZGVyOiBfc3RhdGljRGlzc29sdmUyLmRlZmF1bHQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IF9zdGF0aWNEaXNzb2x2ZTQuZGVmYXVsdCxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIG1peDogeyB0eXBlOiBcInVuaWZvcm1cIiwgdmFsdWU6IDAuMCB9XG4gICAgfSxcbiAgICBpbnB1dHM6IFtcInVfaW1hZ2VfYVwiLCBcInVfaW1hZ2VfYlwiXVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gc3RhdGljRGlzc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvc3RhdGljRGlzc29sdmUvc3RhdGljRGlzc29sdmUudmVydFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL3N0YXRpY0Rpc3NvbHZlL3N0YXRpY0Rpc3NvbHZlLnZlcnQgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHZlYzIoMi4wLDIuMCkqYV9wb3NpdGlvbi12ZWMyKDEuMCwgMS4wKSwgMC4wLCAxLjApO1xcbiAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvc3RhdGljRWZmZWN0L3N0YXRpY0VmZmVjdC5mcmFnXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy9zdGF0aWNFZmZlY3Qvc3RhdGljRWZmZWN0LmZyYWcgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gZmxvYXQgY3VycmVudFRpbWU7XFxudW5pZm9ybSBmbG9hdCBhbW91bnQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudW5pZm9ybSB2ZWMzIHdlaWdodDtcXG5mbG9hdCByYW5kKHZlYzIgY28sIGZsb2F0IGN1cnJlbnRUaW1lKXtcXG4gICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoY28ueHksdmVjMigxMi45ODk4LDc4LjIzMykpK2N1cnJlbnRUaW1lKSAqIDQzNzU4LjU0NTMpO1xcbn1cXG52b2lkIG1haW4oKXtcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG4gICAgY29sb3JbMF0gPSBjb2xvclswXSArICgyLjAqKGNsYW1wKHJhbmQodl90ZXhDb29yZCwgY3VycmVudFRpbWUpLCAgMC4wMSwgMS4wMDEpLTAuNSkpICogd2VpZ2h0WzBdICogYW1vdW50O1xcbiAgICBjb2xvclsxXSA9IGNvbG9yWzFdICsgKDIuMCooY2xhbXAocmFuZCh2X3RleENvb3JkLCBjdXJyZW50VGltZSksICAwLjAxLCAxLjAwMSktMC41KSkgKiB3ZWlnaHRbMV0gKiBhbW91bnQ7XFxuICAgIGNvbG9yWzJdID0gY29sb3JbMl0gKyAoMi4wKihjbGFtcChyYW5kKHZfdGV4Q29vcmQsIGN1cnJlbnRUaW1lKSwgIDAuMDEsIDEuMDAxKS0wLjUpKSAqIHdlaWdodFsyXSAqYW1vdW50O1xcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvc3RhdGljRWZmZWN0L3N0YXRpY0VmZmVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL3N0YXRpY0VmZmVjdC9zdGF0aWNFZmZlY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3RhdGljRWZmZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdGF0aWNFZmZlY3QudmVydCAqLyBcIi4vc3JjL0RlZmluaXRpb25zL3N0YXRpY0VmZmVjdC9zdGF0aWNFZmZlY3QudmVydFwiKTtcblxudmFyIF9zdGF0aWNFZmZlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RhdGljRWZmZWN0KTtcblxudmFyIF9zdGF0aWNFZmZlY3QzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdGF0aWNFZmZlY3QuZnJhZyAqLyBcIi4vc3JjL0RlZmluaXRpb25zL3N0YXRpY0VmZmVjdC9zdGF0aWNFZmZlY3QuZnJhZ1wiKTtcblxudmFyIF9zdGF0aWNFZmZlY3Q0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RhdGljRWZmZWN0Myk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzdGF0aWNFZmZlY3QgPSB7XG4gICAgdGl0bGU6IFwiU3RhdGljXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQSBzdGF0aWMgZWZmZWN0IHRvIGFkZCBwc2V1ZG8gcmFuZG9tIG5vaXNlIHRvIGEgdmlkZW9cIixcbiAgICB2ZXJ0ZXhTaGFkZXI6IF9zdGF0aWNFZmZlY3QyLmRlZmF1bHQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IF9zdGF0aWNFZmZlY3Q0LmRlZmF1bHQsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICB3ZWlnaHQ6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiBbMS4wLCAxLjAsIDEuMF0gfSxcbiAgICAgICAgYW1vdW50OiB7IHR5cGU6IFwidW5pZm9ybVwiLCB2YWx1ZTogMS4wIH1cbiAgICB9LFxuICAgIGlucHV0czogW1widV9pbWFnZVwiXVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gc3RhdGljRWZmZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0RlZmluaXRpb25zL3N0YXRpY0VmZmVjdC9zdGF0aWNFZmZlY3QudmVydFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvc3RhdGljRWZmZWN0L3N0YXRpY0VmZmVjdC52ZXJ0ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHZlYzIoMi4wLDIuMCkqYV9wb3NpdGlvbi12ZWMyKDEuMCwgMS4wKSwgMC4wLCAxLjApO1xcbiAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvdG9Db2xvckFuZEJhY2tGYWRlL3RvQ29sb3JBbmRCYWNrRmFkZS5mcmFnXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy90b0NvbG9yQW5kQmFja0ZhZGUvdG9Db2xvckFuZEJhY2tGYWRlLmZyYWcgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlX2E7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZV9iO1xcbnVuaWZvcm0gZmxvYXQgbWl4O1xcbnVuaWZvcm0gdmVjNCBjb2xvcjtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG52YXJ5aW5nIGZsb2F0IHZfbWl4O1xcbnZvaWQgbWFpbigpe1xcbiAgICB2ZWM0IGNvbG9yX2EgPSB0ZXh0dXJlMkQodV9pbWFnZV9hLCB2X3RleENvb3JkKTtcXG4gICAgdmVjNCBjb2xvcl9iID0gdGV4dHVyZTJEKHVfaW1hZ2VfYiwgdl90ZXhDb29yZCk7XFxuICAgIGZsb2F0IG1peF9hbW91bnQgPSAobWl4ICoyLjApIC0gMS4wO1xcbiAgICBpZihtaXhfYW1vdW50IDwgMC4wKXtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGFicyhtaXhfYW1vdW50KSAqIGNvbG9yX2EgKyAoMS4wIC0gYWJzKG1peF9hbW91bnQpKSAqIGNvbG9yO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gbWl4X2Ftb3VudCAqIGNvbG9yX2IgKyAoMS4wIC0gbWl4X2Ftb3VudCkgKiBjb2xvcjtcXG4gICAgfVxcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy90b0NvbG9yQW5kQmFja0ZhZGUvdG9Db2xvckFuZEJhY2tGYWRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvdG9Db2xvckFuZEJhY2tGYWRlL3RvQ29sb3JBbmRCYWNrRmFkZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90b0NvbG9yQW5kQmFja0ZhZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvQ29sb3JBbmRCYWNrRmFkZS52ZXJ0ICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvdG9Db2xvckFuZEJhY2tGYWRlL3RvQ29sb3JBbmRCYWNrRmFkZS52ZXJ0XCIpO1xuXG52YXIgX3RvQ29sb3JBbmRCYWNrRmFkZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b0NvbG9yQW5kQmFja0ZhZGUpO1xuXG52YXIgX3RvQ29sb3JBbmRCYWNrRmFkZTMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvQ29sb3JBbmRCYWNrRmFkZS5mcmFnICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvdG9Db2xvckFuZEJhY2tGYWRlL3RvQ29sb3JBbmRCYWNrRmFkZS5mcmFnXCIpO1xuXG52YXIgX3RvQ29sb3JBbmRCYWNrRmFkZTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b0NvbG9yQW5kQmFja0ZhZGUzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHRvQ29sb3JBbmRCYWNrRmFkZSA9IHtcbiAgICB0aXRsZTogXCJUbyBDb2xvciBBbmQgQmFjayBGYWRlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQSBmYWRlIHRvIGJsYWNrIGFuZCBiYWNrIGVmZmVjdC4gU2V0dGluZyBtaXggdG8gMC41IGlzIGEgZnVsbHkgc29saWQgY29sb3IgZnJhbWUuIFR5cGljYWxseSB1c2VkIGFzIGEgdHJhbnNpc3Rpb24uXCIsXG4gICAgdmVydGV4U2hhZGVyOiBfdG9Db2xvckFuZEJhY2tGYWRlMi5kZWZhdWx0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBfdG9Db2xvckFuZEJhY2tGYWRlNC5kZWZhdWx0LFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgbWl4OiB7IHR5cGU6IFwidW5pZm9ybVwiLCB2YWx1ZTogMC4wIH0sXG4gICAgICAgIGNvbG9yOiB7IHR5cGU6IFwidW5pZm9ybVwiLCB2YWx1ZTogWzAuMCwgMC4wLCAwLjAsIDAuMF0gfVxuICAgIH0sXG4gICAgaW5wdXRzOiBbXCJ1X2ltYWdlX2FcIiwgXCJ1X2ltYWdlX2JcIl1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSB0b0NvbG9yQW5kQmFja0ZhZGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvdG9Db2xvckFuZEJhY2tGYWRlL3RvQ29sb3JBbmRCYWNrRmFkZS52ZXJ0XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZWZpbml0aW9ucy90b0NvbG9yQW5kQmFja0ZhZGUvdG9Db2xvckFuZEJhY2tGYWRlLnZlcnQgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVjMigyLjAsMi4wKSphX3Bvc2l0aW9uLXZlYzIoMS4wLCAxLjApLCAwLjAsIDEuMCk7XFxuICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy92ZXJ0aWNhbEJsdXIvdmVydGljYWxCbHVyLmZyYWdcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL3ZlcnRpY2FsQmx1ci92ZXJ0aWNhbEJsdXIuZnJhZyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudmFyeWluZyB2ZWMyIHZfYmx1clRleENvb3Jkc1sxNF07XFxudm9pZCBtYWluKCl7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wKTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDBdKSowLjAwNDQyOTkxMjEwNTUxMTMyNjU7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl9ibHVyVGV4Q29vcmRzWyAxXSkqMC4wMDg5NTc4MTIxMTc5NDtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDJdKSowLjAyMTU5NjM4NjYwNTM7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl9ibHVyVGV4Q29vcmRzWyAzXSkqMC4wNDQzNjgzMzM4NzE4O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfYmx1clRleENvb3Jkc1sgNF0pKjAuMDc3Njc0NDIxOTkzMztcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDVdKSowLjExNTg3NjYyMTEwNTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDZdKSowLjE0NzMwODA1NjEyMTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkICAgICAgICAgKSowLjE1OTU3NjkxMjE2MTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDddKSowLjE0NzMwODA1NjEyMTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDhdKSowLjExNTg3NjYyMTEwNTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbIDldKSowLjA3NzY3NDQyMTk5MzM7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl9ibHVyVGV4Q29vcmRzWzEwXSkqMC4wNDQzNjgzMzM4NzE4O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfYmx1clRleENvb3Jkc1sxMV0pKjAuMDIxNTk2Mzg2NjA1MztcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1X2ltYWdlLCB2X2JsdXJUZXhDb29yZHNbMTJdKSowLjAwODk1NzgxMjExNzk0O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfYmx1clRleENvb3Jkc1sxM10pKjAuMDA0NDI5OTEyMTA1NTExMzI2NTtcXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVmaW5pdGlvbnMvdmVydGljYWxCbHVyL3ZlcnRpY2FsQmx1ci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL3ZlcnRpY2FsQmx1ci92ZXJ0aWNhbEJsdXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdmVydGljYWxCbHVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92ZXJ0aWNhbEJsdXIudmVydCAqLyBcIi4vc3JjL0RlZmluaXRpb25zL3ZlcnRpY2FsQmx1ci92ZXJ0aWNhbEJsdXIudmVydFwiKTtcblxudmFyIF92ZXJ0aWNhbEJsdXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmVydGljYWxCbHVyKTtcblxudmFyIF92ZXJ0aWNhbEJsdXIzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92ZXJ0aWNhbEJsdXIuZnJhZyAqLyBcIi4vc3JjL0RlZmluaXRpb25zL3ZlcnRpY2FsQmx1ci92ZXJ0aWNhbEJsdXIuZnJhZ1wiKTtcblxudmFyIF92ZXJ0aWNhbEJsdXI0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmVydGljYWxCbHVyMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB2ZXJ0aWNhbEJsdXIgPSB7XG4gICAgdGl0bGU6IFwiVmVydGljYWwgQmx1clwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkEgdmVydGljYWwgYmx1ciBlZmZlY3QuIEFkcGF0ZWQgZnJvbSBodHRwOi8veGlzc2J1cmcuY29tL2Zhc3Rlci1nYXVzc2lhbi1ibHVyLWluLWdsc2wvXCIsXG4gICAgdmVydGV4U2hhZGVyOiBfdmVydGljYWxCbHVyMi5kZWZhdWx0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBfdmVydGljYWxCbHVyNC5kZWZhdWx0LFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgYmx1ckFtb3VudDogeyB0eXBlOiBcInVuaWZvcm1cIiwgdmFsdWU6IDEuMCB9XG4gICAgfSxcbiAgICBpbnB1dHM6IFtcInVfaW1hZ2VcIl1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHZlcnRpY2FsQmx1cjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy92ZXJ0aWNhbEJsdXIvdmVydGljYWxCbHVyLnZlcnRcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL3ZlcnRpY2FsQmx1ci92ZXJ0aWNhbEJsdXIudmVydCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIGZsb2F0IGJsdXJBbW91bnQ7XFxudmFyeWluZyB2ZWMyIHZfYmx1clRleENvb3Jkc1sxNF07XFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVjMigyLjAsMi4wKSphX3Bvc2l0aW9uLXZlYzIoMS4wLCAxLjApLCAwLjAsIDEuMCk7XFxuICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbIDBdID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLC0wLjAyOCAqIGJsdXJBbW91bnQpO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbIDFdID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLC0wLjAyNCAqIGJsdXJBbW91bnQpO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbIDJdID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLC0wLjAyMCAqIGJsdXJBbW91bnQpO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbIDNdID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLC0wLjAxNiAqIGJsdXJBbW91bnQpO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbIDRdID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLC0wLjAxMiAqIGJsdXJBbW91bnQpO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbIDVdID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLC0wLjAwOCAqIGJsdXJBbW91bnQpO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbIDZdID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLC0wLjAwNCAqIGJsdXJBbW91bnQpO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbIDddID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLCAwLjAwNCAqIGJsdXJBbW91bnQpO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbIDhdID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLCAwLjAwOCAqIGJsdXJBbW91bnQpO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbIDldID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLCAwLjAxMiAqIGJsdXJBbW91bnQpO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbMTBdID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLCAwLjAxNiAqIGJsdXJBbW91bnQpO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbMTFdID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLCAwLjAyMCAqIGJsdXJBbW91bnQpO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbMTJdID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLCAwLjAyNCAqIGJsdXJBbW91bnQpO1xcbiAgICB2X2JsdXJUZXhDb29yZHNbMTNdID0gdl90ZXhDb29yZCArIHZlYzIoMC4wLCAwLjAyOCAqIGJsdXJBbW91bnQpO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy92ZXJ0aWNhbFdpcGUvdmVydGljYWxXaXBlLmZyYWdcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL3ZlcnRpY2FsV2lwZS92ZXJ0aWNhbFdpcGUuZnJhZyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2VfYTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlX2I7XFxudW5pZm9ybSBmbG9hdCBtaXg7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudmFyeWluZyBmbG9hdCB2X21peDtcXG52b2lkIG1haW4oKXtcXG4gICAgdmVjNCBjb2xvcl9hID0gdGV4dHVyZTJEKHVfaW1hZ2VfYSwgdl90ZXhDb29yZCk7XFxuICAgIHZlYzQgY29sb3JfYiA9IHRleHR1cmUyRCh1X2ltYWdlX2IsIHZfdGV4Q29vcmQpO1xcbiAgICBpZiAodl90ZXhDb29yZFsxXSA+IG1peCl7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcl9hO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3JfYjtcXG4gICAgfVxcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy92ZXJ0aWNhbFdpcGUvdmVydGljYWxXaXBlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVmaW5pdGlvbnMvdmVydGljYWxXaXBlL3ZlcnRpY2FsV2lwZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF92ZXJ0aWNhbFdpcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ZlcnRpY2FsV2lwZS52ZXJ0ICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvdmVydGljYWxXaXBlL3ZlcnRpY2FsV2lwZS52ZXJ0XCIpO1xuXG52YXIgX3ZlcnRpY2FsV2lwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92ZXJ0aWNhbFdpcGUpO1xuXG52YXIgX3ZlcnRpY2FsV2lwZTMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ZlcnRpY2FsV2lwZS5mcmFnICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvdmVydGljYWxXaXBlL3ZlcnRpY2FsV2lwZS5mcmFnXCIpO1xuXG52YXIgX3ZlcnRpY2FsV2lwZTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92ZXJ0aWNhbFdpcGUzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHZlcnRpY2FsV2lwZSA9IHtcbiAgICB0aXRsZTogXCJ2ZXJ0aWNhbCBXaXBlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQSB2ZXJ0aWNhbCB3aXBlIGVmZmVjdC4gVHlwaWNhbGx5IHVzZWQgYXMgYSB0cmFuc2lzdGlvbi5cIixcbiAgICB2ZXJ0ZXhTaGFkZXI6IF92ZXJ0aWNhbFdpcGUyLmRlZmF1bHQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IF92ZXJ0aWNhbFdpcGU0LmRlZmF1bHQsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBtaXg6IHsgdHlwZTogXCJ1bmlmb3JtXCIsIHZhbHVlOiAwLjAgfVxuICAgIH0sXG4gICAgaW5wdXRzOiBbXCJ1X2ltYWdlX2FcIiwgXCJ1X2ltYWdlX2JcIl1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHZlcnRpY2FsV2lwZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9EZWZpbml0aW9ucy92ZXJ0aWNhbFdpcGUvdmVydGljYWxXaXBlLnZlcnRcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0RlZmluaXRpb25zL3ZlcnRpY2FsV2lwZS92ZXJ0aWNhbFdpcGUudmVydCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh2ZWMyKDIuMCwyLjApKmFfcG9zaXRpb24tdmVjMigxLjAsIDEuMCksIDAuMCwgMS4wKTtcXG4gICAgdl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7XFxufVxcblwiXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0Rlc3RpbmF0aW9uTm9kZS9kZXN0aW5hdGlvbm5vZGUuZnJhZ1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvRGVzdGluYXRpb25Ob2RlL2Rlc3RpbmF0aW9ubm9kZS5mcmFnICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG52YXJ5aW5nIGZsb2F0IHZfcHJvZ3Jlc3M7XFxudm9pZCBtYWluKCl7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG59XFxuXCJcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVzdGluYXRpb25Ob2RlL2Rlc3RpbmF0aW9ubm9kZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0Rlc3RpbmF0aW9uTm9kZS9kZXN0aW5hdGlvbm5vZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkRFU1RJTkFUSU9OVFlQRSA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3Byb2Nlc3Npbmdub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vUHJvY2Vzc2luZ05vZGVzL3Byb2Nlc3Npbmdub2RlICovIFwiLi9zcmMvUHJvY2Vzc2luZ05vZGVzL3Byb2Nlc3Npbmdub2RlLmpzXCIpO1xuXG52YXIgX3Byb2Nlc3Npbmdub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb2Nlc3Npbmdub2RlKTtcblxudmFyIF9kZXN0aW5hdGlvbm5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Rlc3RpbmF0aW9ubm9kZS5mcmFnICovIFwiLi9zcmMvRGVzdGluYXRpb25Ob2RlL2Rlc3RpbmF0aW9ubm9kZS5mcmFnXCIpO1xuXG52YXIgX2Rlc3RpbmF0aW9ubm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXN0aW5hdGlvbm5vZGUpO1xuXG52YXIgX2Rlc3RpbmF0aW9ubm9kZTMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Rlc3RpbmF0aW9ubm9kZS52ZXJ0ICovIFwiLi9zcmMvRGVzdGluYXRpb25Ob2RlL2Rlc3RpbmF0aW9ubm9kZS52ZXJ0XCIpO1xuXG52YXIgX2Rlc3RpbmF0aW9ubm9kZTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXN0aW5hdGlvbm5vZGUzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvL01hdHRoZXcgU2hvdHRvbiwgUiZEIFVzZXIgRXhwZXJpZW5jZSzCqSBCQkMgMjAxNVxuXG5cbnZhciBUWVBFID0gXCJEZXN0aW5hdGlvbk5vZGVcIjtcblxudmFyIERlc3RpbmF0aW9uTm9kZSA9IGZ1bmN0aW9uIChfUHJvY2Vzc2luZ05vZGUpIHtcbiAgICBfaW5oZXJpdHMoRGVzdGluYXRpb25Ob2RlLCBfUHJvY2Vzc2luZ05vZGUpO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSBhbiBpbnN0YW5jZSBvZiBhIERlc3RpbmF0aW9uTm9kZS5cbiAgICAgKlxuICAgICAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIGluc3RhbmNlIG9mIGEgRGVzdGluYXRpb25Ob2RlIHBlciBWaWRlb0NvbnRleHQgaW5zdGFuY2UuIEFuIFZpZGVvQ29udGV4dCdzIGRlc3RpbmF0aW9uIGNhbiBiZSBhY2Nlc3NlZCBsaWtlIHNvOiB2aWRlb0NvbnRleHQuZGVzaXRuYXRpb24uXG4gICAgICpcbiAgICAgKiBZb3Ugc2hvdWxkIG5vdCBpbnN0YW50aWF0ZSB0aGlzIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlc3RpbmF0aW9uTm9kZShnbCwgcmVuZGVyR3JhcGgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlc3RpbmF0aW9uTm9kZSk7XG5cbiAgICAgICAgdmFyIGRlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogX2Rlc3RpbmF0aW9ubm9kZTIuZGVmYXVsdCxcbiAgICAgICAgICAgIHZlcnRleFNoYWRlcjogX2Rlc3RpbmF0aW9ubm9kZTQuZGVmYXVsdCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgaW5wdXRzOiBbXCJ1X2ltYWdlXCJdXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERlc3RpbmF0aW9uTm9kZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERlc3RpbmF0aW9uTm9kZSkpLmNhbGwodGhpcywgZ2wsIHJlbmRlckdyYXBoLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uLmlucHV0cywgZmFsc2UpKTtcblxuICAgICAgICBfdGhpcy5fZGlzcGxheU5hbWUgPSBUWVBFO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKERlc3RpbmF0aW9uTm9kZSwgW3tcbiAgICAgICAga2V5OiBcIl9yZW5kZXJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5fZ2w7XG5cbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDAuMCk7IC8vIGdyZWVuO1xuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfZ2V0KERlc3RpbmF0aW9uTm9kZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEZXN0aW5hdGlvbk5vZGUucHJvdG90eXBlKSwgXCJfcmVuZGVyXCIsIF90aGlzMikuY2FsbChfdGhpczIpO1xuICAgICAgICAgICAgICAgIC8vbWFwIHRoZSBpbnB1dCB0ZXh0dXJlcyBpbnB1dCB0aGUgbm9kZVxuICAgICAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gbm9kZS5fdGV4dHVyZTtcblxuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfdGhpczIuX3NoYWRlcklucHV0c1RleHR1cmVVbml0TWFwcGluZ1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBwaW5nID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUobWFwcGluZy50ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkobWFwcGluZy5sb2NhdGlvbiwgbWFwcGluZy50ZXh0dXJlVW5pdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgNik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEZXN0aW5hdGlvbk5vZGU7XG59KF9wcm9jZXNzaW5nbm9kZTIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuREVTVElOQVRJT05UWVBFID0gVFlQRTtcbmV4cG9ydHMuZGVmYXVsdCA9IERlc3RpbmF0aW9uTm9kZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvRGVzdGluYXRpb25Ob2RlL2Rlc3RpbmF0aW9ubm9kZS52ZXJ0XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9EZXN0aW5hdGlvbk5vZGUvZGVzdGluYXRpb25ub2RlLnZlcnQgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVjMigyLjAsMi4wKSphX3Bvc2l0aW9uLXZlYzIoMS4wLCAxLjApLCAwLjAsIDEuMCk7XFxuICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xcbn1cXG5cIlxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9Qcm9jZXNzaW5nTm9kZXMvY29tcG9zaXRpbmdub2RlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvUHJvY2Vzc2luZ05vZGVzL2NvbXBvc2l0aW5nbm9kZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ09NUE9TSVRJTkdUWVBFID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcHJvY2Vzc2luZ25vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Byb2Nlc3Npbmdub2RlICovIFwiLi9zcmMvUHJvY2Vzc2luZ05vZGVzL3Byb2Nlc3Npbmdub2RlLmpzXCIpO1xuXG52YXIgX3Byb2Nlc3Npbmdub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb2Nlc3Npbmdub2RlKTtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLy9NYXR0aGV3IFNob3R0b24sIFImRCBVc2VyIEV4cGVyaWVuY2UswqkgQkJDIDIwMTVcblxuXG52YXIgVFlQRSA9IFwiQ29tcG9zaXRpbmdOb2RlXCI7XG5cbnZhciBDb21wb3NpdGluZ05vZGUgPSBmdW5jdGlvbiAoX1Byb2Nlc3NpbmdOb2RlKSB7XG4gICAgX2luaGVyaXRzKENvbXBvc2l0aW5nTm9kZSwgX1Byb2Nlc3NpbmdOb2RlKTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpc2UgYW4gaW5zdGFuY2Ugb2YgYSBDb21wb3NpdGluZyBOb2RlLiBZb3Ugc2hvdWxkIG5vdCBpbnN0YW50aWF0ZSB0aGlzIGRpcmVjdGx5LCBidXQgdXNlIFZpZGVvQ29udGVzdC5jcmVhdGVDb21wb3NpdGluZ05vZGUoKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21wb3NpdGluZ05vZGUoZ2wsIHJlbmRlckdyYXBoLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wb3NpdGluZ05vZGUpO1xuXG4gICAgICAgIHZhciBwbGFjZWhvbGRlclRleHR1cmUgPSAoMCwgX3V0aWxzLmNyZWF0ZUVsZW1lbnRUZXh0dXJlKShnbCk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDBdKSk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvbXBvc2l0aW5nTm9kZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbXBvc2l0aW5nTm9kZSkpLmNhbGwodGhpcywgZ2wsIHJlbmRlckdyYXBoLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uLmlucHV0cywgZmFsc2UpKTtcblxuICAgICAgICBfdGhpcy5fcGxhY2Vob2xkZXJUZXh0dXJlID0gcGxhY2Vob2xkZXJUZXh0dXJlO1xuICAgICAgICBfdGhpcy5fZGlzcGxheU5hbWUgPSBUWVBFO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENvbXBvc2l0aW5nTm9kZSwgW3tcbiAgICAgICAga2V5OiBcIl9yZW5kZXJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5fZ2w7XG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSwgMCk7XG4gICAgICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApOyAvLyBncmVlbjtcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXG4gICAgICAgICAgICB0aGlzLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIF9nZXQoQ29tcG9zaXRpbmdOb2RlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbXBvc2l0aW5nTm9kZS5wcm90b3R5cGUpLCBcIl9yZW5kZXJcIiwgX3RoaXMyKS5jYWxsKF90aGlzMik7XG5cbiAgICAgICAgICAgICAgICAvL21hcCB0aGUgaW5wdXQgdGV4dHVyZXMgaW5wdXQgdGhlIG5vZGVcbiAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZSA9IG5vZGUuX3RleHR1cmU7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX3RoaXMyLl9zaGFkZXJJbnB1dHNUZXh0dXJlVW5pdE1hcHBpbmdbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFwcGluZyA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKG1hcHBpbmcudGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKG1hcHBpbmcubG9jYXRpb24sIG1hcHBpbmcudGV4dHVyZVVuaXRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDYpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29tcG9zaXRpbmdOb2RlO1xufShfcHJvY2Vzc2luZ25vZGUyLmRlZmF1bHQpO1xuXG5leHBvcnRzLkNPTVBPU0lUSU5HVFlQRSA9IFRZUEU7XG5leHBvcnRzLmRlZmF1bHQgPSBDb21wb3NpdGluZ05vZGU7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL1Byb2Nlc3NpbmdOb2Rlcy9lZmZlY3Rub2RlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL1Byb2Nlc3NpbmdOb2Rlcy9lZmZlY3Rub2RlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRUZGRUNUWVBFID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcHJvY2Vzc2luZ25vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Byb2Nlc3Npbmdub2RlICovIFwiLi9zcmMvUHJvY2Vzc2luZ05vZGVzL3Byb2Nlc3Npbmdub2RlLmpzXCIpO1xuXG52YXIgX3Byb2Nlc3Npbmdub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb2Nlc3Npbmdub2RlKTtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLy9NYXR0aGV3IFNob3R0b24sIFImRCBVc2VyIEV4cGVyaWVuY2UswqkgQkJDIDIwMTVcblxuXG52YXIgVFlQRSA9IFwiRWZmZWN0Tm9kZVwiO1xuXG52YXIgRWZmZWN0Tm9kZSA9IGZ1bmN0aW9uIChfUHJvY2Vzc2luZ05vZGUpIHtcbiAgICBfaW5oZXJpdHMoRWZmZWN0Tm9kZSwgX1Byb2Nlc3NpbmdOb2RlKTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpc2UgYW4gaW5zdGFuY2Ugb2YgYW4gRWZmZWN0Tm9kZS4gWW91IHNob3VsZCBub3QgaW5zdGFudGlhdGUgdGhpcyBkaXJlY3RseSwgYnV0IHVzZSBWaWRlb0NvbnRlc3QuY3JlYXRlRWZmZWN0Tm9kZSgpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVmZmVjdE5vZGUoZ2wsIHJlbmRlckdyYXBoLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZmZlY3ROb2RlKTtcblxuICAgICAgICB2YXIgcGxhY2Vob2xkZXJUZXh0dXJlID0gKDAsIF91dGlscy5jcmVhdGVFbGVtZW50VGV4dHVyZSkoZ2wpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAwXSkpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChFZmZlY3ROb2RlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRWZmZWN0Tm9kZSkpLmNhbGwodGhpcywgZ2wsIHJlbmRlckdyYXBoLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uLmlucHV0cywgdHJ1ZSkpO1xuXG4gICAgICAgIF90aGlzLl9wbGFjZWhvbGRlclRleHR1cmUgPSBwbGFjZWhvbGRlclRleHR1cmU7XG4gICAgICAgIF90aGlzLl9kaXNwbGF5TmFtZSA9IFRZUEU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRWZmZWN0Tm9kZSwgW3tcbiAgICAgICAga2V5OiBcIl9yZW5kZXJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXIoKSB7XG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5fZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlLCAwKTtcbiAgICAgICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7IC8vIGdyZWVuO1xuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5aRVJPKTtcblxuICAgICAgICAgICAgX2dldChFZmZlY3ROb2RlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEVmZmVjdE5vZGUucHJvdG90eXBlKSwgXCJfcmVuZGVyXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBpbnB1dHMgPSB0aGlzLl9yZW5kZXJHcmFwaC5nZXRJbnB1dHNGb3JOb2RlKHRoaXMpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NoYWRlcklucHV0c1RleHR1cmVVbml0TWFwcGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dFRleHR1cmUgPSB0aGlzLl9wbGFjZWhvbGRlclRleHR1cmU7XG4gICAgICAgICAgICAgICAgdmFyIHRleHR1cmVVbml0ID0gdGhpcy5fc2hhZGVySW5wdXRzVGV4dHVyZVVuaXRNYXBwaW5nW2ldLnRleHR1cmVVbml0O1xuICAgICAgICAgICAgICAgIGlmIChpIDwgaW5wdXRzLmxlbmd0aCAmJiBpbnB1dHNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dFRleHR1cmUgPSBpbnB1dHNbaV0uX3RleHR1cmU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHRoaXMuX3NoYWRlcklucHV0c1RleHR1cmVVbml0TWFwcGluZ1tpXS5sb2NhdGlvbiwgdGhpcy5fc2hhZGVySW5wdXRzVGV4dHVyZVVuaXRNYXBwaW5nW2ldLnRleHR1cmVVbml0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGlucHV0VGV4dHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgNik7XG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEVmZmVjdE5vZGU7XG59KF9wcm9jZXNzaW5nbm9kZTIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuRUZGRUNUWVBFID0gVFlQRTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVmZmVjdE5vZGU7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL1Byb2Nlc3NpbmdOb2Rlcy9wcm9jZXNzaW5nbm9kZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvUHJvY2Vzc2luZ05vZGVzL3Byb2Nlc3Npbmdub2RlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlBST0NFU1NJTkdUWVBFID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfZ3JhcGhub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZ3JhcGhub2RlICovIFwiLi9zcmMvZ3JhcGhub2RlLmpzXCIpO1xuXG52YXIgX2dyYXBobm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncmFwaG5vZGUpO1xuXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMuanMgKi8gXCIuL3NyYy91dGlscy5qc1wiKTtcblxudmFyIF9leGNlcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXhjZXB0aW9ucy5qcyAqLyBcIi4vc3JjL2V4Y2VwdGlvbnMuanNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLy9NYXR0aGV3IFNob3R0b24sIFImRCBVc2VyIEV4cGVyaWVuY2UswqkgQkJDIDIwMTVcblxuXG52YXIgVFlQRSA9IFwiUHJvY2Vzc2luZ05vZGVcIjtcblxudmFyIFByb2Nlc3NpbmdOb2RlID0gZnVuY3Rpb24gKF9HcmFwaE5vZGUpIHtcbiAgICBfaW5oZXJpdHMoUHJvY2Vzc2luZ05vZGUsIF9HcmFwaE5vZGUpO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSBhbiBpbnN0YW5jZSBvZiBhIFByb2Nlc3NpbmdOb2RlLlxuICAgICAqXG4gICAgICogVGhpcyBjbGFzcyBpcyBub3QgdXNlZCBkaXJlY3RseSwgYnV0IGlzIGV4dGVuZGVkIHRvIGNyZWF0ZSBDb21wb3NpdGluZ05vZGVzLCBUcmFuc2l0aW9uTm9kZXMsIGFuZCBFZmZlY3ROb2Rlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcm9jZXNzaW5nTm9kZShnbCwgcmVuZGVyR3JhcGgsIGRlZmluaXRpb24sIGlucHV0TmFtZXMsIGxpbWl0Q29ubmVjdGlvbnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb2Nlc3NpbmdOb2RlKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUHJvY2Vzc2luZ05vZGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQcm9jZXNzaW5nTm9kZSkpLmNhbGwodGhpcywgZ2wsIHJlbmRlckdyYXBoLCBpbnB1dE5hbWVzLCBsaW1pdENvbm5lY3Rpb25zKSk7XG5cbiAgICAgICAgX3RoaXMuX3ZlcnRleFNoYWRlciA9ICgwLCBfdXRpbHMuY29tcGlsZVNoYWRlcikoZ2wsIGRlZmluaXRpb24udmVydGV4U2hhZGVyLCBnbC5WRVJURVhfU0hBREVSKTtcbiAgICAgICAgX3RoaXMuX2ZyYWdtZW50U2hhZGVyID0gKDAsIF91dGlscy5jb21waWxlU2hhZGVyKShnbCwgZGVmaW5pdGlvbi5mcmFnbWVudFNoYWRlciwgZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICAgICAgX3RoaXMuX2RlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuICAgICAgICBfdGhpcy5fcHJvcGVydGllcyA9IHt9OyAvL2RlZmluaXRpb24ucHJvcGVydGllcztcbiAgICAgICAgLy9jb3B5IGRlZmluaXRpb24gcHJvcGVydGllc1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gZGVmaW5pdGlvbi5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHlWYWx1ZSA9IGRlZmluaXRpb24ucHJvcGVydGllc1twcm9wZXJ0eU5hbWVdLnZhbHVlO1xuICAgICAgICAgICAgLy9pZiBhbiBhcnJheSB0aGVuIHNoYWxsb3cgY29weSBpdFxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9wZXJ0eVZhbHVlKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9IGRlZmluaXRpb24ucHJvcGVydGllc1twcm9wZXJ0eU5hbWVdLnZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvcGVydHlUeXBlID0gZGVmaW5pdGlvbi5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0udHlwZTtcbiAgICAgICAgICAgIF90aGlzLl9wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcHJvcGVydHlUeXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9wZXJ0eVZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX3NoYWRlcklucHV0c1RleHR1cmVVbml0TWFwcGluZyA9IFtdO1xuICAgICAgICBfdGhpcy5fbWF4VGV4dHVyZVVuaXRzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcbiAgICAgICAgX3RoaXMuX2JvdW5kVGV4dHVyZVVuaXRzID0gMDtcbiAgICAgICAgX3RoaXMuX3RleHR1cmUgPSAoMCwgX3V0aWxzLmNyZWF0ZUVsZW1lbnRUZXh0dXJlKShnbCk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAgICAgLy9jb21waWxlIHRoZSBzaGFkZXJcbiAgICAgICAgX3RoaXMuX3Byb2dyYW0gPSAoMCwgX3V0aWxzLmNyZWF0ZVNoYWRlclByb2dyYW0pKGdsLCBfdGhpcy5fdmVydGV4U2hhZGVyLCBfdGhpcy5fZnJhZ21lbnRTaGFkZXIpO1xuXG4gICAgICAgIC8vY3JlYXRlIGFuZCBzZXR1cCB0aGUgZnJhbWVidWZmZXJcbiAgICAgICAgX3RoaXMuX2ZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBfdGhpcy5fZnJhbWVidWZmZXIpO1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIF90aGlzLl90ZXh0dXJlLCAwKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuICAgICAgICAvL2NyZWF0ZSBwcm9wZXJ0aWVzIG9uIHRoaXMgb2JqZWN0IGZvciB0aGUgcGFzc2VkIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIF9wcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXNbX3Byb3BlcnR5TmFtZV0udmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChwYXNzZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzW19wcm9wZXJ0eU5hbWVdLnZhbHVlID0gcGFzc2VkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgX3Byb3BlcnR5TmFtZSBpbiBfdGhpcy5fcHJvcGVydGllcykge1xuICAgICAgICAgICAgX2xvb3AoX3Byb3BlcnR5TmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NyZWF0ZSB0ZXh1dHJlcyBmb3IgYW55IHRleHR1cmUgcHJvcGVydGllc1xuICAgICAgICBmb3IgKHZhciBfcHJvcGVydHlOYW1lMiBpbiBfdGhpcy5fcHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIF9wcm9wZXJ0eVZhbHVlID0gX3RoaXMuX3Byb3BlcnRpZXNbX3Byb3BlcnR5TmFtZTJdLnZhbHVlO1xuICAgICAgICAgICAgaWYgKF9wcm9wZXJ0eVZhbHVlIGluc3RhbmNlb2YgSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHJvcGVydGllc1tfcHJvcGVydHlOYW1lMl0udGV4dHVyZSA9ICgwLCBfdXRpbHMuY3JlYXRlRWxlbWVudFRleHR1cmUpKGdsKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHJvcGVydGllc1tfcHJvcGVydHlOYW1lMl0udGV4dHVyZVVuaXQgPSBnbC5URVhUVVJFMCArIF90aGlzLl9ib3VuZFRleHR1cmVVbml0cztcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHJvcGVydGllc1tfcHJvcGVydHlOYW1lMl0udGV4dHVyZVVuaXRJbmRleCA9IF90aGlzLl9ib3VuZFRleHR1cmVVbml0cztcbiAgICAgICAgICAgICAgICBfdGhpcy5fYm91bmRUZXh0dXJlVW5pdHMgKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2JvdW5kVGV4dHVyZVVuaXRzID4gX3RoaXMuX21heFRleHR1cmVVbml0cykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbnMuUmVuZGVyRXhjZXB0aW9uKFwiVHJ5aW5nIHRvIGJpbmQgbW9yZSB0aGFuIGF2YWlsYWJsZSB0ZXh0dXJlcyB1bml0cyB0byBzaGFkZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRleHR1cmUgdW5pdHMgZm9yIGlucHV0IHRleHR1cmVzXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZGVmaW5pdGlvbi5pbnB1dHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0TmFtZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NoYWRlcklucHV0c1RleHR1cmVVbml0TWFwcGluZy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaW5wdXROYW1lLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlVW5pdDogZ2wuVEVYVFVSRTAgKyBfdGhpcy5fYm91bmRUZXh0dXJlVW5pdHMsXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVVbml0SW5kZXg6IF90aGlzLl9ib3VuZFRleHR1cmVVbml0cyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihfdGhpcy5fcHJvZ3JhbSwgaW5wdXROYW1lKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLl9ib3VuZFRleHR1cmVVbml0cyArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fYm91bmRUZXh0dXJlVW5pdHMgPiBfdGhpcy5fbWF4VGV4dHVyZVVuaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9ucy5SZW5kZXJFeGNlcHRpb24oXCJUcnlpbmcgdG8gYmluZCBtb3JlIHRoYW4gYXZhaWxhYmxlIHRleHR1cmVzIHVuaXRzIHRvIHNoYWRlclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZmluZCB0aGUgbG9jYXRpb25zIG9mIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBjb21waWxlZCBzaGFkZXJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9wcm9wZXJ0eU5hbWUzIGluIF90aGlzLl9wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3Byb3BlcnRpZXNbX3Byb3BlcnR5TmFtZTNdLnR5cGUgPT09IFwidW5pZm9ybVwiKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Byb3BlcnRpZXNbX3Byb3BlcnR5TmFtZTNdLmxvY2F0aW9uID0gX3RoaXMuX2dsLmdldFVuaWZvcm1Mb2NhdGlvbihfdGhpcy5fcHJvZ3JhbSwgX3Byb3BlcnR5TmFtZTMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9jdXJyZW50VGltZUxvY2F0aW9uID0gX3RoaXMuX2dsLmdldFVuaWZvcm1Mb2NhdGlvbihfdGhpcy5fcHJvZ3JhbSwgXCJjdXJyZW50VGltZVwiKTtcbiAgICAgICAgX3RoaXMuX2N1cnJlbnRUaW1lID0gMDtcblxuICAgICAgICAvL090aGVyIHNldHVwXG4gICAgICAgIHZhciBwb3NpdGlvbkxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oX3RoaXMuX3Byb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoWzEuMCwgMS4wLCAwLjAsIDEuMCwgMS4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICB2YXIgdGV4Q29vcmRMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKF90aGlzLl9wcm9ncmFtLCBcImFfdGV4Q29vcmRcIik7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRleENvb3JkTG9jYXRpb24pO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRleENvb3JkTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgIF90aGlzLl9kaXNwbGF5TmFtZSA9IFRZUEU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwYXNzZWQgcHJvY2Vzc2luZyBub2RlIHByb3BlcnR5IHRvIHRoZSBwYXNzZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvY2Vzc2luZyBub2RlIHBhcmFtZXRlciB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldCBpdCB0by5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGN0eCA9IG5ldyBWaWRlb0NvbnRleHQoKTtcbiAgICAgKiB2YXIgbW9ub05vZGUgPSBjdHguZWZmZWN0KFZpZGVvQ29udGV4dC5ERUZJTklUSU9OUy5NT05PQ0hST01FKTtcbiAgICAgKiBtb25vTm9kZS5zZXRQcm9wZXJ0eShcImlucHV0TWl4XCIsIFsxLjAsMC4wLDAuMF0pOyAvL0p1c3QgdXNlIHJlZCBjaGFubmVsXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhQcm9jZXNzaW5nTm9kZSwgW3tcbiAgICAgICAga2V5OiBcInNldFByb3BlcnR5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllc1tuYW1lXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHBhc3NlZCBwcm9jZXNzaW5nIG5vZGUgcHJvcGVydHkgdG8gdGhlIHBhc3NlZCB2YWx1ZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvY2Vzc2luZyBub2RlIHBhcmFtZXRlciB0byBnZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBjdHggPSBuZXcgVmlkZW9Db250ZXh0KCk7XG4gICAgICAgICAqIHZhciBtb25vTm9kZSA9IGN0eC5lZmZlY3QoVmlkZW9Db250ZXh0LkRFRklOSVRJT05TLk1PTk9DSFJPTUUpO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhtb25vTm9kZS5nZXRQcm9wZXJ0eShcImlucHV0TWl4XCIpKTsgLy9XaWxsIG91dHB1dCBbMC40LDAuNiwwLjJdLCB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBlZmZlY3QgZGVmaW5pdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRQcm9wZXJ0eVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvcGVydHkobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXNbbmFtZV0udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveSBhbmQgY2xlYW4tdXAgdGhlIG5vZGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIF9nZXQoUHJvY2Vzc2luZ05vZGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUHJvY2Vzc2luZ05vZGUucHJvdG90eXBlKSwgXCJkZXN0cm95XCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvL2Rlc3RycHkgdGV4dXRyZXMgZm9yIGFueSB0ZXh0dXJlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiB0aGlzLl9wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSB0aGlzLl9wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0udmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5VmFsdWUgaW5zdGFuY2VvZiBJbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbC5kZWxldGVUZXh0dXJlKHRoaXMuX3Byb3BlcnRpZXNbcHJvcGVydHlOYW1lXS50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL0Rlc3Ryb3kgbWFpblxuICAgICAgICAgICAgdGhpcy5fZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLl90ZXh0dXJlKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvL0RldGFjaCBzaGFkZXJzXG4gICAgICAgICAgICB0aGlzLl9nbC5kZXRhY2hTaGFkZXIodGhpcy5fcHJvZ3JhbSwgdGhpcy5fdmVydGV4U2hhZGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2dsLmRldGFjaFNoYWRlcih0aGlzLl9wcm9ncmFtLCB0aGlzLl9mcmFnbWVudFNoYWRlcik7XG4gICAgICAgICAgICAvL0RlbGV0ZSBzaGFkZXJzXG4gICAgICAgICAgICB0aGlzLl9nbC5kZWxldGVTaGFkZXIodGhpcy5fdmVydGV4U2hhZGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2dsLmRlbGV0ZVNoYWRlcih0aGlzLl9mcmFnbWVudFNoYWRlcik7XG4gICAgICAgICAgICAvL0RlbGV0ZSBwcm9ncmFtXG4gICAgICAgICAgICB0aGlzLl9nbC5kZWxldGVQcm9ncmFtKHRoaXMuX3Byb2dyYW0pO1xuICAgICAgICAgICAgLy9EZWxldGUgRnJhbWVidWZmZXJcbiAgICAgICAgICAgIHRoaXMuX2dsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuX2ZyYW1lYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl91cGRhdGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUoY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfc2Vla1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NlZWsoY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfcmVuZGVyXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5fZ2w7XG4gICAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMuX3Byb2dyYW0pO1xuXG4gICAgICAgICAgICAvL3VwbG9hZCB0aGUgZGVmYXVsdCB1bmlmb3Jtc1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHRoaXMuX2N1cnJlbnRUaW1lTG9jYXRpb24sIHBhcnNlRmxvYXQodGhpcy5fY3VycmVudFRpbWUpKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHRoaXMuX3Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlWYWx1ZSA9IHRoaXMuX3Byb3BlcnRpZXNbcHJvcGVydHlOYW1lXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlUeXBlID0gdGhpcy5fcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5TG9jYXRpb24gPSB0aGlzLl9wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0ubG9jYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5VHlwZSAhPT0gXCJ1bmlmb3JtXCIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eVZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZihwcm9wZXJ0eUxvY2F0aW9uLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9wZXJ0eVZhbHVlKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmdihwcm9wZXJ0eUxvY2F0aW9uLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eVZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9wZXJ0eUxvY2F0aW9uLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eVZhbHVlLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdihwcm9wZXJ0eUxvY2F0aW9uLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eVZhbHVlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmdihwcm9wZXJ0eUxvY2F0aW9uLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJTaGFkZXIgcGFyYW1ldGVyXCIsIHByb3BlcnR5TmFtZSwgXCJpcyB0b28gbG9uZyBhbiBhcnJheTpcIiwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5VmFsdWUgaW5zdGFuY2VvZiBJbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3Byb3BlcnRpZXNbcHJvcGVydHlOYW1lXS50ZXh0dXJlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZVVuaXQgPSB0aGlzLl9wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0udGV4dHVyZVVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0dXJlVW5pdEluZGV4ID0gdGhpcy5fcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdLnRleHR1cmVVbml0O1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLnVwZGF0ZVRleHR1cmUpKGdsLCB0ZXh0dXJlLCBwcm9wZXJ0eVZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKHRleHR1cmVVbml0KTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHByb3BlcnR5TG9jYXRpb24sIHRleHR1cmVVbml0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gLSBhZGQgdGVzdHMgZm9yIHRleHR1cmVzXG4gICAgICAgICAgICAgICAgICAgIC8qZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkocGFyYW1ldGVyTG9jdGF0aW9uLCB0ZXh0dXJlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZXNbdGV4dHVyZU9mZnNldC0xXSk7Ki9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUHJvY2Vzc2luZ05vZGU7XG59KF9ncmFwaG5vZGUyLmRlZmF1bHQpO1xuXG5leHBvcnRzLlBST0NFU1NJTkdUWVBFID0gVFlQRTtcbmV4cG9ydHMuZGVmYXVsdCA9IFByb2Nlc3NpbmdOb2RlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9Qcm9jZXNzaW5nTm9kZXMvdHJhbnNpdGlvbm5vZGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL1Byb2Nlc3NpbmdOb2Rlcy90cmFuc2l0aW9ubm9kZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5UUkFOU0lUSU9OVFlQRSA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2VmZmVjdG5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VmZmVjdG5vZGUgKi8gXCIuL3NyYy9Qcm9jZXNzaW5nTm9kZXMvZWZmZWN0bm9kZS5qc1wiKTtcblxudmFyIF9lZmZlY3Rub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VmZmVjdG5vZGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8vTWF0dGhldyBTaG90dG9uLCBSJkQgVXNlciBFeHBlcmllbmNlLMKpIEJCQyAyMDE1XG5cblxudmFyIFRZUEUgPSBcIlRyYW5zaXRpb25Ob2RlXCI7XG5cbnZhciBUcmFuc2l0aW9uTm9kZSA9IGZ1bmN0aW9uIChfRWZmZWN0Tm9kZSkge1xuICAgIF9pbmhlcml0cyhUcmFuc2l0aW9uTm9kZSwgX0VmZmVjdE5vZGUpO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSBhbiBpbnN0YW5jZSBvZiBhIFRyYW5zaXRpb25Ob2RlLiBZb3Ugc2hvdWxkIG5vdCBpbnN0YW50aWF0ZSB0aGlzIGRpcmVjdGx5LCBidXQgdXNlIFZpZGVvQ29udGVzdC5jcmVhdGVUcmFuc2l0b25Ob2RlKCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbk5vZGUoZ2wsIHJlbmRlckdyYXBoLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2l0aW9uTm9kZSk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFRyYW5zaXRpb25Ob2RlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHJhbnNpdGlvbk5vZGUpKS5jYWxsKHRoaXMsIGdsLCByZW5kZXJHcmFwaCwgZGVmaW5pdGlvbikpO1xuXG4gICAgICAgIF90aGlzLl90cmFuc2l0aW9ucyA9IHt9O1xuXG4gICAgICAgIC8vc2F2ZSBhIHZlcnNpb24gb2YgdGhlIG9yaWdpbmFsIHByb3BlcnR5IHZhbHVlc1xuICAgICAgICBfdGhpcy5faW5pdGlhbFByb3BlcnR5VmFsdWVzID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBfdGhpcy5fcHJvcGVydGllcykge1xuICAgICAgICAgICAgX3RoaXMuX2luaXRpYWxQcm9wZXJ0eVZhbHVlc1twcm9wZXJ0eU5hbWVdID0gX3RoaXMuX3Byb3BlcnRpZXNbcHJvcGVydHlOYW1lXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5fZGlzcGxheU5hbWUgPSBUWVBFO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFRyYW5zaXRpb25Ob2RlLCBbe1xuICAgICAgICBrZXk6IFwiX2RvZXNUcmFuc2l0aW9uRml0T25UaW1lbGluZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RvZXNUcmFuc2l0aW9uRml0T25UaW1lbGluZSh0ZXN0VHJhbnNpdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zaXRpb25zW3Rlc3RUcmFuc2l0aW9uLnByb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRoaXMuX3RyYW5zaXRpb25zW3Rlc3RUcmFuc2l0aW9uLnByb3BlcnR5XVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGVzdFRyYW5zaXRpb24uc3RhcnQgPiB0cmFuc2l0aW9uLnN0YXJ0ICYmIHRlc3RUcmFuc2l0aW9uLnN0YXJ0IDwgdHJhbnNpdGlvbi5lbmQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlc3RUcmFuc2l0aW9uLmVuZCA+IHRyYW5zaXRpb24uc3RhcnQgJiYgdGVzdFRyYW5zaXRpb24uZW5kIDwgdHJhbnNpdGlvbi5lbmQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zaXRpb24uc3RhcnQgPiB0ZXN0VHJhbnNpdGlvbi5zdGFydCAmJiB0cmFuc2l0aW9uLnN0YXJ0IDwgdGVzdFRyYW5zaXRpb24uZW5kKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uLmVuZCA+IHRlc3RUcmFuc2l0aW9uLnN0YXJ0ICYmIHRyYW5zaXRpb24uZW5kIDwgdGVzdFRyYW5zaXRpb24uZW5kKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfaW5zZXJ0VHJhbnNpdGlvbkluVGltZWxpbmVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnNlcnRUcmFuc2l0aW9uSW5UaW1lbGluZSh0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNpdGlvbnNbdHJhbnNpdGlvbi5wcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkgdGhpcy5fdHJhbnNpdGlvbnNbdHJhbnNpdGlvbi5wcm9wZXJ0eV0gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25zW3RyYW5zaXRpb24ucHJvcGVydHldLnB1c2godHJhbnNpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25zW3RyYW5zaXRpb24ucHJvcGVydHldLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSB0cmFuc2l0aW9uIG9uIHRoZSB0aW1lbGluZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0VGltZSAtIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSB0cmFuc2l0aW9uIHNob3VsZCBzdGFydCAocmVsYXRpdmUgdG8gY3VycmVudFRpbWUgb2YgdmlkZW8gY29udGV4dCkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRUaW1lIC0gVGhlIHRpbWUgYXQgd2hpY2ggdGhlIHRyYW5zaXRpb24gc2hvdWxkIGJlIGNvbXBsZXRlZCBieSAocmVsYXRpdmUgdG8gY3VycmVudFRpbWUgb2YgdmlkZW8gY29udGV4dCkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50VmFsdWUgLSBUaGUgdmFsdWUgdG8gc3RhcnQgdGhlIHRyYW5zaXRpb24gYXQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRWYWx1ZSAtIFRoZSB2YWx1ZSB0byB0cmFuc2l0aW9uIHRvIGJ5IGVuZFRpbWUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2xlYXIgdHJhbnNpdGlvbnMgb24sIGlmIHVuZGVmaW5lZCBkZWZhdWx0IHRvIFwibWl4XCIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHJldHVybnMgVHJ1ZSBpZiBhIHRyYW5zaXRpb24gaXMgc3VjY2Vzc2Z1bGx5IGFkZGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwidHJhbnNpdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNpdGlvbihzdGFydFRpbWUsIGVuZFRpbWUsIGN1cnJlbnRWYWx1ZSwgdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFwibWl4XCI7XG5cbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydFRpbWUgKyB0aGlzLl9jdXJyZW50VGltZSxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZFRpbWUgKyB0aGlzLl9jdXJyZW50VGltZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRWYWx1ZSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHlOYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kb2VzVHJhbnNpdGlvbkZpdE9uVGltZWxpbmUodHJhbnNpdGlvbikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2luc2VydFRyYW5zaXRpb25JblRpbWVsaW5lKHRyYW5zaXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgdHJhbnNpdGlvbiBvbiB0aGUgdGltZWxpbmUgYXQgYW4gYWJzb2x1dGUgdGltZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0VGltZSAtIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSB0cmFuc2l0aW9uIHNob3VsZCBzdGFydCAocmVsYXRpdmUgdG8gdGltZSAwKS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFRpbWUgLSBUaGUgdGltZSBhdCB3aGljaCB0aGUgdHJhbnNpdGlvbiBzaG91bGQgYmUgY29tcGxldGVkIGJ5IChyZWxhdGl2ZSB0byB0aW1lIDApLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFZhbHVlIC0gVGhlIHZhbHVlIHRvIHN0YXJ0IHRoZSB0cmFuc2l0aW9uIGF0LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0VmFsdWUgLSBUaGUgdmFsdWUgdG8gdHJhbnNpdGlvbiB0byBieSBlbmRUaW1lLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNsZWFyIHRyYW5zaXRpb25zIG9uLCBpZiB1bmRlZmluZWQgZGVmYXVsdCB0byBcIm1peFwiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSByZXR1cm5zIFRydWUgaWYgYSB0cmFuc2l0aW9uIGlzIHN1Y2Nlc3NmdWxseSBhZGRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInRyYW5zaXRpb25BdFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNpdGlvbkF0KHN0YXJ0VGltZSwgZW5kVGltZSwgY3VycmVudFZhbHVlLCB0YXJnZXRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogXCJtaXhcIjtcblxuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgY3VycmVudDogY3VycmVudFZhbHVlLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0VmFsdWUsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5TmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZG9lc1RyYW5zaXRpb25GaXRPblRpbWVsaW5lKHRyYW5zaXRpb24pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRUcmFuc2l0aW9uSW5UaW1lbGluZSh0cmFuc2l0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFyIGFsbCB0cmFuc2lzdGlvbnMgb24gdGhlIHBhc3NlZCBwcm9wZXJ0eS4gSWYgbm8gcHJvcGVydHkgaXMgZGVmaW5lZCBjbGVhciBhbGwgdHJhbnNpdGlvbnMgb24gdGhlIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2xlYXIgdHJhbnNpdGlvbnMgb24sIGlmIHVuZGVmaW5lZCBjbGVhciBhbGwgdHJhbnNpdGlvbnMgb24gdGhlIG5vZGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY2xlYXJUcmFuc2l0aW9uc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJUcmFuc2l0aW9ucyhwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25zID0ge307XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25zW3Byb3BlcnR5TmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciBhIHRyYW5zaXN0aW9uIG9uIHRoZSBwYXNzZWQgcHJvcGVydHkgdGhhdCB0aGUgc3BlY2lmaWVkIHRpbWUgbGllcyB3aXRoaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2xlYXIgYSB0cmFuc2l0aW9uIG9uLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSAtIEEgdGltZSB3aGljaCBsaWVzIHdpdGhpbiB0aGUgcHJvcGVydHkgeW91J3JlIHRyeWluZyB0byBjbGVhci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gcmV0dXJucyBUcnVlIGlmIGEgdHJhbnNpdGlvbiBpcyByZW1vdmVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY2xlYXJUcmFuc2l0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclRyYW5zaXRpb24ocHJvcGVydHlOYW1lLCB0aW1lKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbkluZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90cmFuc2l0aW9uc1twcm9wZXJ0eU5hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLl90cmFuc2l0aW9uc1twcm9wZXJ0eU5hbWVdW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lID4gdHJhbnNpdGlvbi5zdGFydCAmJiB0aW1lIDwgdHJhbnNpdGlvbi5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbkluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNpdGlvbkluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uc1twcm9wZXJ0eU5hbWVdLnNwbGljZSh0cmFuc2l0aW9uSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZShjdXJyZW50VGltZSkge1xuICAgICAgICAgICAgX2dldChUcmFuc2l0aW9uTm9kZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUcmFuc2l0aW9uTm9kZS5wcm90b3R5cGUpLCBcIl91cGRhdGVcIiwgdGhpcykuY2FsbCh0aGlzLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gdGhpcy5fdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zaXRpb25zW3Byb3BlcnR5TmFtZV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3RyYW5zaXRpb25zW3Byb3BlcnR5TmFtZV1bMF0uY3VycmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25BY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdHJhbnNpdGlvbnNbcHJvcGVydHlOYW1lXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zaXRpb25zW3Byb3BlcnR5TmFtZV1baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA+IHRyYW5zaXRpb24uZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRyYW5zaXRpb24udGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPiB0cmFuc2l0aW9uLnN0YXJ0ICYmIGN1cnJlbnRUaW1lIDwgdHJhbnNpdGlvbi5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWZmZXJlbmNlID0gdHJhbnNpdGlvbi50YXJnZXQgLSB0cmFuc2l0aW9uLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSAodGhpcy5fY3VycmVudFRpbWUgLSB0cmFuc2l0aW9uLnN0YXJ0KSAvICh0cmFuc2l0aW9uLmVuZCAtIHRyYW5zaXRpb24uc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbkFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSB0cmFuc2l0aW9uLmN1cnJlbnQgKyBkaWZmZXJlbmNlICogcHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdHJhbnNpdGlvbkFjdGl2ZSkgdGhpc1twcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVHJhbnNpdGlvbk5vZGU7XG59KF9lZmZlY3Rub2RlMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5UUkFOU0lUSU9OVFlQRSA9IFRZUEU7XG5leHBvcnRzLmRlZmF1bHQgPSBUcmFuc2l0aW9uTm9kZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvU291cmNlTm9kZXMvYXVkaW9ub2RlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9Tb3VyY2VOb2Rlcy9hdWRpb25vZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQVVESU9UWVBFID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfbWVkaWFub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZWRpYW5vZGUgKi8gXCIuL3NyYy9Tb3VyY2VOb2Rlcy9tZWRpYW5vZGUuanNcIik7XG5cbnZhciBfbWVkaWFub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lZGlhbm9kZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLy9NYXR0aGV3IFNob3R0b24sIFImRCBVc2VyIEV4cGVyaWVuY2UswqkgQkJDIDIwMTVcblxuXG52YXIgVFlQRSA9IFwiQXVkaW9Ob2RlXCI7XG5cbnZhciBBdWRpb05vZGUgPSBmdW5jdGlvbiAoX01lZGlhTm9kZSkge1xuICAgIF9pbmhlcml0cyhBdWRpb05vZGUsIF9NZWRpYU5vZGUpO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSBhbiBpbnN0YW5jZSBvZiBhbiBBdWRpb05vZGUuXG4gICAgICogVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseSwgYnV0IGNyZWF0ZWQgdGhyb3VnaCBhIGNhbGwgdG8gdmlkZW9Db250ZXh0LmF1ZGlvKCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gQXVkaW9Ob2RlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9Ob2RlKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQXVkaW9Ob2RlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQXVkaW9Ob2RlKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICAgICAgX3RoaXMuX2Rpc3BsYXlOYW1lID0gVFlQRTtcbiAgICAgICAgX3RoaXMuX2VsZW1lbnRUeXBlID0gXCJhdWRpb1wiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEF1ZGlvTm9kZSwgW3tcbiAgICAgICAga2V5OiBcIl91cGRhdGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUoY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgIF9nZXQoQXVkaW9Ob2RlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEF1ZGlvTm9kZS5wcm90b3R5cGUpLCBcIl91cGRhdGVcIiwgdGhpcykuY2FsbCh0aGlzLCBjdXJyZW50VGltZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEF1ZGlvTm9kZTtcbn0oX21lZGlhbm9kZTIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuQVVESU9UWVBFID0gVFlQRTtcbmV4cG9ydHMuZGVmYXVsdCA9IEF1ZGlvTm9kZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvU291cmNlTm9kZXMvY2FudmFzbm9kZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL1NvdXJjZU5vZGVzL2NhbnZhc25vZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNBTlZBU1RZUEUgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9zb3VyY2Vub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zb3VyY2Vub2RlICovIFwiLi9zcmMvU291cmNlTm9kZXMvc291cmNlbm9kZS5qc1wiKTtcblxudmFyIF9zb3VyY2Vub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NvdXJjZW5vZGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8vTWF0dGhldyBTaG90dG9uLCBSJkQgVXNlciBFeHBlcmllbmNlLMKpIEJCQyAyMDE1XG5cblxudmFyIFRZUEUgPSBcIkNhbnZhc05vZGVcIjtcblxudmFyIENhbnZhc05vZGUgPSBmdW5jdGlvbiAoX1NvdXJjZU5vZGUpIHtcbiAgICBfaW5oZXJpdHMoQ2FudmFzTm9kZSwgX1NvdXJjZU5vZGUpO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSBhbiBpbnN0YW5jZSBvZiBhIENhbnZhc05vZGUuXG4gICAgICogVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseSwgYnV0IGNyZWF0ZWQgdGhyb3VnaCBhIGNhbGwgdG8gdmlkZW9Db250ZXh0LmNyZWF0ZUNhbnZhc05vZGUoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDYW52YXNOb2RlKGNhbnZhcywgZ2wsIHJlbmRlckdyYXBoLCBjdXJyZW50VGltZSkge1xuICAgICAgICB2YXIgcHJlbG9hZFRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDQ7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhc05vZGUpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDYW52YXNOb2RlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2FudmFzTm9kZSkpLmNhbGwodGhpcywgY2FudmFzLCBnbCwgcmVuZGVyR3JhcGgsIGN1cnJlbnRUaW1lKSk7XG5cbiAgICAgICAgX3RoaXMuX3ByZWxvYWRUaW1lID0gcHJlbG9hZFRpbWU7XG4gICAgICAgIF90aGlzLl9kaXNwbGF5TmFtZSA9IFRZUEU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2FudmFzTm9kZSwgW3tcbiAgICAgICAga2V5OiBcIl9sb2FkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZCgpIHtcbiAgICAgICAgICAgIF9nZXQoQ2FudmFzTm9kZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDYW52YXNOb2RlLnByb3RvdHlwZSksIFwiX2xvYWRcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJDYWxsYmFja3MoXCJsb2FkZWRcIik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfdW5sb2FkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5sb2FkKCkge1xuICAgICAgICAgICAgX2dldChDYW52YXNOb2RlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENhbnZhc05vZGUucHJvdG90eXBlKSwgXCJfdW5sb2FkXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiX3NlZWtcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZWVrKHRpbWUpIHtcbiAgICAgICAgICAgIF9nZXQoQ2FudmFzTm9kZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDYW52YXNOb2RlLnByb3RvdHlwZSksIFwiX3NlZWtcIiwgdGhpcykuY2FsbCh0aGlzLCB0aW1lKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUucGxheWluZyB8fCB0aGlzLnN0YXRlID09PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgPT09IHVuZGVmaW5lZCkgdGhpcy5fbG9hZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuX3N0YXRlID09PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUuc2VxdWVuY2VkIHx8IHRoaXMuX3N0YXRlID09PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUuZW5kZWQpICYmIHRoaXMuX2VsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZShjdXJyZW50VGltZSkge1xuICAgICAgICAgICAgLy9pZiAoIXN1cGVyLl91cGRhdGUoY3VycmVudFRpbWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBfZ2V0KENhbnZhc05vZGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2FudmFzTm9kZS5wcm90b3R5cGUpLCBcIl91cGRhdGVcIiwgdGhpcykuY2FsbCh0aGlzLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fY3VycmVudFRpbWUgPD0gdGhpcy5fcHJlbG9hZFRpbWUgJiYgdGhpcy5fc3RhdGUgIT09IF9zb3VyY2Vub2RlLlNPVVJDRU5PREVTVEFURS53YWl0aW5nICYmIHRoaXMuX3N0YXRlICE9PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUuZW5kZWQpIHRoaXMuX2xvYWQoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUucGxheWluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFLmVuZGVkICYmIHRoaXMuX2VsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubG9hZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDYW52YXNOb2RlO1xufShfc291cmNlbm9kZTIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuQ0FOVkFTVFlQRSA9IFRZUEU7XG5leHBvcnRzLmRlZmF1bHQgPSBDYW52YXNOb2RlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9Tb3VyY2VOb2Rlcy9pbWFnZW5vZGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL1NvdXJjZU5vZGVzL2ltYWdlbm9kZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5JTUFHRVRZUEUgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9zb3VyY2Vub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zb3VyY2Vub2RlICovIFwiLi9zcmMvU291cmNlTm9kZXMvc291cmNlbm9kZS5qc1wiKTtcblxudmFyIF9zb3VyY2Vub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NvdXJjZW5vZGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8vTWF0dGhldyBTaG90dG9uLCBSJkQgVXNlciBFeHBlcmllbmNlLMKpIEJCQyAyMDE1XG5cblxudmFyIFRZUEUgPSBcIkNhbnZhc05vZGVcIjtcblxudmFyIEltYWdlTm9kZSA9IGZ1bmN0aW9uIChfU291cmNlTm9kZSkge1xuICAgIF9pbmhlcml0cyhJbWFnZU5vZGUsIF9Tb3VyY2VOb2RlKTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpc2UgYW4gaW5zdGFuY2Ugb2YgYW4gSW1hZ2VOb2RlLlxuICAgICAqIFRoaXMgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHksIGJ1dCBjcmVhdGVkIHRocm91Z2ggYSBjYWxsIHRvIHZpZGVvQ29udGV4dC5jcmVhdGVJbWFnZU5vZGUoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbWFnZU5vZGUoc3JjLCBnbCwgcmVuZGVyR3JhcGgsIGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIHZhciBwcmVsb2FkVGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogNDtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZU5vZGUpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChJbWFnZU5vZGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbWFnZU5vZGUpKS5jYWxsKHRoaXMsIHNyYywgZ2wsIHJlbmRlckdyYXBoLCBjdXJyZW50VGltZSkpO1xuXG4gICAgICAgIF90aGlzLl9wcmVsb2FkVGltZSA9IHByZWxvYWRUaW1lO1xuICAgICAgICBfdGhpcy5fYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIF90aGlzLl90ZXh0dXJlVXBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2Rpc3BsYXlOYW1lID0gVFlQRTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhJbWFnZU5vZGUsIFt7XG4gICAgICAgIGtleTogXCJfbG9hZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWQoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2ltYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZVtrZXldID0gdGhpcy5fYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faXNSZXNwb25zaWJsZUZvckVsZW1lbnRMaWZlQ3ljbGUpIHtcbiAgICAgICAgICAgICAgICBfZ2V0KEltYWdlTm9kZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbWFnZU5vZGUucHJvdG90eXBlKSwgXCJfbG9hZFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW1hZ2Uuc2V0QXR0cmlidXRlKFwiY3Jvc3NvcmlnaW5cIiwgXCJhbm9ueW1vdXNcIik7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gc2V0IHRoZSBgb25sb2FkYCBldmVudCBiZWZvcmUgdGhlIGBzcmNgIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTIzNTQ4NjUvaW1hZ2Utb25sb2FkLWV2ZW50LWFuZC1icm93c2VyLWNhY2hlP2Fuc3dlcnRhYj1hY3RpdmUjdGFiLXRvcFxuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLl9yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jcmVhdGVJbWFnZUJpdG1hcChfdGhpczIuX2ltYWdlLCB7IGltYWdlT3JpZW50YXRpb246IFwiZmxpcFlcIiB9KS50aGVuKGZ1bmN0aW9uIChpbWFnZUJpdG1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5fZWxlbWVudCA9IGltYWdlQml0bWFwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5fdHJpZ2dlckNhbGxiYWNrcyhcImxvYWRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyLl9lbGVtZW50ID0gX3RoaXMyLl9pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5fdHJpZ2dlckNhbGxiYWNrcyhcImxvYWRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5faW1hZ2Uuc3JjID0gdGhpcy5fZWxlbWVudFVSTDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW1hZ2VOb2RlIGZhaWxlZCB0byBsb2FkLiB1cmw6XCIsIF90aGlzMi5fZWxlbWVudFVSTCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9rZXkgaW4gdGhpcy5fYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZVtfa2V5XSA9IHRoaXMuX2F0dHJpYnV0ZXNbX2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiRXJyb3Igd2l0aCBlbGVtZW50XCIsIF90aGlzMi5faW1hZ2UpO1xuICAgICAgICAgICAgICAgIF90aGlzMi5fc3RhdGUgPSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUuZXJyb3I7XG4gICAgICAgICAgICAgICAgLy9FdmVudCB0aG91Z2ggdGhlcmUncyBhbiBlcnJvciByZWFkeSBzaG91bGQgYmUgc2V0IHRvIHRydWUgc28gdGhlIG5vZGUgY2FuIG91dHB1dCB0cmFuc3BhcmVublxuICAgICAgICAgICAgICAgIF90aGlzMi5fcmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzMi5fdHJpZ2dlckNhbGxiYWNrcyhcImVycm9yXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl91bmxvYWRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bmxvYWQoKSB7XG4gICAgICAgICAgICBfZ2V0KEltYWdlTm9kZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbWFnZU5vZGUucHJvdG90eXBlKSwgXCJfdW5sb2FkXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNSZXNwb25zaWJsZUZvckVsZW1lbnRMaWZlQ3ljbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZS5zcmMgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZS5vbmVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ltYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCBpbnN0YW5jZW9mIHdpbmRvdy5JbWFnZUJpdG1hcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVhZHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9zZWVrXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2Vlayh0aW1lKSB7XG4gICAgICAgICAgICBfZ2V0KEltYWdlTm9kZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbWFnZU5vZGUucHJvdG90eXBlKSwgXCJfc2Vla1wiLCB0aGlzKS5jYWxsKHRoaXMsIHRpbWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IF9zb3VyY2Vub2RlLlNPVVJDRU5PREVTVEFURS5wbGF5aW5nIHx8IHRoaXMuc3RhdGUgPT09IF9zb3VyY2Vub2RlLlNPVVJDRU5PREVTVEFURS5wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW1hZ2UgPT09IHVuZGVmaW5lZCkgdGhpcy5fbG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLl9zdGF0ZSA9PT0gX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFLnNlcXVlbmNlZCB8fCB0aGlzLl9zdGF0ZSA9PT0gX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFLmVuZGVkKSAmJiB0aGlzLl9lbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl91cGRhdGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUoY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgIC8vaWYgKCFzdXBlci5fdXBkYXRlKGN1cnJlbnRUaW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmVVcGxvYWRlZCkge1xuICAgICAgICAgICAgICAgIF9nZXQoSW1hZ2VOb2RlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEltYWdlTm9kZS5wcm90b3R5cGUpLCBcIl91cGRhdGVcIiwgdGhpcykuY2FsbCh0aGlzLCBjdXJyZW50VGltZSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfZ2V0KEltYWdlTm9kZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbWFnZU5vZGUucHJvdG90eXBlKSwgXCJfdXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fY3VycmVudFRpbWUgPD0gdGhpcy5fcHJlbG9hZFRpbWUgJiYgdGhpcy5fc3RhdGUgIT09IF9zb3VyY2Vub2RlLlNPVVJDRU5PREVTVEFURS53YWl0aW5nICYmIHRoaXMuX3N0YXRlICE9PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUuZW5kZWQpIHRoaXMuX2xvYWQoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUucGxheWluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFLmVuZGVkICYmIHRoaXMuX2ltYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmxvYWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlbGVtZW50VVJMXCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRVUkw7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW1hZ2VOb2RlO1xufShfc291cmNlbm9kZTIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuSU1BR0VUWVBFID0gVFlQRTtcbmV4cG9ydHMuZGVmYXVsdCA9IEltYWdlTm9kZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvU291cmNlTm9kZXMvbWVkaWFub2RlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9Tb3VyY2VOb2Rlcy9tZWRpYW5vZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3NldCA9IGZ1bmN0aW9uIHNldChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCAhPT0gbnVsbCkgeyBzZXQocGFyZW50LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjICYmIGRlc2Mud3JpdGFibGUpIHsgZGVzYy52YWx1ZSA9IHZhbHVlOyB9IGVsc2UgeyB2YXIgc2V0dGVyID0gZGVzYy5zZXQ7IGlmIChzZXR0ZXIgIT09IHVuZGVmaW5lZCkgeyBzZXR0ZXIuY2FsbChyZWNlaXZlciwgdmFsdWUpOyB9IH0gcmV0dXJuIHZhbHVlOyB9O1xuXG52YXIgX3NvdXJjZW5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NvdXJjZW5vZGUgKi8gXCIuL3NyYy9Tb3VyY2VOb2Rlcy9zb3VyY2Vub2RlLmpzXCIpO1xuXG52YXIgX3NvdXJjZW5vZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc291cmNlbm9kZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLy9NYXR0aGV3IFNob3R0b24sIFImRCBVc2VyIEV4cGVyaWVuY2UswqkgQkJDIDIwMTVcblxuXG52YXIgTWVkaWFOb2RlID0gZnVuY3Rpb24gKF9Tb3VyY2VOb2RlKSB7XG4gICAgX2luaGVyaXRzKE1lZGlhTm9kZSwgX1NvdXJjZU5vZGUpO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSBhbiBpbnN0YW5jZSBvZiBhIE1lZGlhTm9kZS5cbiAgICAgKiBUaGlzIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LCBidXQgZXh0ZW5kZWQgYnkgb3RoZXIgTm9kZSBUeXBlcyB3aGljaCB1c2UgYSBgSFRNTE1lZGlhRWxlbWVudGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWVkaWFOb2RlKHNyYywgZ2wsIHJlbmRlckdyYXBoLCBjdXJyZW50VGltZSkge1xuICAgICAgICB2YXIgZ2xvYmFsUGxheWJhY2tSYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAxLjA7XG4gICAgICAgIHZhciBzb3VyY2VPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG4gICAgICAgIHZhciBwcmVsb2FkVGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogNDtcbiAgICAgICAgdmFyIG1lZGlhRWxlbWVudENhY2hlID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDggJiYgYXJndW1lbnRzWzhdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbOF0gOiB7fTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVkaWFOb2RlKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTWVkaWFOb2RlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWVkaWFOb2RlKSkuY2FsbCh0aGlzLCBzcmMsIGdsLCByZW5kZXJHcmFwaCwgY3VycmVudFRpbWUpKTtcblxuICAgICAgICBfdGhpcy5fcHJlbG9hZFRpbWUgPSBwcmVsb2FkVGltZTtcbiAgICAgICAgX3RoaXMuX3NvdXJjZU9mZnNldCA9IHNvdXJjZU9mZnNldDtcbiAgICAgICAgX3RoaXMuX2dsb2JhbFBsYXliYWNrUmF0ZSA9IGdsb2JhbFBsYXliYWNrUmF0ZTtcbiAgICAgICAgX3RoaXMuX21lZGlhRWxlbWVudENhY2hlID0gbWVkaWFFbGVtZW50Q2FjaGU7XG4gICAgICAgIF90aGlzLl9wbGF5YmFja1JhdGUgPSAxLjA7XG4gICAgICAgIF90aGlzLl9wbGF5YmFja1JhdGVVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuX2F0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHsgdm9sdW1lOiAxLjAgfSwgYXR0cmlidXRlcyk7XG4gICAgICAgIF90aGlzLl9sb29wRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5faXNFbGVtZW50UGxheWluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoX3RoaXMuX2F0dHJpYnV0ZXMubG9vcCkge1xuICAgICAgICAgICAgX3RoaXMuX2xvb3BFbGVtZW50ID0gX3RoaXMuX2F0dHJpYnV0ZXMubG9vcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE1lZGlhTm9kZSwgW3tcbiAgICAgICAga2V5OiBcIl90cmlnZ2VyTG9hZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3RyaWdnZXJMb2FkKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGhhc24ndCBzdXBwbGllZCBhbiBlbGVtZW50LCB2aWRlb2NvbnRleHQgaXMgcmVzcG9uc2libGUgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBpZiAodGhpcy5faXNSZXNwb25zaWJsZUZvckVsZW1lbnRMaWZlQ3ljbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWVkaWFFbGVtZW50Q2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEdldCBhIGNhY2hlZCB2aWRlbyBlbGVtZW50IGFuZCBhbHNvIHBhc3MgdGhpcyBpbnN0YW5jZSBzbyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICogY2FjaGUgY2FuIGFjY2VzcyB0aGUgY3VycmVudCBwbGF5IHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudCA9IHRoaXMuX21lZGlhRWxlbWVudENhY2hlLmdldEVsZW1lbnRBbmRMaW5rVG9Ob2RlKHRoaXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuX2VsZW1lbnRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjcm9zc29yaWdpblwiLCBcImFub255bW91c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ3ZWJraXQtcGxheXNpbmxpbmVcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwicGxheXNpbmxpbmVcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZVVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50LnZvbHVtZSA9IHRoaXMuX2F0dHJpYnV0ZXMudm9sdW1lO1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuTWVkaWFTdHJlYW0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9lbGVtZW50VVJMIGluc3RhbmNlb2YgTWVkaWFTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5zcmNPYmplY3QgPSB0aGlzLl9lbGVtZW50VVJMO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuc3JjID0gdGhpcy5fZWxlbWVudFVSTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhdCB0aGlzIHN0YWdlIGVpdGhlciB0aGUgdXNlciBvciB0aGUgZWxlbWVudCBjYWNoZSBzaG91bGQgaGF2ZSBwcm92aWRlZCBhbiBlbGVtZW50XG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRba2V5XSA9IHRoaXMuX2F0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRpbWVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGltZSA+IHRoaXMuX3N0YXJ0VGltZSkgY3VycmVudFRpbWVPZmZzZXQgPSB0aGlzLl9jdXJyZW50VGltZSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50LmN1cnJlbnRUaW1lID0gdGhpcy5fc291cmNlT2Zmc2V0ICsgY3VycmVudFRpbWVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMyLl9lbGVtZW50ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIkVycm9yIHdpdGggZWxlbWVudFwiLCBfdGhpczIuX2VsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIuX3N0YXRlID0gX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAvL0V2ZW50IHRob3VnaCB0aGVyZSdzIGFuIGVycm9yIHJlYWR5IHNob3VsZCBiZSBzZXQgdG8gdHJ1ZSBzbyB0aGUgbm9kZSBjYW4gb3V0cHV0IHRyYW5zcGFyZW5uXG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi5fcmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIuX3RyaWdnZXJDYWxsYmFja3MoXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBkb2Vzbid0IGV4aXN0IGZvciB3aGF0ZXZlciByZWFzb24gZW50ZXIgdGhlIGVycm9yIHN0YXRlLlxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFLmVycm9yO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ2FsbGJhY2tzKFwiZXJyb3JcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xvYWRUcmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIF9sb2FkIGhhcyB0d28gZnVuY3Rpb25zOlxuICAgICAgICAgKlxuICAgICAgICAgKiAxLiBgX3RyaWdnZXJMb2FkYCB3aGljaCBlbnN1cmVzIHRoZSBlbGVtZW50IGhhcyB0aGUgY29ycmVjdCBzcmMgYW5kIGlzIGF0IHRoZSBjb3JyZWN0IGN1cnJlbnRUaW1lLFxuICAgICAgICAgKiAgICAgc28gdGhhdCB0aGUgYnJvd3NlciBjYW4gc3RhcnQgZmV0Y2hpbmcgbWVkaWEuXG4gICAgICAgICAqXG4gICAgICAgICAqIDIuICBgc2hvdWxkUG9sbEZvckVsZW1lbnRSZWFkeVN0YXRlYCB3YWl0cyB1bnRpbCB0aGUgZWxlbWVudCBoYXMgYSBcInJlYWRTdGF0ZVwiIHRoYXQgc2lnbmFscyB0aGVyZVxuICAgICAgICAgKiAgICAgaXMgZW5vdWdoIG1lZGlhIHRvIHN0YXJ0IHBsYXliYWNrLiBUaGlzIGlzIGEgbGl0dGxlIGNvbmZ1c2luZyBhcyBjdXJyZW50bHkgc3RydWN0dXJlZC5cbiAgICAgICAgICogICAgIFdlJ3JlIHVzaW5nIHRoZSBfdXBkYXRlIGxvb3AgdG8gcG9sbCB0aGUgX2xvYWQgZnVuY3Rpb24gd2hpY2ggY2hlY2tzIHRoZSBlbGVtZW50IHN0YXR1cy5cbiAgICAgICAgICogICAgIFdoZW4gcmVhZHkgd2UgZmlyZSBvZmYgdGhlIFwibG9hZGVkIGNhbGxiYWNrXCJcbiAgICAgICAgICpcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfbG9hZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWQoKSB7XG4gICAgICAgICAgICBfZ2V0KE1lZGlhTm9kZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNZWRpYU5vZGUucHJvdG90eXBlKSwgXCJfbG9hZFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlJ3ZlIGdvdCB0byBiZSBjYXJlZnVsIGhlcmUgYXMgX2xvYWQgaXMgY2FsbGVkIG1hbnkgdGltZXMgd2hpbHN0IHdhaXRpbmcgZm9yIHRoZSBlbGVtZW50IHRvIGJ1ZmZlclxuICAgICAgICAgICAgICogYW5kIHRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uY2UuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIHN0ZXAgb25lIGluIHdoYXQgc2hvdWxkIGJlIGEgbW9yZSB0aG9yb3VnaCByZWZhY3RvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xvYWRUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyTG9hZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2hvdWxkUG9sbEZvckVsZW1lbnRSZWFkeVN0YXRlID0gdGhpcy5fZWxlbWVudCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiB0aGlzIGV4cHJlc3Npb24gaXMgZWZmZWN0aXZlbHkgcG9sbGluZyB0aGUgZWxlbWVudCwgd2FpdGluZyBmb3IgaXQgdG8gYnVmZmVyXG4gICAgICAgICAgICAgKiBpdCBnZXRzIGNhbGxlZCBhIGxvdCBvZiB0aW1lXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChzaG91bGRQb2xsRm9yRWxlbWVudFJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudC5yZWFkeVN0YXRlID4gMyAmJiAhdGhpcy5fZWxlbWVudC5zZWVraW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGVsZW1lbnQgaGFzIGVub3VnaCBkYXRhIGZvciBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBhdCBsZWFzdCBhIGNvdXBsZSBvZiBmcmFtZXMgaW50byB0aGUgZnV0dXJlXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGR1cmF0aW9uIGhhcyBjaGFuZ2VkLiBVcGRhdGUgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIHBvdGVudGlhbGx5IGdvIGluIHRoZSBub3JtYWwgdXBkYXRlIGxvb3AgYnV0IEkgZG9uJ3Qgd2FudCB0byBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9vIG1hbnkgdGhpbmdzIGF0IG9uY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3BFbGVtZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BUaW1lID09PSBJbmZpbml0eSB8fCB0aGlzLl9zdG9wVGltZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wVGltZSA9IHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2VsZW1lbnQuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNhbGxiYWNrcyhcImR1cmF0aW9uY2hhbmdlXCIsIHRoaXMuZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2lnbmFsIHRvIHVzZXIgdGhhdCB0aGlzIG5vZGUgaGFzIFwibG9hZGVkXCJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWR5ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ2FsbGJhY2tzKFwibG9hZGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGxheWJhY2tSYXRlVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfdW5sb2FkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5sb2FkKCkge1xuICAgICAgICAgICAgX2dldChNZWRpYU5vZGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWVkaWFOb2RlLnByb3RvdHlwZSksIFwiX3VubG9hZFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzUmVzcG9uc2libGVGb3JFbGVtZW50TGlmZUN5Y2xlICYmIHRoaXMuX2VsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwic3JjXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuc3JjT2JqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQubG9hZCgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVubGluayB0aGlzIGZvcm0gdGhlIGNhY2hlLCBmcmVlaW5nIHVwIHRoZSBlbGVtZW50IGZvciBhbm90aGVyIG1lZGlhIG5vZGVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWVkaWFFbGVtZW50Q2FjaGUpIHRoaXMuX21lZGlhRWxlbWVudENhY2hlLnVubGlua05vZGVGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbWVkaWFFbGVtZW50Q2FjaGUpIGRlbGV0ZSB0aGlzLl9lbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVzZXQgY2xhc3MgdG8gaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5fcmVhZHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWxlbWVudFBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEZvciBjb21wbGV0ZW5lc3MuIEkgY291bGRuJ3QgZmluZCBhIHBhdGggdGhhdCByZXF1aXJlZCByZXVzZSBvZiB0aGlzLl9sb2FkVHJpZ2dlcmVkIGFmdGVyIF91bmxvYWQuXG4gICAgICAgICAgICB0aGlzLl9sb2FkVHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfc2Vla1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NlZWsodGltZSkge1xuICAgICAgICAgICAgX2dldChNZWRpYU5vZGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWVkaWFOb2RlLnByb3RvdHlwZSksIFwiX3NlZWtcIiwgdGhpcykuY2FsbCh0aGlzLCB0aW1lKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUucGxheWluZyB8fCB0aGlzLnN0YXRlID09PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgPT09IHVuZGVmaW5lZCkgdGhpcy5fbG9hZCgpO1xuICAgICAgICAgICAgICAgIHZhciByZWxhdGl2ZVRpbWUgPSB0aGlzLl9jdXJyZW50VGltZSAtIHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX3NvdXJjZU9mZnNldDtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50LmN1cnJlbnRUaW1lID0gcmVsYXRpdmVUaW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuX3N0YXRlID09PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUuc2VxdWVuY2VkIHx8IHRoaXMuX3N0YXRlID09PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUuZW5kZWQpICYmIHRoaXMuX2VsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZShjdXJyZW50VGltZSkge1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJUZXh0dXJlVXBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAgICAgICAvL2lmICghc3VwZXIuX3VwZGF0ZShjdXJyZW50VGltZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIF9nZXQoTWVkaWFOb2RlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1lZGlhTm9kZS5wcm90b3R5cGUpLCBcIl91cGRhdGVcIiwgdGhpcykuY2FsbCh0aGlzLCBjdXJyZW50VGltZSwgdHJpZ2dlclRleHR1cmVVcGRhdGUpO1xuICAgICAgICAgICAgLy9jaGVjayBpZiB0aGUgbWVkaWEgaGFzIGVuZGVkXG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQuZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUuZW5kZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJDYWxsYmFja3MoXCJlbmRlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9jdXJyZW50VGltZSA8PSB0aGlzLl9wcmVsb2FkVGltZSAmJiB0aGlzLl9zdGF0ZSAhPT0gX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFLndhaXRpbmcgJiYgdGhpcy5fc3RhdGUgIT09IF9zb3VyY2Vub2RlLlNPVVJDRU5PREVTVEFURS5lbmRlZCkgdGhpcy5fbG9hZCgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IF9zb3VyY2Vub2RlLlNPVVJDRU5PREVTVEFURS5wbGF5aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BsYXliYWNrUmF0ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5wbGF5YmFja1JhdGUgPSB0aGlzLl9nbG9iYWxQbGF5YmFja1JhdGUgKiB0aGlzLl9wbGF5YmFja1JhdGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZVVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0VsZW1lbnRQbGF5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQucGxheSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RyZXRjaFBhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5wYXVzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzRWxlbWVudFBsYXlpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IF9zb3VyY2Vub2RlLlNPVVJDRU5PREVTVEFURS5wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50LnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNFbGVtZW50UGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFLmVuZGVkICYmIHRoaXMuX2VsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNFbGVtZW50UGxheWluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmxvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY2xlYXJUaW1lbGluZVN0YXRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclRpbWVsaW5lU3RhdGUoKSB7XG4gICAgICAgICAgICBfZ2V0KE1lZGlhTm9kZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNZWRpYU5vZGUucHJvdG90eXBlKSwgXCJjbGVhclRpbWVsaW5lU3RhdGVcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50LnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNFbGVtZW50UGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdW5sb2FkKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQpIHRoaXMuX2VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgICAgIF9nZXQoTWVkaWFOb2RlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1lZGlhTm9kZS5wcm90b3R5cGUpLCBcImRlc3Ryb3lcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInBsYXliYWNrUmF0ZVwiLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChwbGF5YmFja1JhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IHBsYXliYWNrUmF0ZTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZVVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF5YmFja1JhdGU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzdHJldGNoUGF1c2VkXCIsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHN0cmV0Y2hQYXVzZWQpIHtcbiAgICAgICAgICAgIF9zZXQoTWVkaWFOb2RlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1lZGlhTm9kZS5wcm90b3R5cGUpLCBcInN0cmV0Y2hQYXVzZWRcIiwgc3RyZXRjaFBhdXNlZCwgdGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdHJldGNoUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IF9zb3VyY2Vub2RlLlNPVVJDRU5PREVTVEFURS5wbGF5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50LnBsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyZXRjaFBhdXNlZDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVsZW1lbnRVUkxcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFVSTDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59XG4gICAgICAgICAqIEBzdW1tYXJ5IC0gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgd2FpdGluZyBvbiB0aGUgbmV0d29yayB0byBjb250aW51ZSBwbGF5YmFja1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9idWZmZXJpbmdcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LnJlYWR5U3RhdGUgPCBIVE1MTWVkaWFFbGVtZW50LkhBVkVfRlVUVVJFX0RBVEE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInZvbHVtZVwiLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2b2x1bWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXMudm9sdW1lID0gdm9sdW1lO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgIT09IHVuZGVmaW5lZCkgdGhpcy5fZWxlbWVudC52b2x1bWUgPSB0aGlzLl9hdHRyaWJ1dGVzLnZvbHVtZTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBNZWRpYU5vZGU7XG59KF9zb3VyY2Vub2RlMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTWVkaWFOb2RlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL1NvdXJjZU5vZGVzL25vZGVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL1NvdXJjZU5vZGVzL25vZGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9hdWRpb25vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2F1ZGlvbm9kZSAqLyBcIi4vc3JjL1NvdXJjZU5vZGVzL2F1ZGlvbm9kZS5qc1wiKTtcblxudmFyIF9hdWRpb25vZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXVkaW9ub2RlKTtcblxudmFyIF9jYW52YXNub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jYW52YXNub2RlICovIFwiLi9zcmMvU291cmNlTm9kZXMvY2FudmFzbm9kZS5qc1wiKTtcblxudmFyIF9jYW52YXNub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NhbnZhc25vZGUpO1xuXG52YXIgX2ltYWdlbm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW1hZ2Vub2RlICovIFwiLi9zcmMvU291cmNlTm9kZXMvaW1hZ2Vub2RlLmpzXCIpO1xuXG52YXIgX2ltYWdlbm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbWFnZW5vZGUpO1xuXG52YXIgX21lZGlhbm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWVkaWFub2RlICovIFwiLi9zcmMvU291cmNlTm9kZXMvbWVkaWFub2RlLmpzXCIpO1xuXG52YXIgX21lZGlhbm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZWRpYW5vZGUpO1xuXG52YXIgX3NvdXJjZW5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NvdXJjZW5vZGUgKi8gXCIuL3NyYy9Tb3VyY2VOb2Rlcy9zb3VyY2Vub2RlLmpzXCIpO1xuXG52YXIgX3NvdXJjZW5vZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc291cmNlbm9kZSk7XG5cbnZhciBfdmlkZW9ub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92aWRlb25vZGUgKi8gXCIuL3NyYy9Tb3VyY2VOb2Rlcy92aWRlb25vZGUuanNcIik7XG5cbnZhciBfdmlkZW9ub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvbm9kZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBOT0RFUyA9IHtcbiAgICBBdWRpb05vZGU6IF9hdWRpb25vZGUyLmRlZmF1bHQsXG4gICAgQ2FudmFzTm9kZTogX2NhbnZhc25vZGUyLmRlZmF1bHQsXG4gICAgSW1hZ2VOb2RlOiBfaW1hZ2Vub2RlMi5kZWZhdWx0LFxuICAgIE1lZGlhTm9kZTogX21lZGlhbm9kZTIuZGVmYXVsdCxcbiAgICBTb3VyY2VOb2RlOiBfc291cmNlbm9kZTIuZGVmYXVsdCxcbiAgICBWaWRlb05vZGU6IF92aWRlb25vZGUyLmRlZmF1bHRcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE5PREVTO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL1NvdXJjZU5vZGVzL3NvdXJjZW5vZGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9Tb3VyY2VOb2Rlcy9zb3VyY2Vub2RlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5TT1VSQ0VUWVBFID0gZXhwb3J0cy5TT1VSQ0VOT0RFU1RBVEUgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIik7XG5cbnZhciBfZ3JhcGhub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZ3JhcGhub2RlICovIFwiLi9zcmMvZ3JhcGhub2RlLmpzXCIpO1xuXG52YXIgX2dyYXBobm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncmFwaG5vZGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8vTWF0dGhldyBTaG90dG9uLCBSJkQgVXNlciBFeHBlcmllbmNlLMKpIEJCQyAyMDE1XG5cblxudmFyIFNUQVRFID0ge1xuICAgIHdhaXRpbmc6IDAsXG4gICAgc2VxdWVuY2VkOiAxLFxuICAgIHBsYXlpbmc6IDIsXG4gICAgcGF1c2VkOiAzLFxuICAgIGVuZGVkOiA0LFxuICAgIGVycm9yOiA1XG59O1xuXG52YXIgVFlQRSA9IFwiU291cmNlTm9kZVwiO1xuXG52YXIgU291cmNlTm9kZSA9IGZ1bmN0aW9uIChfR3JhcGhOb2RlKSB7XG4gICAgX2luaGVyaXRzKFNvdXJjZU5vZGUsIF9HcmFwaE5vZGUpO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSBhbiBpbnN0YW5jZSBvZiBhIFNvdXJjZU5vZGUuXG4gICAgICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3Igb3RoZXIgTm9kZXMgd2hpY2ggZ2VuZXJhdGUgbWVkaWEgdG8gYmUgcGFzc2VkIGludG8gdGhlIHByb2Nlc3NpbmcgcGlwZWxpbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU291cmNlTm9kZShzcmMsIGdsLCByZW5kZXJHcmFwaCwgY3VycmVudFRpbWUpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvdXJjZU5vZGUpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTb3VyY2VOb2RlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU291cmNlTm9kZSkpLmNhbGwodGhpcywgZ2wsIHJlbmRlckdyYXBoLCBbXSwgdHJ1ZSkpO1xuXG4gICAgICAgIF90aGlzLl9lbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5fZWxlbWVudFVSTCA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuX2lzUmVzcG9uc2libGVGb3JFbGVtZW50TGlmZUN5Y2xlID0gdHJ1ZTtcblxuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIiB8fCB3aW5kb3cuTWVkaWFTdHJlYW0gIT09IHVuZGVmaW5lZCAmJiBzcmMgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbSkge1xuICAgICAgICAgICAgLy9jcmVhdGUgdGhlIG5vZGUgZnJvbSB0aGUgcGFzc2VkIFVSTCBvciBNZWRpYVN0cmVhbVxuICAgICAgICAgICAgX3RoaXMuX2VsZW1lbnRVUkwgPSBzcmM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3VzZSB0aGUgcGFzc2VkIGVsZW1lbnQgdG8gY3JlYXRlIHRoZSBTb3VyY2VOb2RlXG4gICAgICAgICAgICBfdGhpcy5fZWxlbWVudCA9IHNyYztcbiAgICAgICAgICAgIF90aGlzLl9pc1Jlc3BvbnNpYmxlRm9yRWxlbWVudExpZmVDeWNsZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX3N0YXRlID0gU1RBVEUud2FpdGluZztcbiAgICAgICAgX3RoaXMuX2N1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIF90aGlzLl9zdGFydFRpbWUgPSBOYU47XG4gICAgICAgIF90aGlzLl9zdG9wVGltZSA9IEluZmluaXR5O1xuICAgICAgICBfdGhpcy5fcmVhZHkgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2xvYWRDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3N0cmV0Y2hQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3RleHR1cmUgPSAoMCwgX3V0aWxzLmNyZWF0ZUVsZW1lbnRUZXh0dXJlKShnbCk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDBdKSk7XG4gICAgICAgIF90aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgX3RoaXMuX3JlbmRlclBhdXNlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fZGlzcGxheU5hbWUgPSBUWVBFO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgb2YgdGhlIG5vZGUuXG4gICAgICogMCAtIFdhaXRpbmcsIHN0YXJ0KCkgaGFzIG5vdCBiZWVuIGNhbGxlZCBvbiBpdCB5ZXQuXG4gICAgICogMSAtIFNlcXVlbmNlZCwgc3RhcnQoKSBoYXMgYmVlbiBjYWxsZWQgYnV0IGl0IGlzIG5vdCBwbGF5aW5nIHlldC5cbiAgICAgKiAyIC0gUGxheWluZywgdGhlIG5vZGUgaXMgcGxheWluZy5cbiAgICAgKiAzIC0gUGF1c2VkLCB0aGUgbm9kZSBpcyBwYXVzZWQuXG4gICAgICogNCAtIEVuZGVkLCBwbGF5YmFjayBvZiB0aGUgbm9kZSBoYXMgZmluaXNoZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBjdHggPSBuZXcgVmlkZW9Db250ZXh0KCk7XG4gICAgICogdmFyIHZpZGVvTm9kZSA9IGN0eC5jcmVhdGVWaWRlb1NvdXJjZU5vZGUoJ3ZpZGVvLm1wNCcpO1xuICAgICAqIGNvbnNvbGUubG9nKHZpZGVvTm9kZS5zdGF0ZSk7IC8vd2lsbCBvdXRwdXQgMCAoZm9yIHdhaXRpbmcpXG4gICAgICogdmlkZW9Ob2RlLnN0YXJ0KDUpO1xuICAgICAqIGNvbnNvbGUubG9nKHZpZGVvTm9kZS5zdGF0ZSk7IC8vd2lsbCBvdXRwdXQgMSAoZm9yIHNlcXVlbmNlZClcbiAgICAgKiB2aWRlb05vZGUuc3RvcCgxMCk7XG4gICAgICogY3R4LnBsYXkoKTtcbiAgICAgKiBjb25zb2xlLmxvZyh2aWRlb05vZGUuc3RhdGUpOyAvL3dpbGwgb3V0cHV0IDIgKGZvciBwbGF5aW5nKVxuICAgICAqIGN0eC5wYXVzZWQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyh2aWRlb05vZGUuc3RhdGUpOyAvL3dpbGwgb3V0cHV0IDMgKGZvciBwYXVzZWQpXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhTb3VyY2VOb2RlLCBbe1xuICAgICAgICBrZXk6IFwiX2xvYWRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9sb2FkQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNhbGxiYWNrcyhcImxvYWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZENhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfdW5sb2FkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5sb2FkKCkge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNhbGxiYWNrcyhcImRlc3Ryb3lcIik7XG4gICAgICAgICAgICB0aGlzLl9sb2FkQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgY2FsbGJhY2tzIGFnYWluc3Qgb25lIG9mIHRoZXNlIGV2ZW50czogXCJsb2FkXCIsIFwiZGVzdHJveVwiLCBcInNlZWtcIiwgXCJwYXVzZVwiLCBcInBsYXlcIiwgXCJlbmRlZFwiLCBcImR1cmF0aW9uY2hhbmdlXCIsIFwibG9hZGVkXCIsIFwiZXJyb3JcIlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIHRoZSB0eXBlIG9mIGV2ZW50IHRvIHJlZ2lzdGVyIHRoZSBjYWxsYmFjayBhZ2FpbnN0LlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIC0gdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBjdHggPSBuZXcgVmlkZW9Db250ZXh0KCk7XG4gICAgICAgICAqIHZhciB2aWRlb05vZGUgPSBjdHguY3JlYXRlVmlkZW9Tb3VyY2VOb2RlKCd2aWRlby5tcDQnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogdmlkZW9Ob2RlLnJlZ2lzdGVyQ2FsbGJhY2soXCJsb2FkXCIsIGZ1bmN0aW9uKCl7XCJ2aWRlbyBpcyBsb2FkaW5nXCJ9KTtcbiAgICAgICAgICogdmlkZW9Ob2RlLnJlZ2lzdGVyQ2FsbGJhY2soXCJwbGF5XCIsIGZ1bmN0aW9uKCl7XCJ2aWRlbyBpcyBwbGF5aW5nXCJ9KTtcbiAgICAgICAgICogdmlkZW9Ob2RlLnJlZ2lzdGVyQ2FsbGJhY2soXCJlbmRlZFwiLCBmdW5jdGlvbigpe1widmlkZW8gaGFzIGVuZWRlZFwifSk7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicmVnaXN0ZXJDYWxsYmFja1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJDYWxsYmFjayh0eXBlLCBmdW5jKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaCh7IHR5cGU6IHR5cGUsIGZ1bmM6IGZ1bmMgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZnVuY10gLSB0aGUgY2FsbGJhY2sgdG8gcmVtb3ZlLCBpZiB1bmRlZmluZWQgd2lsbCByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhpcyBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgY3R4ID0gbmV3IFZpZGVvQ29udGV4dCgpO1xuICAgICAgICAgKiB2YXIgdmlkZW9Ob2RlID0gY3R4LmNyZWF0ZVZpZGVvU291cmNlTm9kZSgndmlkZW8ubXA0Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHZpZGVvTm9kZS5yZWdpc3RlckNhbGxiYWNrKFwibG9hZFwiLCBmdW5jdGlvbigpe1widmlkZW8gaXMgbG9hZGluZ1wifSk7XG4gICAgICAgICAqIHZpZGVvTm9kZS5yZWdpc3RlckNhbGxiYWNrKFwicGxheVwiLCBmdW5jdGlvbigpe1widmlkZW8gaXMgcGxheWluZ1wifSk7XG4gICAgICAgICAqIHZpZGVvTm9kZS5yZWdpc3RlckNhbGxiYWNrKFwiZW5kZWRcIiwgZnVuY3Rpb24oKXtcInZpZGVvIGhhcyBlbmVkZWRcIn0pO1xuICAgICAgICAgKiB2aWRlb05vZGUudW5yZWdpc3RlckNhbGxiYWNrKCk7IC8vcmVtb3ZlIGFsbCBvZiB0aGUgdGhyZWUgY2FsbGJhY2tzLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInVucmVnaXN0ZXJDYWxsYmFja1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdW5yZWdpc3RlckNhbGxiYWNrKGZ1bmMpIHtcbiAgICAgICAgICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5fY2FsbGJhY2tzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JlbW92ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYWxsYmFjay5mdW5jID09PSBmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JlbW92ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0b1JlbW92ZVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2NhbGxiYWNrID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2NhbGxiYWNrcy5pbmRleE9mKF9jYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiX3RyaWdnZXJDYWxsYmFja3NcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90cmlnZ2VyQ2FsbGJhY2tzKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSB0aGlzLl9jYWxsYmFja3NbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suZnVuYyh0aGlzLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suZnVuYyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0IHBsYXliYWNrIGF0IFZpZGVvQ29udGV4dC5jdXJyZW50VGltZSBwbHVzIHBhc3NlZCB0aW1lLiBJZiBwYXNzZWQgdGltZSBpcyBuZWdhdGl2ZSwgd2lsbCBwbGF5IGFzIHNvb24gYXMgcG9zc2libGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIC0gdGhlIHRpbWUgZnJvbSB0aGUgY3VycmVudFRpbWUgb2YgdGhlIFZpZGVvQ29udGV4dCB3aGljaCB0byBzdGFydCBwbGF5aW5nLCBpZiBuZWdhdGl2ZSB3aWxsIHBsYXkgYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2lsbCByZXR1cm4gdHJ1ZSBpcyBzZXFldW5jaW5nIGhhcyBzdWNjZWRlZCwgb3IgZmFsc2UgaWYgaXQgaXMgYWxyZWFkeSBzZXF1ZW5jZWQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwic3RhcnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KHRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gU1RBVEUud2FpdGluZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJTb3VyY2VOb2RlIGlzIGhhcyBhbHJlYWR5IGJlZW4gc2VxdWVuY2VkLiBDYW4ndCBzZXF1ZW5jZSB0d2ljZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aGlzLl9jdXJyZW50VGltZSArIHRpbWU7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFNUQVRFLnNlcXVlbmNlZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0IHBsYXliYWNrIGF0IGFuIGFic29sdXRlIHRpbWUgb250IHRoZSBWaWRlb0NvbnRleHQncyB0aW1lbGluZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSB0aGUgdGltZSBvbiB0aGUgVmlkZW9Db250ZXh0cyB0aW1lbGluZSB0byBzdGFydCBwbGF5aW5nLlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaWxsIHJldHVybiB0cnVlIGlzIHNlcWV1bmNpbmcgaGFzIHN1Y2NlZGVkLCBvciBmYWxzZSBpZiBpdCBpcyBhbHJlYWR5IHNlcXVlbmNlZC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzdGFydEF0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydEF0KHRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gU1RBVEUud2FpdGluZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJTb3VyY2VOb2RlIGlzIGhhcyBhbHJlYWR5IGJlZW4gc2VxdWVuY2VkLiBDYW4ndCBzZXF1ZW5jZSB0d2ljZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gU1RBVEUuc2VxdWVuY2VkO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzdG9wXCIsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCBwbGF5YmFjayBhdCBWaWRlb0NvbnRleHQuY3VycmVudFRpbWUgcGx1cyBwYXNzZWQgdGltZS4gSWYgcGFzc2VkIHRpbWUgaXMgbmVnYXRpdmUsIHdpbGwgcGxheSBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSAtIHRoZSB0aW1lIGZyb20gdGhlIGN1cnJlbnRUaW1lIG9mIHRoZSB2aWRlbyBjb250ZXh0IHdoaWNoIHRvIHN0b3AgcGxheWJhY2suXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdpbGwgcmV0dXJuIHRydWUgaXMgc2VxZXVuY2luZyBoYXMgc3VjY2VkZWQsIG9yIGZhbHNlIGlmIHRoZSBwbGF5YmFjayBoYXMgYWxyZWFkeSBlbmRlZCBvciBpZiBzdGFydCBoYXNuJ3QgYmVlbiBjYWxsZWQgeWV0LCBvciBpZiB0aW1lIGlzIGxlc3MgdGhhbiB0aGUgc3RhcnQgdGltZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKHRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gU1RBVEUuZW5kZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiU291cmNlTm9kZSBoYXMgYWxyZWFkeSBlbmRlZC4gQ2Fubm90IGNhbGwgc3RvcC5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gU1RBVEUud2FpdGluZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJTb3VyY2VOb2RlIG11c3QgaGF2ZSBzdGFydCBjYWxsZWQgYmVmb3JlIHN0b3AgaXMgY2FsbGVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGltZSArIHRpbWUgPD0gdGhpcy5fc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIlNvdXJjZU5vZGUgbXVzdCBoYXZlIGEgc3RvcCB0aW1lIGFmdGVyIGl0J3Mgc3RhcnQgdGltZSwgbm90IGJlZm9yZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RvcFRpbWUgPSB0aGlzLl9jdXJyZW50VGltZSArIHRpbWU7XG4gICAgICAgICAgICB0aGlzLl9zdHJldGNoUGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ2FsbGJhY2tzKFwiZHVyYXRpb25jaGFuZ2VcIiwgdGhpcy5kdXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wIHBsYXliYWNrIGF0IGFuIGFic29sdXRlIHRpbWUgb250IHRoZSBWaWRlb0NvbnRleHQncyB0aW1lbGluZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSB0aGUgdGltZSBvbiB0aGUgVmlkZW9Db250ZXh0cyB0aW1lbGluZSB0byBzdG9wIHBsYXlpbmcuXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdpbGwgcmV0dXJuIHRydWUgaXMgc2VxZXVuY2luZyBoYXMgc3VjY2VkZWQsIG9yIGZhbHNlIGlmIHRoZSBwbGF5YmFjayBoYXMgYWxyZWFkeSBlbmRlZCBvciBpZiBzdGFydCBoYXNuJ3QgYmVlbiBjYWxsZWQgeWV0LCBvciBpZiB0aW1lIGlzIGxlc3MgdGhhbiB0aGUgc3RhcnQgdGltZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzdG9wQXRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BBdCh0aW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFNUQVRFLmVuZGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIlNvdXJjZU5vZGUgaGFzIGFscmVhZHkgZW5kZWQuIENhbm5vdCBjYWxsIHN0b3AuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IFNUQVRFLndhaXRpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiU291cmNlTm9kZSBtdXN0IGhhdmUgc3RhcnQgY2FsbGVkIGJlZm9yZSBzdG9wIGlzIGNhbGxlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZSA8PSB0aGlzLl9zdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiU291cmNlTm9kZSBtdXN0IGhhdmUgYSBzdG9wIHRpbWUgYWZ0ZXIgaXQncyBzdGFydCB0aW1lLCBub3QgYmVmb3JlLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdG9wVGltZSA9IHRpbWU7XG4gICAgICAgICAgICB0aGlzLl9zdHJldGNoUGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ2FsbGJhY2tzKFwiZHVyYXRpb25jaGFuZ2VcIiwgdGhpcy5kdXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9zZWVrXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2Vlayh0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJQYXVzZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNhbGxiYWNrcyhcInNlZWtcIiwgdGltZSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gU1RBVEUud2FpdGluZykgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHRpbWUgPCB0aGlzLl9zdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLmNsZWFyVGV4dHVyZSkodGhpcy5fZ2wsIHRoaXMuX3RleHR1cmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gU1RBVEUuc2VxdWVuY2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWUgPj0gdGhpcy5fc3RhcnRUaW1lICYmIHRoaXMuX3N0YXRlICE9PSBTVEFURS5wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFNUQVRFLnBsYXlpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZSA+PSB0aGlzLl9zdG9wVGltZSkge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbHMuY2xlYXJUZXh0dXJlKSh0aGlzLl9nbCwgdGhpcy5fdGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNhbGxiYWNrcyhcImVuZGVkXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gU1RBVEUuZW5kZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3VwZGF0ZSB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZSA9IHRpbWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfcGF1c2VcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXVzZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gU1RBVEUucGxheWluZyB8fCB0aGlzLl9jdXJyZW50VGltZSA9PT0gMCAmJiB0aGlzLl9zdGFydFRpbWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ2FsbGJhY2tzKFwicGF1c2VcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBTVEFURS5wYXVzZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyUGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfcGxheVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYXkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFNUQVRFLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJDYWxsYmFja3MoXCJwbGF5XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gU1RBVEUucGxheWluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9pc1JlYWR5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNSZWFkeSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9idWZmZXJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFNUQVRFLnBsYXlpbmcgfHwgdGhpcy5fc3RhdGUgPT09IFNUQVRFLnBhdXNlZCB8fCB0aGlzLl9zdGF0ZSA9PT0gU1RBVEUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl91cGRhdGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUoY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyVGV4dHVyZVVwZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHRpbWVEZWx0YSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5fY3VycmVudFRpbWU7XG5cbiAgICAgICAgICAgIC8vdXBkYXRlIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG5cbiAgICAgICAgICAgIC8vdXBkYXRlIHRoZSBzdGF0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBTVEFURS53YWl0aW5nIHx8IHRoaXMuX3N0YXRlID09PSBTVEFURS5lbmRlZCB8fCB0aGlzLl9zdGF0ZSA9PT0gU1RBVEUuZXJyb3IpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNhbGxiYWNrcyhcInJlbmRlclwiLCBjdXJyZW50VGltZSk7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA8IHRoaXMuX3N0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbHMuY2xlYXJUZXh0dXJlKSh0aGlzLl9nbCwgdGhpcy5fdGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBTVEFURS5zZXF1ZW5jZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA+PSB0aGlzLl9zdGFydFRpbWUgJiYgdGhpcy5fc3RhdGUgIT09IFNUQVRFLnBhdXNlZCAmJiB0aGlzLl9zdGF0ZSAhPT0gU1RBVEUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IFNUQVRFLnBsYXlpbmcpIHRoaXMuX3RyaWdnZXJDYWxsYmFja3MoXCJwbGF5XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gU1RBVEUucGxheWluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRUaW1lID49IHRoaXMuX3N0b3BUaW1lKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlscy5jbGVhclRleHR1cmUpKHRoaXMuX2dsLCB0aGlzLl90ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ2FsbGJhY2tzKFwiZW5kZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBTVEFURS5lbmRlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy91cGRhdGUgdGhpcyBzb3VyY2Ugbm9kZXMgdGV4dHVyZVxuICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9yZWFkeSA9PT0gZmFsc2UpIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlbmRlclBhdXNlZCAmJiB0aGlzLl9zdGF0ZSA9PT0gU1RBVEUucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJUZXh0dXJlVXBkYXRlKSAoMCwgX3V0aWxzLnVwZGF0ZVRleHR1cmUpKHRoaXMuX2dsLCB0aGlzLl90ZXh0dXJlLCB0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJQYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBTVEFURS5wbGF5aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJUZXh0dXJlVXBkYXRlKSAoMCwgX3V0aWxzLnVwZGF0ZVRleHR1cmUpKHRoaXMuX2dsLCB0aGlzLl90ZXh0dXJlLCB0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RyZXRjaFBhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wVGltZSArPSB0aW1lRGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciBhbnkgdGltZWxpbmUgc3RhdGUgdGhlIG5vZGUgY3VycmVudGx5IGhhcywgdGhpcyBwdXRzIHRoZSBub2RlIGluIHRoZSBcIndhaXRpbmdcIiBzdGF0ZSwgYXMgaWYgbmVpdGhlciBzdGFydCBub3Igc3RvcCBoYWQgYmVlbiBjYWxsZWQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY2xlYXJUaW1lbGluZVN0YXRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclRpbWVsaW5lU3RhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBOYU47XG4gICAgICAgICAgICB0aGlzLl9zdG9wVGltZSA9IEluZmluaXR5O1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBTVEFURS53YWl0aW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3kgYW5kIGNsZWFuLXVwIHRoZSBub2RlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICB0aGlzLl91bmxvYWQoKTtcbiAgICAgICAgICAgIF9nZXQoU291cmNlTm9kZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTb3VyY2VOb2RlLnByb3RvdHlwZSksIFwiZGVzdHJveVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9lbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFVSTCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gU1RBVEUud2FpdGluZztcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IE5hTjtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BUaW1lID0gSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fbG9hZENhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLl90ZXh0dXJlKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzdGF0ZVwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIERPTSBlbGVtZW50IHdoaWNoIHJlcHJlc2VudHMgdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICAgICAgICogTm90ZTogSWYgYSBzb3VyY2Ugbm9kZSBpcyBjcmVhdGVkIHdpdGggYSB1cmwgcmF0aGVyIHRoYW4gcGFzc2luZyBpbiBhbiBleGlzdGluZyBlbGVtZW50IHRoZW4gdGhpcyB3aWxsIHJldHVybiB1bmRlZmluZWQgdW50aWwgdGhlIHNvdXJjZSBub2RlIHByZWxvYWRzIHRoZSBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUgdW5kZXJseWluZyBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIG1lZGlhIGZvciB0aGUgbm9kZS4gSWYgdGhlIGxpZmVjeWNsZSBvZiB0aGUgdmlkZW8gaXMgb3duZWQgVU5TSUdORURfQllURSB0aGUgbm9kZSBpdHNlbGYsIHRoaXMgY2FuIHJldHVybiB1bmRlZmluZWQgaWYgdGhlIGVsZW1lbnQgaGFzbid0IGJlZW4gbG9hZGVkIHlldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy9BY2Nlc3NpbmcgdGhlIEVsZW1lbnQgb24gYSBWaWRlb05vZGUgY3JlYXRlZCB2aWEgYSBVUkxcbiAgICAgICAgICogdmFyIGN0eCA9IG5ldyBWaWRlb0NvbnRleHQoKTtcbiAgICAgICAgICogdmFyIHZpZGVvTm9kZSA9IGN0eC5jcmVhdGVWaWRlb1NvdXJjZU5vZGUoJ3ZpZGVvLm1wNCcpO1xuICAgICAgICAgKiB2aWRlb05vZGUuc3RhcnQoMCk7XG4gICAgICAgICAqIHZpZGVvTm9kZS5zdG9wKDUpO1xuICAgICAgICAgKiAvL1doZW4gdGhlIG5vZGUgc3RhcnRzIHBsYXlpbmcgdGhlIGVsZW1lbnQgc2hvdWxkIGV4aXN0IHNvIHNldCBpdCdzIHZvbHVtZSB0byAwXG4gICAgICAgICAqIHZpZGVvTm9kZS5yZWdzaXRlckNhbGxiYWNrKFwicGxheVwiLCBmdW5jdGlvbigpe3ZpZGVvTm9kZS5lbGVtZW50LnZvbHVtZSA9IDA7fSk7XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vQWNjZXNzaW5nIHRoZSBFbGVtZW50IG9uIGEgVmlkZW9Ob2RlIGNyZWF0ZWQgdmlhIGFuIGFscmVhZHkgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICAgKiB2YXIgY3R4ID0gbmV3IFZpZGVvQ29udGV4dCgpO1xuICAgICAgICAgKiB2YXIgdmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuICAgICAgICAgKiB2YXIgdmlkZW9Ob2RlID0gY3R4LmNyZWF0ZVZpZGVvU291cmNlTm9kZSh2aWRlb0VsZW1lbnQpO1xuICAgICAgICAgKiB2aWRlb05vZGUuc3RhcnQoMCk7XG4gICAgICAgICAqIHZpZGVvTm9kZS5zdG9wKDUpO1xuICAgICAgICAgKiAvL1RoZSBlbGVtbnQgY2FuIGJlIGFjY2Vzc2VkIGFueSB0aW1lIGJlY2F1c2UgaXQncyBsaWZlY3ljbGUgaXMgbWFuYWdlZCBvdXRzaWRlIG9mIHRoZSBWaWRlb0NvbnRleHRcbiAgICAgICAgICogdmlkZW9Ob2RlLmVsZW1lbnQudm9sdW1lID0gMDtcbiAgICAgICAgICpcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlbGVtZW50XCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgZHVyYXRpb24gb2YgdGhlIG5vZGUgb24gYSB0aW1lbGluZS4gSWYgbm8gc3RhcnQgdGltZSBpcyBzZXQgd2lsbCByZXR1cm4gdW5kZWZpZW5kLCBpZiBubyBzdG9wIHRpbWUgaXMgc2V0IHdpbGwgcmV0dXJuIEluZmluaXR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkdXJhdGlvbiBvZiB0aGUgbm9kZSBpbiBzZWNvbmRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgY3R4ID0gbmV3IFZpZGVvQ29udGV4dCgpO1xuICAgICAgICAgKiB2YXIgdmlkZW9Ob2RlID0gY3R4LmNyZWF0ZVZpZGVvU291cmNlTm9kZSgndmlkZW8ubXA0Jyk7XG4gICAgICAgICAqIHZpZGVvTm9kZS5zdGFydCg1KTtcbiAgICAgICAgICogdmlkZW9Ob2RlLnN0b3AoMTApO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyh2aWRlb05vZGUuZHVyYXRpb24pOyAvL3dpbGwgb3V0cHV0IDEwXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5fc3RhcnRUaW1lKSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wVGltZSA9PT0gSW5maW5pdHkpIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltZSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInN0cmV0Y2hQYXVzZWRcIixcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc3RyZXRjaFBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fc3RyZXRjaFBhdXNlZCA9IHN0cmV0Y2hQYXVzZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmV0Y2hQYXVzZWQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzdGFydFRpbWVcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRUaW1lO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwic3RvcFRpbWVcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcFRpbWU7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU291cmNlTm9kZTtcbn0oX2dyYXBobm9kZTIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuU09VUkNFTk9ERVNUQVRFID0gU1RBVEU7XG5leHBvcnRzLlNPVVJDRVRZUEUgPSBUWVBFO1xuZXhwb3J0cy5kZWZhdWx0ID0gU291cmNlTm9kZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvU291cmNlTm9kZXMvdmlkZW9ub2RlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9Tb3VyY2VOb2Rlcy92aWRlb25vZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVklERU9UWVBFID0gdW5kZWZpbmVkO1xuXG52YXIgX21lZGlhbm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWVkaWFub2RlICovIFwiLi9zcmMvU291cmNlTm9kZXMvbWVkaWFub2RlLmpzXCIpO1xuXG52YXIgX21lZGlhbm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZWRpYW5vZGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8vTWF0dGhldyBTaG90dG9uLCBSJkQgVXNlciBFeHBlcmllbmNlLMKpIEJCQyAyMDE1XG5cblxudmFyIFRZUEUgPSBcIlZpZGVvTm9kZVwiO1xuXG52YXIgVmlkZW9Ob2RlID0gZnVuY3Rpb24gKF9NZWRpYU5vZGUpIHtcbiAgICBfaW5oZXJpdHMoVmlkZW9Ob2RlLCBfTWVkaWFOb2RlKTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpc2UgYW4gaW5zdGFuY2Ugb2YgYSBWaWRlb05vZGUuXG4gICAgICogVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseSwgYnV0IGNyZWF0ZWQgdGhyb3VnaCBhIGNhbGwgdG8gdmlkZW9Db250ZXh0LmNyZWF0ZVZpZGVvTm9kZSgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZpZGVvTm9kZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvTm9kZSk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFZpZGVvTm9kZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFZpZGVvTm9kZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgICAgIF90aGlzLl9kaXNwbGF5TmFtZSA9IFRZUEU7XG4gICAgICAgIF90aGlzLl9lbGVtZW50VHlwZSA9IFwidmlkZW9cIjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBWaWRlb05vZGU7XG59KF9tZWRpYW5vZGUyLmRlZmF1bHQpO1xuXG5leHBvcnRzLlZJREVPVFlQRSA9IFRZUEU7XG5leHBvcnRzLmRlZmF1bHQgPSBWaWRlb05vZGU7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2V4Y2VwdGlvbnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9leGNlcHRpb25zLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Db25uZWN0RXhjZXB0aW9uID0gQ29ubmVjdEV4Y2VwdGlvbjtcbmV4cG9ydHMuUmVuZGVyRXhjZXB0aW9uID0gUmVuZGVyRXhjZXB0aW9uO1xuLy9NYXR0aGV3IFNob3R0b24sIFImRCBVc2VyIEV4cGVyaWVuY2UswqkgQkJDIDIwMTVcbmZ1bmN0aW9uIENvbm5lY3RFeGNlcHRpb24obWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gXCJDb25uZWN0aW9uRXhjZXB0aW9uXCI7XG59XG5cbmZ1bmN0aW9uIFJlbmRlckV4Y2VwdGlvbihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSBcIlJlbmRlckV4Y2VwdGlvblwiO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9ncmFwaG5vZGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2dyYXBobm9kZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vL01hdHRoZXcgU2hvdHRvbiwgUiZEIFVzZXIgRXhwZXJpZW5jZSzCqSBCQkMgMjAxNVxuXG52YXIgVFlQRSA9IFwiR3JhcGhOb2RlXCI7XG5cbnZhciBHcmFwaE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQmFzZSBjbGFzcyBmcm9tIHdoaWNoIGFsbCBwcm9jZXNzaW5nIGFuZCBzb3VyY2Ugbm9kZXMgYXJlIGRlcnJpdmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEdyYXBoTm9kZShnbCwgcmVuZGVyR3JhcGgsIGlucHV0TmFtZXMpIHtcbiAgICAgICAgdmFyIGxpbWl0Q29ubmVjdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmFwaE5vZGUpO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlckdyYXBoID0gcmVuZGVyR3JhcGg7XG4gICAgICAgIHRoaXMuX2xpbWl0Q29ubmVjdGlvbnMgPSBsaW1pdENvbm5lY3Rpb25zO1xuICAgICAgICB0aGlzLl9pbnB1dE5hbWVzID0gaW5wdXROYW1lcztcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgICAgLy9TZXR1cCBXZWJHTCBvdXRwdXQgdGV4dHVyZVxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xuICAgICAgICB0aGlzLl9yZW5kZXJHcmFwaCA9IHJlbmRlckdyYXBoO1xuICAgICAgICB0aGlzLl9yZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXNwbGF5TmFtZSA9IFRZUEU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjbGFzcyBuYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiBTdHJpbmcgQSBzdHJpbmcgb2YgdGhlIGNsYXNzIG5hbWUuXG4gICAgICovXG5cbiAgICBfY3JlYXRlQ2xhc3MoR3JhcGhOb2RlLCBbe1xuICAgICAgICBrZXk6IFwiY29ubmVjdFwiLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbm5lY3QgdGhpcyBub2RlIHRvIHRoZSB0YXJnZXROb2RlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7R3JhcGhOb2RlfSB0YXJnZXROb2RlIC0gdGhlIG5vZGUgdG8gY29ubmVjdC5cbiAgICAgICAgICogQHBhcmFtIHsobnVtYmVyfCBTdHJpbmcpfSBbdGFyZ2V0UG9ydF0gLSB0aGUgcG9ydCBvbiB0aGUgdGFyZ2V0Tm9kZSB0byBjb25uZWN0IHRvLCB0aGlzIGNhbiBiZSBhbiBpbmRleCwgYSBzdHJpbmcgaWRlbnRpZmllciwgb3IgdW5kZWZpbmVkIChpbiB3aGljaCBjYXNlIHRoZSBuZXh0IGF2YWlsYWJsZSBwb3J0IHdpbGwgYmUgY29ubmVjdGVkIHRvKS5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KHRhcmdldE5vZGUsIHRhcmdldFBvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJHcmFwaC5yZWdpc3RlckNvbm5lY3Rpb24odGhpcywgdGFyZ2V0Tm9kZSwgdGFyZ2V0UG9ydCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzY29ubmVjdCB0aGlzIG5vZGUgZnJvbSB0aGUgdGFyZ2V0Tm9kZS4gSWYgdGFyZ2V0Tm9kZSBpcyB1bmRlZmluZCByZW1vdmUgYWxsIG91dC1ib3VuZCBjb25uZWN0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtHcmFwaE5vZGV9IFt0YXJnZXROb2RlXSAtIHRoZSBub2RlIHRvIGRpc2Nvbm5lY3QgZnJvbS4gSWYgdW5kZWZpbmVkLCBkaXNjb25uZWN0IGZyb20gYWxsIG5vZGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRpc2Nvbm5lY3RcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3QodGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciB0b1JlbW92ZSA9IHRoaXMuX3JlbmRlckdyYXBoLmdldE91dHB1dHNGb3JOb2RlKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlbmRlckdyYXBoLnVucmVnaXN0ZXJDb25uZWN0aW9uKF90aGlzLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0b1JlbW92ZS5sZW5ndGggPiAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyR3JhcGgudW5yZWdpc3RlckNvbm5lY3Rpb24odGhpcywgdGFyZ2V0Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdG9yeSB0aGlzIG5vZGUsIHJlbW92aW5nIGl0IGZyb20gdGhlIGdyYXBoLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRoaXMuaW5wdXRzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5kaXNjb25uZWN0KHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJkaXNwbGF5TmFtZVwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG5hbWVzIG9mIHRoZSBpbnB1dHMgdG8gdGhpcyBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0gQW4gYXJyYXkgb2YgdGhlIG5hbWVzIG9mIHRoZSBpbnB1dHMgb3QgdGhlIG5vZGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiaW5wdXROYW1lc1wiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dE5hbWVzLnNsaWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbm5lY3Rpb25zIHRoYXQgY2FuIGJlIG1hZGUgdG8gdGhpcyBub2RlLiBJZiB0aGVyZSBpcyBub3QgbGltaXQgdGhpcyB3aWxsIHJldHVybiBJbmZpbml0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbm5lY3Rpb25zIHdoaWNoIGNhbiBiZSBtYWRlIHRvIHRoaXMgbm9kZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJtYXhpbXVtQ29ubmVjdGlvbnNcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGltaXRDb25uZWN0aW9ucyA9PT0gZmFsc2UpIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dE5hbWVzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYW4gYXJyYXkgb2YgYWxsIHRoZSBub2RlcyB3aGljaCBjb25uZWN0IHRvIHRoaXMgbm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7R3JhcGhOb2RlW119IEFuIGFycmF5IG9mIG5vZGVzIHdoaWNoIGNvbm5lY3QgdG8gdGhpcyBub2RlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImlucHV0c1wiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9yZW5kZXJHcmFwaC5nZXRJbnB1dHNGb3JOb2RlKHRoaXMpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFuIGFycmF5IG9mIGFsbCB0aGUgbm9kZXMgd2hpY2ggdGhpcyBub2RlIG91dHB1dHMgdG8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0dyYXBoTm9kZVtdfSBBbiBhcnJheSBvZiBub2RlcyB3aGljaCB0aGlzIG5vZGUgY29ubmVjdHMgdG8uXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwib3V0cHV0c1wiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJHcmFwaC5nZXRPdXRwdXRzRm9yTm9kZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgd2hldGhlciB0aGUgbm9kZSBoYXMgYmVlbiBkZXN0cm95ZWQgb3Igbm90LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBBIHRydWUvZmFsc2UgdmFsdWUgb2Ygd2hhdGhlciB0aGUgbm9kZSBoYXMgYmVlbiBkZXN0b3J5ZWQgb3Igbm90LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlc3Ryb3llZFwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXN0cm95ZWQ7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gR3JhcGhOb2RlO1xufSgpO1xuXG5leHBvcnRzLkdSQVBIVFlQRSA9IFRZUEU7XG5leHBvcnRzLmRlZmF1bHQgPSBHcmFwaE5vZGU7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3JlbmRlcmdyYXBoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3JlbmRlcmdyYXBoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLy9NYXR0aGV3IFNob3R0b24sIFImRCBVc2VyIEV4cGVyaWVuY2UswqkgQkJDIDIwMTVcblxuXG52YXIgX2V4Y2VwdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V4Y2VwdGlvbnMuanMgKi8gXCIuL3NyYy9leGNlcHRpb25zLmpzXCIpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUmVuZGVyR3JhcGggPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogTWFuYWdlcyB0aGUgcmVuZGVyaW5nIGdyYXBoLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbmRlckdyYXBoKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVuZGVyR3JhcGgpO1xuXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsaXN0IG9mIG5vZGVzIHdoaWNoIGFyZSBjb25uZWN0ZWQgdG8gdGhlIG91dHB1dCBvZiB0aGUgcGFzc2VkIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0dyYXBoTm9kZX0gbm9kZSAtIHRoZSBub2RlIHRvIGdldCB0aGUgb3V0cHV0cyBmb3IuXG4gICAgICogQHJldHVybiB7R3JhcGhOb2RlW119IEFuIGFycmF5IG9mIHRoZSBub2RlcyB3aGljaCBhcmUgY29ubmVjdGVkIHRvIHRoZSBvdXRwdXQuXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhSZW5kZXJHcmFwaCwgW3tcbiAgICAgICAga2V5OiBcImdldE91dHB1dHNGb3JOb2RlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPdXRwdXRzRm9yTm9kZShub2RlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uc291cmNlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjb25uZWN0aW9uLmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIGxpc3Qgb2Ygbm9kZXMgd2hpY2ggYXJlIGNvbm5lY3RlZCwgYnkgaW5wdXQgbmFtZSwgdG8gdGhlIGdpdmVuIG5vZGUuIEFycmF5IGNvbnRhaW5zIG9iamVjdHMgb2YgdGhlIGZvcm06IHtcInNvdXJjZVwiOnNvdXJjZU5vZGUsIFwidHlwZVwiOlwibmFtZVwiLCBcIm5hbWVcIjppbnB1dE5hbWUsIFwiZGVzdGluYXRpb25cIjpkZXN0aW5hdGlvbk5vZGV9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0dyYXBoTm9kZX0gbm9kZSAtIHRoZSBub2RlIHRvIGdldCB0aGUgbmFtZWQgaW5wdXRzIGZvci5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0W119IEFuIGFycmF5IG9mIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBub2RlcyBhbmQgY29ubmVjdGlvbiB0eXBlLCB3aGljaCBhcmUgY29ubmVjdGVkIHRvIHRoZSBuYW1lZCBpbnB1dHMgZm9yIHRoZSBub2RlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldE5hbWVkSW5wdXRzRm9yTm9kZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmFtZWRJbnB1dHNGb3JOb2RlKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5kZXN0aW5hdGlvbiA9PT0gbm9kZSAmJiBjb25uZWN0aW9uLnR5cGUgPT09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIGxpc3Qgb2Ygbm9kZXMgd2hpY2ggYXJlIGNvbm5lY3RlZCwgYnkgei1pbmRleCBuYW1lLCB0byB0aGUgZ2l2ZW4gbm9kZS4gQXJyYXkgY29udGFpbnMgb2JqZWN0cyBvZiB0aGUgZm9ybToge1wic291cmNlXCI6c291cmNlTm9kZSwgXCJ0eXBlXCI6XCJ6SW5kZXhcIiwgXCJ6SW5kZXhcIjowLCBcImRlc3RpbmF0aW9uXCI6ZGVzdGluYXRpb25Ob2RlfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtHcmFwaE5vZGV9IG5vZGUgLSB0aGUgbm9kZSB0byBnZXQgdGhlIHotaW5kZXggcmVmZXJuY2VkIGlucHV0cyBmb3IuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdFtdfSBBbiBhcnJheSBvZiBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgbm9kZXMgYW5kIGNvbm5lY3Rpb24gdHlwZSwgd2hpY2ggYXJlIGNvbm5lY3RlZCBieSB6LUluZGV4IGZvciB0aGUgbm9kZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRaSW5kZXhJbnB1dHNGb3JOb2RlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRaSW5kZXhJbnB1dHNGb3JOb2RlKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5kZXN0aW5hdGlvbiA9PT0gbm9kZSAmJiBjb25uZWN0aW9uLnR5cGUgPT09IFwiekluZGV4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuekluZGV4IC0gYi56SW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIGxpc3Qgb2Ygbm9kZXMgd2hpY2ggYXJlIGNvbm5lY3RlZCBhcyBpbnB1dHMgdG8gdGhlIGdpdmVuIG5vZGUuIFRoZSBsZW5ndGggb2YgdGhlIHJldHVybiBhcnJheSBpcyBhbHdheXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBpbnB1dHMgZm9yIHRoZSBub2RlLCB3aXRoIHVuZGVmaW5lZCB0YWtpbmcgdGhlIHBsYWNlIG9mIGFueSBpbnB1dHMgbm90IGNvbm5lY3RlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtHcmFwaE5vZGV9IG5vZGUgLSB0aGUgbm9kZSB0byBnZXQgdGhlIGlucHV0cyBmb3IuXG4gICAgICAgICAqIEByZXR1cm4ge0dyYXBoTm9kZVtdfSBBbiBhcnJheSBvZiBHcmFwaE5vZGVzIHdoaWNoIGFyZSBjb25uZWN0ZWQgdG8gdGhlIG5vZGUuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0SW5wdXRzRm9yTm9kZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5wdXRzRm9yTm9kZShub2RlKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXROYW1lcyA9IG5vZGUuaW5wdXROYW1lcztcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICB2YXIgbmFtZWRJbnB1dHMgPSB0aGlzLmdldE5hbWVkSW5wdXRzRm9yTm9kZShub2RlKTtcbiAgICAgICAgICAgIHZhciBpbmRleGVkSW5wdXRzID0gdGhpcy5nZXRaSW5kZXhJbnB1dHNGb3JOb2RlKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5fbGltaXRDb25uZWN0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBuYW1lZElucHV0c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGlucHV0TmFtZXMuaW5kZXhPZihjb25uZWN0aW9uLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSBjb25uZWN0aW9uLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ZWRJbnB1dHNJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHJlc3VsdHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzW19pXSA9PT0gdW5kZWZpbmVkICYmIGluZGV4ZWRJbnB1dHNbaW5kZXhlZElucHV0c0luZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW19pXSA9IGluZGV4ZWRJbnB1dHNbaW5kZXhlZElucHV0c0luZGV4XS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVkSW5wdXRzSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBuYW1lZElucHV0c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jb25uZWN0aW9uID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goX2Nvbm5lY3Rpb24uc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gaW5kZXhlZElucHV0c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jb25uZWN0aW9uMiA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKF9jb25uZWN0aW9uMi5zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgYSBuYW1lZCBpbnB1dCBvbiBhIG5vZGUgaXMgYXZhaWxhYmxlIHRvIGNvbm5lY3QgdG9vLlxuICAgICAgICAgKiBAcGFyYW0ge0dyYXBoTm9kZX0gbm9kZSAtIHRoZSBub2RlIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXROYW1lIC0gdGhlIG5hbWVkIGlucHV0IHRvIGNoZWNrLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImlzSW5wdXRBdmFpbGFibGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW5wdXRBdmFpbGFibGUobm9kZSwgaW5wdXROYW1lKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5faW5wdXROYW1lcy5pbmRleE9mKGlucHV0TmFtZSkgPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gdGhpcy5jb25uZWN0aW9uc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IF9zdGVwNC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbi50eXBlID09PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uZGVzdGluYXRpb24gPT09IG5vZGUgJiYgY29ubmVjdGlvbi5uYW1lID09PSBpbnB1dE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBjb25uZWN0aW9uIGJldHdlZW4gdHdvIG5vZGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0dyYXBoTm9kZX0gc291cmNlTm9kZSAtIHRoZSBub2RlIHRvIGNvbm5lY3QgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtHcmFwaE5vZGV9IGRlc3RpbmF0aW9uTm9kZSAtIHRoZSBub2RlIHRvIGNvbm5lY3QgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IG51bWJlcil9IFt0YXJnZXRdIC0gdGhlIHRhcmdldCBwb3J0IG9mIHRoZSBjb25lbmN0aW9uLCB0aGlzIGNvdWxkIGJlIGEgc3RyaW5nIHRvIHNwZWNmaXkgYSBzcGVjaWZpYyBuYW1lZCBwb3J0LCBhIG51bWJlciB0byBzcGVjaWZ5IGEgcG9ydCBieSBpbmRleCwgb3IgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIHRoZSBuZXh0IGF2YWlsYWJsZSBwb3J0IHdpbGwgYmUgY29ubmVjdGVkIHRvLlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaWxsIHJldHVybiB0cnVlIGlmIGNvbm5lY3Rpb24gc3VjY2VlZHMgb3RoZXJ3aXNlIHdpbGwgdGhyb3cgYSBDb25uZWN0RXhjZXB0aW9uLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInJlZ2lzdGVyQ29ubmVjdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJDb25uZWN0aW9uKHNvdXJjZU5vZGUsIGRlc3RpbmF0aW9uTm9kZSwgdGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoZGVzdGluYXRpb25Ob2RlLmlucHV0cy5sZW5ndGggPj0gZGVzdGluYXRpb25Ob2RlLmlucHV0TmFtZXMubGVuZ3RoICYmIGRlc3RpbmF0aW9uTm9kZS5fbGltaXRDb25uZWN0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9ucy5Db25uZWN0RXhjZXB0aW9uKFwiTm9kZSBoYXMgcmVhY2hlZCBtYXggbnVtYmVyIG9mIGlucHV0cywgY2FuJ3QgY29ubmVjdFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uTm9kZS5fbGltaXRDb25uZWN0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBtYWRlLCBpZiBzbyByYWlzZSBhIHdhcm5pbmdcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRzID0gdGhpcy5nZXRJbnB1dHNGb3JOb2RlKGRlc3RpbmF0aW9uTm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0cy5pbmNsdWRlcyhzb3VyY2VOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiV0FSTklORyAtIG5vZGUgY29ubmVjdGVkIG11dGxpcGxlIHRpbWVzLCByZW1vdmluZyBwcmV2aW91cyBjb25uZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJDb25uZWN0aW9uKHNvdXJjZU5vZGUsIGRlc3RpbmF0aW9uTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIC8vdGFyZ2V0IGlzIGEgc3BlY2lmaWNcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZU5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiekluZGV4XCIsXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb25Ob2RlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIgJiYgZGVzdGluYXRpb25Ob2RlLl9saW1pdENvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgLy90YXJnZXQgaXMgYSBuYW1lZCBwb3J0XG5cbiAgICAgICAgICAgICAgICAvL21ha2Ugc3VyZSBuYW1lZCBwb3J0IGlzIGZyZWVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0lucHV0QXZhaWxhYmxlKGRlc3RpbmF0aW9uTm9kZSwgdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2VOb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJuYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb25Ob2RlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9ucy5Db25uZWN0RXhjZXB0aW9uKFwiUG9ydCBcIiArIHRhcmdldCArIFwiIGlzIGFscmVhZHkgY29ubmVjdGVkIHRvXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy90YXJnZXQgaXMgdW5kZWZpbmVkIHNvIGp1c3QgbWFrZSBpdCBhIGhpZ2ggekluZGV4XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ZWRDb25ucyA9IHRoaXMuZ2V0WkluZGV4SW5wdXRzRm9yTm9kZShkZXN0aW5hdGlvbk5vZGUpO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ZWRDb25ucy5sZW5ndGggPiAwKSBpbmRleCA9IGluZGV4ZWRDb25uc1tpbmRleGVkQ29ubnMubGVuZ3RoIC0gMV0uekluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZU5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiekluZGV4XCIsXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbk5vZGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gbm9kZXMuXG4gICAgICAgICAqIEBwYXJhbSB7R3JhcGhOb2RlfSBzb3VyY2VOb2RlIC0gdGhlIG5vZGUgdG8gdW5yZWdzaXRlciBjb25uZWN0aW9uIGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7R3JhcGhOb2RlfSBkZXN0aW5hdGlvbk5vZGUgLSB0aGUgbm9kZSB0byByZWdpc3RlciBjb25uZWN0aW9uIHRvLlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaWxsIHJldHVybiB0cnVlIGlmIHJlbW92aW5nIGNvbm5lY3Rpb24gc3VjY2VlZHMsIG9yIGZhbHNlIGlmIHRoZXJlIHdhcyBubyBjb25uZWN0aW9uc2N0aW9uIHRvIHJlbW92ZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJ1bnJlZ2lzdGVyQ29ubmVjdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdW5yZWdpc3RlckNvbm5lY3Rpb24oc291cmNlTm9kZSwgZGVzdGluYXRpb25Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgdG9SZW1vdmUgPSBbXTtcblxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uc291cmNlID09PSBzb3VyY2VOb2RlICYmIGNvbm5lY3Rpb24uZGVzdGluYXRpb24gPT09IGRlc3RpbmF0aW9uTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0b1JlbW92ZS5wdXNoKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodG9SZW1vdmUubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHRvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKHJlbW92ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5jb25uZWN0aW9ucy5pbmRleE9mKHJlbW92ZU5vZGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiBcIm91dHB1dEVkZ2VzRm9yXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXRFZGdlc0Zvcihub2RlLCBjb25uZWN0aW9ucykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSBjb25uZWN0aW9uc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IChfc3RlcDUgPSBfaXRlcmF0b3I1Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29ubiA9IF9zdGVwNS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubi5zb3VyY2UgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjb25uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3I1ID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3I1LnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImlucHV0RWRnZXNGb3JcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlucHV0RWRnZXNGb3Iobm9kZSwgY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNiA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I2ID0gY29ubmVjdGlvbnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDY7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSAoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbm4gPSBfc3RlcDYudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm4uZGVzdGluYXRpb24gPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjb25uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNiA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3I2ID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ICYmIF9pdGVyYXRvcjYucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3I2LnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldElucHV0bGVzc05vZGVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnB1dGxlc3NOb2Rlcyhjb25uZWN0aW9ucykge1xuICAgICAgICAgICAgdmFyIGlucHV0TGVzcyA9IFtdO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNyA9IGNvbm5lY3Rpb25zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA3OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gKF9zdGVwNyA9IF9pdGVyYXRvcjcubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25uID0gX3N0ZXA3LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlucHV0TGVzcy5wdXNoKGNvbm4uc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yNyA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyAmJiBfaXRlcmF0b3I3LnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNy5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjggPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjggPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yOCA9IGNvbm5lY3Rpb25zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA4OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gKF9zdGVwOCA9IF9pdGVyYXRvcjgubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfY29ubiA9IF9zdGVwOC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBpbnB1dExlc3MuaW5kZXhPZihfY29ubi5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0TGVzcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjggPSBlcnI7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggJiYgX2l0ZXJhdG9yOC5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjgucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnB1dExlc3M7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUmVuZGVyR3JhcGg7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJlbmRlckdyYXBoO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVXBkYXRlYWJsZXNNYW5hZ2VyID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvL01hdHRoZXcgU2hvdHRvbiwgUiZEIFVzZXIgRXhwZXJpZW5jZSzCqSBCQkMgMjAxNVxuXG5cbmV4cG9ydHMuY29tcGlsZVNoYWRlciA9IGNvbXBpbGVTaGFkZXI7XG5leHBvcnRzLmNyZWF0ZVNoYWRlclByb2dyYW0gPSBjcmVhdGVTaGFkZXJQcm9ncmFtO1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50VGV4dHVyZSA9IGNyZWF0ZUVsZW1lbnRUZXh0dXJlO1xuZXhwb3J0cy51cGRhdGVUZXh0dXJlID0gdXBkYXRlVGV4dHVyZTtcbmV4cG9ydHMuY2xlYXJUZXh0dXJlID0gY2xlYXJUZXh0dXJlO1xuZXhwb3J0cy5nZW5lcmF0ZVJhbmRvbUlkID0gZ2VuZXJhdGVSYW5kb21JZDtcbmV4cG9ydHMuZXhwb3J0VG9KU09OID0gZXhwb3J0VG9KU09OO1xuZXhwb3J0cy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuZXhwb3J0cy5jcmVhdGVDb250cm9sRm9ybUZvck5vZGUgPSBjcmVhdGVDb250cm9sRm9ybUZvck5vZGU7XG5leHBvcnRzLnZpc3VhbGlzZVZpZGVvQ29udGV4dEdyYXBoID0gdmlzdWFsaXNlVmlkZW9Db250ZXh0R3JhcGg7XG5leHBvcnRzLmNyZWF0ZVNpZ21hR3JhcGhEYXRhRnJvbVJlbmRlckdyYXBoID0gY3JlYXRlU2lnbWFHcmFwaERhdGFGcm9tUmVuZGVyR3JhcGg7XG5leHBvcnRzLmltcG9ydFNpbXBsZUVETCA9IGltcG9ydFNpbXBsZUVETDtcbmV4cG9ydHMudmlzdWFsaXNlVmlkZW9Db250ZXh0VGltZWxpbmUgPSB2aXN1YWxpc2VWaWRlb0NvbnRleHRUaW1lbGluZTtcbmV4cG9ydHMubWVkaWFFbGVtZW50SGFzU291cmNlID0gbWVkaWFFbGVtZW50SGFzU291cmNlO1xuXG52YXIgX2RlZmluaXRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9EZWZpbml0aW9ucy9kZWZpbml0aW9ucy5qcyAqLyBcIi4vc3JjL0RlZmluaXRpb25zL2RlZmluaXRpb25zLmpzXCIpO1xuXG52YXIgX2RlZmluaXRpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluaXRpb25zKTtcblxudmFyIF9zb3VyY2Vub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Tb3VyY2VOb2Rlcy9zb3VyY2Vub2RlLmpzICovIFwiLi9zcmMvU291cmNlTm9kZXMvc291cmNlbm9kZS5qc1wiKTtcblxudmFyIF92aWRlb25vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1NvdXJjZU5vZGVzL3ZpZGVvbm9kZS5qcyAqLyBcIi4vc3JjL1NvdXJjZU5vZGVzL3ZpZGVvbm9kZS5qc1wiKTtcblxudmFyIF9jYW52YXNub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Tb3VyY2VOb2Rlcy9jYW52YXNub2RlLmpzICovIFwiLi9zcmMvU291cmNlTm9kZXMvY2FudmFzbm9kZS5qc1wiKTtcblxudmFyIF9pbWFnZW5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1NvdXJjZU5vZGVzL2ltYWdlbm9kZS5qcyAqLyBcIi4vc3JjL1NvdXJjZU5vZGVzL2ltYWdlbm9kZS5qc1wiKTtcblxudmFyIF9kZXN0aW5hdGlvbm5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0Rlc3RpbmF0aW9uTm9kZS9kZXN0aW5hdGlvbm5vZGUuanMgKi8gXCIuL3NyYy9EZXN0aW5hdGlvbk5vZGUvZGVzdGluYXRpb25ub2RlLmpzXCIpO1xuXG52YXIgX3RyYW5zaXRpb25ub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Qcm9jZXNzaW5nTm9kZXMvdHJhbnNpdGlvbm5vZGUuanMgKi8gXCIuL3NyYy9Qcm9jZXNzaW5nTm9kZXMvdHJhbnNpdGlvbm5vZGUuanNcIik7XG5cbnZhciBfY29tcG9zaXRpbmdub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Qcm9jZXNzaW5nTm9kZXMvY29tcG9zaXRpbmdub2RlLmpzICovIFwiLi9zcmMvUHJvY2Vzc2luZ05vZGVzL2NvbXBvc2l0aW5nbm9kZS5qc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLypcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY29tcGlsZSBhIFdlYkdMIFZlcnRleCBvciBGcmFnbWVudCBzaGFkZXIuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gdGhlIHdlYmdsIGNvbnRleHQgZm8gd2hpY2ggdG8gYnVpbGQgdGhlIHNoYWRlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzaGFkZXJTb3VyY2UgLSBBIHN0cmluZyBvZiBzaGFkZXIgY29kZSB0byBjb21waWxlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNoYWRlclR5cGUgLSBTaGFkZXIgdHlwZSwgZWl0aGVyIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5WRVJURVhfU0hBREVSIG9yIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5GUkFHTUVOVF9TSEFERVIuXG4gKlxuICogQHJldHVybiB7V2ViR0xTaGFkZXJ9IEEgY29tcGlsZWQgc2hhZGVyLlxuICpcbiAqL1xuZnVuY3Rpb24gY29tcGlsZVNoYWRlcihnbCwgc2hhZGVyU291cmNlLCBzaGFkZXJUeXBlKSB7XG4gICAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihzaGFkZXJUeXBlKTtcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICB2YXIgc3VjY2VzcyA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcbiAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgXCJjb3VsZCBub3QgY29tcGlsZSBzaGFkZXI6XCIgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgfVxuICAgIHJldHVybiBzaGFkZXI7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBzaGFkZXIgcHJvZ3JhbSBmcm9tIGEgcGFzc2VkIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gdGhlIHdlYmdsIGNvbnRleHQgZm8gd2hpY2ggdG8gYnVpbGQgdGhlIHNoYWRlci5cbiAqIEBwYXJhbSB7V2ViR0xTaGFkZXJ9IHZlcnRleFNoYWRlciAtIEEgY29tcGlsZWQgdmVydGV4IHNoYWRlci5cbiAqIEBwYXJhbSB7V2ViR0xTaGFkZXJ9IGZyYWdtZW50U2hhZGVyIC0gQSBjb21waWxlZCBmcmFnbWVudCBzaGFkZXIuXG4gKlxuICogQHJldHVybiB7V2ViR0xQcm9ncmFtfSBBIGNvbXBpbGVkICYgbGlua2RlIHNoYWRlciBwcm9ncmFtLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTaGFkZXJQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKSB7XG4gICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICBlcnJvcjogNCxcbiAgICAgICAgICAgIG1zZzogXCJDYW4ndCBsaW5rIHNoYWRlciBwcm9ncmFtIGZvciB0cmFja1wiLFxuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1zZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2dyYW07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUZXh0dXJlKGdsKSB7XG4gICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG4gICAgLy8gU2V0IHRoZSBwYXJhbWV0ZXJzIHNvIHdlIGNhbiByZW5kZXIgYW55IHNpemUgaW1hZ2UuXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAvL0luaXRpYWxpc2UgdGhlIHRleHR1cmUgdW50aXQgdG8gY2xlYXIuXG4gICAgLy9nbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHdpZHRoLCBoZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHR5cGUpO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRleHR1cmUoZ2wsIHRleHR1cmUsIGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5yZWFkeVN0YXRlICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudC5yZWFkeVN0YXRlID09PSAwKSByZXR1cm47XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBlbGVtZW50KTtcblxuICAgIHRleHR1cmUuX2lzVGV4dHVyZUNsZWFyZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY2xlYXJUZXh0dXJlKGdsLCB0ZXh0dXJlKSB7XG4gICAgLy8gQSBxdWljayBjaGVjayB0byBlbnN1cmUgd2UgZG9uJ3QgY2FsbCAndGV4SW1hZ2UyRCcgd2hlbiB0aGUgdGV4dHVyZSBoYXMgYWxyZWFkeSBiZWVuICdjbGVhcmVkJyAjcGVyZm9ybWFuY2VcbiAgICBpZiAoIXRleHR1cmUuX2lzVGV4dHVyZUNsZWFyZWQpIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAwXSkpO1xuXG4gICAgICAgIHRleHR1cmUuX2lzVGV4dHVyZUNsZWFyZWQgPSB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21JZCgpIHtcbiAgICB2YXIgYXBwZWFyYW5jZUFkamVjdGl2ZSA9IFtcImFkb3JhYmxlXCIsIFwiYWxlcnRcIiwgXCJhdmVyYWdlXCIsIFwiYmVhdXRpZnVsXCIsIFwiYmxvbmRlXCIsIFwiYmxvb2R5XCIsIFwiYmx1c2hpbmdcIiwgXCJicmlnaHRcIiwgXCJjbGVhblwiLCBcImNsZWFyXCIsIFwiY2xvdWR5XCIsIFwiY29sb3VyZnVsXCIsIFwiY29uY2VybmVkXCIsIFwiY3Jvd2RlZFwiLCBcImN1cmlvdXNcIiwgXCJjdXRlXCIsIFwiZGFya1wiLCBcImRpcnR5XCIsIFwiZHJhYlwiLCBcImRpc3RpbmN0XCIsIFwiZHVsbFwiLCBcImVsZWdhbnRcIiwgXCJmYW5jeVwiLCBcImZpbHRoeVwiLCBcImdsYW1vcm91c1wiLCBcImdsZWFtaW5nXCIsIFwiZ3JhY2VmdWxcIiwgXCJncm90ZXNxdWVcIiwgXCJob21lbHlcIiwgXCJsaWdodFwiLCBcIm1pc3R5XCIsIFwibW90aW9ubGVzc1wiLCBcIm11ZGR5XCIsIFwicGxhaW5cIiwgXCJwb2lzZWRcIiwgXCJxdWFpbnRcIiwgXCJzY2FyeVwiLCBcInNoaW55XCIsIFwic21vZ2d5XCIsIFwic3BhcmtsaW5nXCIsIFwic3BvdGxlc3NcIiwgXCJzdG9ybXlcIiwgXCJzdHJhbmdlXCIsIFwidWdseVwiLCBcInVuc2lnaHRseVwiLCBcInVudXN1YWxcIl07XG4gICAgdmFyIGNvbmRpdGlvbkFkamVjdGl2ZSA9IFtcImFsaXZlXCIsIFwiYnJhaW55XCIsIFwiYnJva2VuXCIsIFwiYnVzeVwiLCBcImNhcmVmdWxcIiwgXCJjYXV0aW91c1wiLCBcImNsZXZlclwiLCBcImNyYXp5XCIsIFwiZGFtYWdlZFwiLCBcImRlYWRcIiwgXCJkaWZmaWN1bHRcIiwgXCJlYXN5XCIsIFwiZmFrZVwiLCBcImZhbHNlXCIsIFwiZmFtb3VzXCIsIFwiZm9yd2FyZFwiLCBcImZyYWdpbGVcIiwgXCJndWlsdHlcIiwgXCJoZWxwZnVsXCIsIFwiaGVscGxlc3NcIiwgXCJpbXBvcnRhbnRcIiwgXCJpbXBvc3NpYmxlXCIsIFwiaW5mYW1vdXNcIiwgXCJpbm5vY2VudFwiLCBcImlucXVpc2l0aXZlXCIsIFwibWFkXCIsIFwibW9kZXJuXCIsIFwib3BlblwiLCBcIm91dGdvaW5nXCIsIFwib3V0c3RhbmRpbmdcIiwgXCJwb29yXCIsIFwicG93ZXJmdWxcIiwgXCJwdXp6bGVkXCIsIFwicmVhbFwiLCBcInJpY2hcIiwgXCJyaWdodFwiLCBcInJvYnVzdFwiLCBcInNhbmVcIiwgXCJzY2FyeVwiLCBcInNoeVwiLCBcInNsZWVweVwiLCBcInN0dXBpZFwiLCBcInN1cGVyXCIsIFwidGFtZVwiLCBcInRoaWNrXCIsIFwidGlyZWRcIiwgXCJ3aWxkXCIsIFwid3JvbmdcIl07XG4gICAgdmFyIG5vdW5BbmltYWwgPSBbXCJtYW5hdGVlXCIsIFwiZ2lsYSBtb25zdGVyXCIsIFwibmVtYXRvZGVcIiwgXCJzZWFob3JzZVwiLCBcInNsdWdcIiwgXCJrb2FsYSBiZWFyXCIsIFwiZ2lhbnQgdG9ydG9pc2VcIiwgXCJnYXJkZW4gc25haWxcIiwgXCJzdGFyZmlzaFwiLCBcInNsb3RoXCIsIFwiYW1lcmljYW4gd29vZGNvY2tcIiwgXCJjb3JhbFwiLCBcInN3YWxsb3d0YWlsIGJ1dHRlcmZseVwiLCBcImhvdXNlIHNwYXJyb3dcIiwgXCJzZWEgYW5lbW9uZVwiXTtcblxuICAgIGZ1bmN0aW9uIHJhbmRvbUNob2ljZShhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyYXlbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyYXkubGVuZ3RoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FwaXRhbGl6ZSh3b3JkKSB7XG4gICAgICAgIHdvcmQgPSB3b3JkLnJlcGxhY2UoL1xcYlxcdy9nLCBmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgcmV0dXJuIGwudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3b3JkO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gcmFuZG9tQ2hvaWNlKGFwcGVhcmFuY2VBZGplY3RpdmUpICsgXCIgXCIgKyByYW5kb21DaG9pY2UoY29uZGl0aW9uQWRqZWN0aXZlKSArIFwiIFwiICsgcmFuZG9tQ2hvaWNlKG5vdW5BbmltYWwpO1xuICAgIG5hbWUgPSBjYXBpdGFsaXplKG5hbWUpO1xuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyAvZywgXCItXCIpO1xuICAgIHJldHVybiBuYW1lO1xufVxuXG5mdW5jdGlvbiBleHBvcnRUb0pTT04odmMpIHtcbiAgICBjb25zb2xlLndhcm4oXCJWaWRlb0NvbnRleHQuZXhwb3J0VG9KU09OIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgVmlkZW9Db250ZXh0LnNuYXBzaG90IGluc3RlYWQuXCIpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzbmFwc2hvdE5vZGVzKHZjKSk7XG59XG5cbmZ1bmN0aW9uIHNuYXBzaG90KHZjKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZXM6IHNuYXBzaG90Tm9kZXModmMpLFxuICAgICAgICB2aWRlb0NvbnRleHQ6IHNuYXBzaG90VmlkZW9Db250ZXh0KHZjKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNuYXBzaG90VmlkZW9Db250ZXh0KHZjKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudFRpbWU6IHZjLmN1cnJlbnRUaW1lLFxuICAgICAgICBkdXJhdGlvbjogdmMuZHVyYXRpb24sXG4gICAgICAgIHN0YXRlOiB2Yy5zdGF0ZSxcbiAgICAgICAgcGxheWJhY2tSYXRlOiB2Yy5wbGF5YmFja1JhdGVcbiAgICB9O1xufVxuXG52YXIgd2FybmluZ0V4cG9ydFNvdXJjZUxvZ2dlZCA9IGZhbHNlO1xuZnVuY3Rpb24gc25hcHNob3ROb2Rlcyh2Yykge1xuICAgIGZ1bmN0aW9uIHF1YWxpZnlVUkwodXJsKSB7XG4gICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIGEuaHJlZiA9IHVybDtcbiAgICAgICAgcmV0dXJuIGEuaHJlZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbnB1dElEcyhub2RlLCB2Yykge1xuICAgICAgICB2YXIgaW5wdXRzID0gW107XG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gbm9kZS5pbnB1dHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0SUQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0SW5kZXggPSBub2RlLmlucHV0cy5pbmRleE9mKGlucHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB2Yy5fcHJvY2Vzc2luZ05vZGVzLmluZGV4T2YoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0SUQgPSBcInByb2Nlc3NvclwiICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pbmRleCA9IHZjLl9zb3VyY2VOb2Rlcy5pbmRleE9mKGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dElEID0gXCJzb3VyY2VcIiArIF9pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgY2FuJ3QgZmluZCBpbnB1dFwiLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5wdXRzLnB1c2goeyBpZDogaW5wdXRJRCwgaW5kZXg6IGlucHV0SW5kZXggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIHZhciBzb3VyY2VOb2RlU3RhdGVNYXBwaW5nID0gW107XG4gICAgZm9yICh2YXIgc3RhdGUgaW4gX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFKSB7XG4gICAgICAgIHNvdXJjZU5vZGVTdGF0ZU1hcHBpbmdbX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFW3N0YXRlXV0gPSBzdGF0ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpbmRleCBpbiB2Yy5fc291cmNlTm9kZXMpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHZjLl9zb3VyY2VOb2Rlc1tpbmRleF07XG4gICAgICAgIHZhciBpZCA9IFwic291cmNlXCIgKyBpbmRleDtcbiAgICAgICAgdmFyIG5vZGVfdXJsID0gXCJcIjtcblxuICAgICAgICBpZiAoIXNvdXJjZS5faXNSZXNwb25zaWJsZUZvckVsZW1lbnRMaWZlQ3ljbGUpIHtcbiAgICAgICAgICAgIGlmICghd2FybmluZ0V4cG9ydFNvdXJjZUxvZ2dlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJXYXJuaW5nIC0gVHJ5aW5nIHRvIGV4cG9ydCBzb3VyY2UgY3JlYXRlZCBmcm9tIGFuIGVsZW1lbnQgbm90IGEgVVJMLiBVUkwgb2YgZXhwb3J0IHdpbGwgYmUgc2V0IHRvIHRoZSBlbGVtZW50cyBzcmMgYXR0cmlidXRlIGFuZCBtYXkgYmUgaW5jb3JyZWN0XCIsIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgd2FybmluZ0V4cG9ydFNvdXJjZUxvZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlX3VybCA9IHNvdXJjZS5lbGVtZW50LnNyYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVfdXJsID0gcXVhbGlmeVVSTChzb3VyY2UuX2VsZW1lbnRVUkwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiBzb3VyY2UuZGlzcGxheU5hbWUsXG4gICAgICAgICAgICB1cmw6IG5vZGVfdXJsLFxuICAgICAgICAgICAgc3RhcnQ6IHNvdXJjZS5zdGFydFRpbWUsXG4gICAgICAgICAgICBzdG9wOiBzb3VyY2Uuc3RvcFRpbWUsXG4gICAgICAgICAgICBzdGF0ZTogc291cmNlTm9kZVN0YXRlTWFwcGluZ1tzb3VyY2Uuc3RhdGVdXG4gICAgICAgIH07XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IF92aWRlb25vZGUuVklERU9UWVBFKSB7XG4gICAgICAgICAgICBub2RlLmN1cnJlbnRUaW1lID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuZWxlbWVudCAmJiBzb3VyY2UuZWxlbWVudC5jdXJyZW50VGltZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuY3VycmVudFRpbWUgPSBzb3VyY2UuZWxlbWVudC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3VyY2UuX3NvdXJjZU9mZnNldCkge1xuICAgICAgICAgICAgbm9kZS5zb3VyY2VPZmZzZXQgPSBzb3VyY2UuX3NvdXJjZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbaWRdID0gbm9kZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaW5kZXgyIGluIHZjLl9wcm9jZXNzaW5nTm9kZXMpIHtcbiAgICAgICAgdmFyIHByb2Nlc3NvciA9IHZjLl9wcm9jZXNzaW5nTm9kZXNbX2luZGV4Ml07XG4gICAgICAgIHZhciBfaWQgPSBcInByb2Nlc3NvclwiICsgX2luZGV4MjtcbiAgICAgICAgdmFyIF9ub2RlID0ge1xuICAgICAgICAgICAgdHlwZTogcHJvY2Vzc29yLmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogcHJvY2Vzc29yLl9kZWZpbml0aW9uLFxuICAgICAgICAgICAgaW5wdXRzOiBnZXRJbnB1dElEcyhwcm9jZXNzb3IsIHZjKSxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gX25vZGUuZGVmaW5pdGlvbi5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBfbm9kZS5wcm9wZXJ0aWVzW3Byb3BlcnR5XSA9IHByb2Nlc3Nvcltwcm9wZXJ0eV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX25vZGUudHlwZSA9PT0gX3RyYW5zaXRpb25ub2RlLlRSQU5TSVRJT05UWVBFKSB7XG4gICAgICAgICAgICBfbm9kZS50cmFuc2l0aW9ucyA9IHByb2Nlc3Nvci5fdHJhbnNpdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRbX2lkXSA9IF9ub2RlO1xuICAgIH1cblxuICAgIHJlc3VsdFtcImRlc3RpbmF0aW9uXCJdID0ge1xuICAgICAgICB0eXBlOiBcIkRlc3RpbmF0aW9uXCIsXG4gICAgICAgIGlucHV0czogZ2V0SW5wdXRJRHModmMuZGVzdGluYXRpb24sIHZjKVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250cm9sRm9ybUZvck5vZGUobm9kZSwgbm9kZU5hbWUpIHtcbiAgICB2YXIgcm9vdERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICBpZiAobm9kZU5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDJcIik7XG4gICAgICAgIHRpdGxlLmlubmVySFRNTCA9IG5vZGVOYW1lO1xuICAgICAgICByb290RGl2LmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICB9XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgdmFyIHByb3BlcnR5UGFyYWdyYXBoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICAgIHZhciBwcm9wZXJ0eVRpdGxlSGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgzXCIpO1xuICAgICAgICBwcm9wZXJ0eVRpdGxlSGVhZGVyLmlubmVySFRNTCA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgcHJvcGVydHlQYXJhZ3JhcGguYXBwZW5kQ2hpbGQocHJvcGVydHlUaXRsZUhlYWRlcik7XG5cbiAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBub2RlLl9wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0udmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHlWYWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInJhbmdlXCIpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgIHJhbmdlLnNldEF0dHJpYnV0ZShcIm1heFwiLCBcIjFcIik7XG4gICAgICAgICAgICByYW5nZS5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsIFwiMC4wMVwiKTtcbiAgICAgICAgICAgIHJhbmdlLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHByb3BlcnR5VmFsdWUsIHRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgbnVtYmVyLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJudW1iZXJcIik7XG4gICAgICAgICAgICBudW1iZXIuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgIG51bWJlci5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgXCIxXCIpO1xuICAgICAgICAgICAgbnVtYmVyLnNldEF0dHJpYnV0ZShcInN0ZXBcIiwgXCIwLjAxXCIpO1xuICAgICAgICAgICAgbnVtYmVyLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHByb3BlcnR5VmFsdWUsIHRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgICB2YXIgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgICAgICByYW5nZS5vbm1vdXNlZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJhbmdlLm9ubW91c2V1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByYW5nZS5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobW91c2VEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHBhcnNlRmxvYXQocmFuZ2UudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBudW1iZXIudmFsdWUgPSByYW5nZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gcGFyc2VGbG9hdChyYW5nZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgbnVtYmVyLnZhbHVlID0gcmFuZ2UudmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbnVtYmVyLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHBhcnNlRmxvYXQobnVtYmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByYW5nZS52YWx1ZSA9IG51bWJlci52YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcm9wZXJ0eVBhcmFncmFwaC5hcHBlbmRDaGlsZChyYW5nZSk7XG4gICAgICAgICAgICBwcm9wZXJ0eVBhcmFncmFwaC5hcHBlbmRDaGlsZChudW1iZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9wZXJ0eVZhbHVlKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKCkge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwicmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgXCIxXCIpO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldEF0dHJpYnV0ZShcInN0ZXBcIiwgXCIwLjAxXCIpO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHByb3BlcnR5VmFsdWVbaV0sIHRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG51bWJlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBudW1iZXIuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgICAgICAgICBudW1iZXIuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICBudW1iZXIuc2V0QXR0cmlidXRlKFwibWF4XCIsIFwiMVwiKTtcbiAgICAgICAgICAgICAgICBudW1iZXIuc2V0QXR0cmlidXRlKFwic3RlcFwiLCBcIjAuMDFcIik7XG4gICAgICAgICAgICAgICAgbnVtYmVyLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHByb3BlcnR5VmFsdWUsIHRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB2YXIgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmFuZ2Uub25tb3VzZWRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByYW5nZS5vbm1vdXNldXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmFuZ2Uub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3VzZURvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbcHJvcGVydHlOYW1lXVtpbmRleF0gPSBwYXJzZUZsb2F0KHJhbmdlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlci52YWx1ZSA9IHJhbmdlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdW2luZGV4XSA9IHBhcnNlRmxvYXQocmFuZ2UudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBudW1iZXIudmFsdWUgPSByYW5nZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbnVtYmVyLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlW3Byb3BlcnR5TmFtZV1baW5kZXhdID0gcGFyc2VGbG9hdChudW1iZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS52YWx1ZSA9IG51bWJlci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHByb3BlcnR5UGFyYWdyYXBoLmFwcGVuZENoaWxkKHJhbmdlKTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eVBhcmFncmFwaC5hcHBlbmRDaGlsZChudW1iZXIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnR5VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcDIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3REaXYuYXBwZW5kQ2hpbGQocHJvcGVydHlQYXJhZ3JhcGgpO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gbm9kZS5fcHJvcGVydGllcykge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBfbG9vcChwcm9wZXJ0eU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdERpdjtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTm9kZURlcHRoRnJvbURlc3RpbmF0aW9uKHZpZGVvQ29udGV4dCkge1xuICAgIHZhciBkZXN0aW5hdGlvbiA9IHZpZGVvQ29udGV4dC5kZXN0aW5hdGlvbjtcbiAgICB2YXIgZGVwdGhNYXAgPSBuZXcgTWFwKCk7XG4gICAgZGVwdGhNYXAuc2V0KGRlc3RpbmF0aW9uLCAwKTtcblxuICAgIGZ1bmN0aW9uIGl0dGVyYXRlQmFja3dhcmRzKG5vZGUpIHtcbiAgICAgICAgdmFyIGRlcHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBub2RlLmlucHV0c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkZXB0aCArIDE7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoTWFwLmhhcyhuKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZCA+IGRlcHRoTWFwLmdldChuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGhNYXAuc2V0KG4sIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGhNYXAuc2V0KG4sIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdHRlcmF0ZUJhY2t3YXJkcyhuLCBkZXB0aE1hcC5nZXQobikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGl0dGVyYXRlQmFja3dhcmRzKGRlc3RpbmF0aW9uKTtcbiAgICByZXR1cm4gZGVwdGhNYXA7XG59XG5cbmZ1bmN0aW9uIHZpc3VhbGlzZVZpZGVvQ29udGV4dEdyYXBoKHZpZGVvQ29udGV4dCwgY2FudmFzKSB7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgdmFyIHcgPSBjYW52YXMud2lkdGg7XG4gICAgdmFyIGggPSBjYW52YXMuaGVpZ2h0O1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG5cbiAgICB2YXIgbm9kZURlcHRocyA9IGNhbGN1bGF0ZU5vZGVEZXB0aEZyb21EZXN0aW5hdGlvbih2aWRlb0NvbnRleHQpO1xuICAgIHZhciBkZXB0aHMgPSBub2RlRGVwdGhzLnZhbHVlcygpO1xuICAgIGRlcHRocyA9IEFycmF5LmZyb20oZGVwdGhzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBiIC0gYTtcbiAgICB9KTtcbiAgICB2YXIgbWF4RGVwdGggPSBkZXB0aHNbMF07XG5cbiAgICB2YXIgeFN0ZXAgPSB3IC8gKG1heERlcHRoICsgMSk7XG5cbiAgICB2YXIgbm9kZUhlaWdodCA9IGggLyB2aWRlb0NvbnRleHQuX3NvdXJjZU5vZGVzLmxlbmd0aCAvIDM7XG4gICAgdmFyIG5vZGVXaWR0aCA9IG5vZGVIZWlnaHQgKiAxLjYxODtcblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU5vZGVQb3Mobm9kZSwgbm9kZURlcHRocywgeFN0ZXAsIG5vZGVIZWlnaHQpIHtcbiAgICAgICAgdmFyIGRlcHRoID0gbm9kZURlcHRocy5nZXQobm9kZSk7XG4gICAgICAgIG5vZGVEZXB0aHMudmFsdWVzKCk7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gbm9kZURlcHRoc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlRGVwdGggPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZURlcHRoWzBdID09PSBub2RlKSBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAobm9kZURlcHRoWzFdID09PSBkZXB0aCkgY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeFN0ZXAgKiBub2RlRGVwdGhzLmdldChub2RlKSxcbiAgICAgICAgICAgIHk6IG5vZGVIZWlnaHQgKiAxLjUgKiBjb3VudCArIDUwXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gXCJ2aWRlb1wiOltcIiM1NzJBNzJcIiwgXCIjM0MxMjU1XCJdLFxuICAgIC8vIFwiaW1hZ2VcIjpbXCIjN0Q5RjM1XCIsIFwiIzU3NzcxNFwiXSxcbiAgICAvLyBcImNhbnZhc1wiOltcIiNBQTk2MzlcIiwgXCIjODA2RDE1XCJdXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZGVvQ29udGV4dC5fcmVuZGVyR3JhcGguY29ubmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbm4gPSB2aWRlb0NvbnRleHQuX3JlbmRlckdyYXBoLmNvbm5lY3Rpb25zW2ldO1xuICAgICAgICB2YXIgc291cmNlID0gY2FsY3VsYXRlTm9kZVBvcyhjb25uLnNvdXJjZSwgbm9kZURlcHRocywgeFN0ZXAsIG5vZGVIZWlnaHQpO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSBjYWxjdWxhdGVOb2RlUG9zKGNvbm4uZGVzdGluYXRpb24sIG5vZGVEZXB0aHMsIHhTdGVwLCBub2RlSGVpZ2h0KTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIGRlc3RpbmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIC8vY3R4Lm1vdmVUbyhzb3VyY2UueCArIG5vZGVXaWR0aC8yLCBzb3VyY2UueSArIG5vZGVIZWlnaHQvMik7XG4gICAgICAgICAgICB2YXIgeDEgPSBzb3VyY2UueCArIG5vZGVXaWR0aCAvIDI7XG4gICAgICAgICAgICB2YXIgeTEgPSBzb3VyY2UueSArIG5vZGVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgdmFyIHgyID0gZGVzdGluYXRpb24ueCArIG5vZGVXaWR0aCAvIDI7XG4gICAgICAgICAgICB2YXIgeTIgPSBkZXN0aW5hdGlvbi55ICsgbm9kZUhlaWdodCAvIDI7XG4gICAgICAgICAgICB2YXIgZHggPSB4MiAtIHgxO1xuICAgICAgICAgICAgdmFyIGR5ID0geTIgLSB5MTtcblxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5QSSAvIDIgLSBNYXRoLmF0YW4yKGR4LCBkeSk7XG5cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcblxuICAgICAgICAgICAgdmFyIG1pZFggPSBNYXRoLm1pbih4MSwgeDIpICsgKE1hdGgubWF4KHgxLCB4MikgLSBNYXRoLm1pbih4MSwgeDIpKSAvIDI7XG4gICAgICAgICAgICB2YXIgbWlkWSA9IE1hdGgubWluKHkxLCB5MikgKyAoTWF0aC5tYXgoeTEsIHkyKSAtIE1hdGgubWluKHkxLCB5MikpIC8gMjtcblxuICAgICAgICAgICAgdmFyIHRlc3RYID0gTWF0aC5jb3MoYW5nbGUgKyBNYXRoLlBJIC8gMikgKiBkaXN0YW5jZSAvIDEuNSArIG1pZFg7XG4gICAgICAgICAgICB2YXIgdGVzdFkgPSBNYXRoLnNpbihhbmdsZSArIE1hdGguUEkgLyAyKSAqIGRpc3RhbmNlIC8gMS41ICsgbWlkWTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRlc3RYLCB0ZXN0WSk7XG5cbiAgICAgICAgICAgIGN0eC5hcmModGVzdFgsIHRlc3RZLCBkaXN0YW5jZSAvIDEuMiwgYW5nbGUgLSBNYXRoLlBJICsgMC45NSwgYW5nbGUgLSAwLjk1KTtcblxuICAgICAgICAgICAgLy9jdHguYXJjVG8oc291cmNlLnggKyBub2RlV2lkdGgvMiAsc291cmNlLnkgKyBub2RlSGVpZ2h0LzIsZGVzdGluYXRpb24ueCArIG5vZGVXaWR0aC8yLGRlc3RpbmF0aW9uLnkgKyBub2RlSGVpZ2h0LzIsMTAwKTtcbiAgICAgICAgICAgIC8vY3R4LmxpbmVUbyhtaWRYLCBtaWRZKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIC8vY3R4LmVuZFBhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gbm9kZURlcHRocy5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgcG9zID0gY2FsY3VsYXRlTm9kZVBvcyhub2RlLCBub2RlRGVwdGhzLCB4U3RlcCwgbm9kZUhlaWdodCk7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBcIiNBQTk2MzlcIjtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChub2RlLmRpc3BsYXlOYW1lID09PSBfY29tcG9zaXRpbmdub2RlLkNPTVBPU0lUSU5HVFlQRSkge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gXCIjMDAwMDAwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5kaXNwbGF5TmFtZSA9PT0gX2Rlc3RpbmF0aW9ubm9kZS5ERVNUSU5BVElPTlRZUEUpIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IFwiIzdEOUYzNVwiO1xuICAgICAgICAgICAgICAgIHRleHQgPSBcIk91dHB1dFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuZGlzcGxheU5hbWUgPT09IF92aWRlb25vZGUuVklERU9UWVBFKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBcIiM1NzJBNzJcIjtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gXCJWaWRlb1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuZGlzcGxheU5hbWUgPT09IF9jYW52YXNub2RlLkNBTlZBU1RZUEUpIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IFwiIzU3MkE3MlwiO1xuICAgICAgICAgICAgICAgIHRleHQgPSBcIkNhbnZhc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuZGlzcGxheU5hbWUgPT09IF9pbWFnZW5vZGUuSU1BR0VUWVBFKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBcIiM1NzJBNzJcIjtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gXCJJbWFnZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHBvcy54LCBwb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiMwMDBcIjtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBcIjEwcHggQXJpYWxcIjtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBwb3MueCArIG5vZGVXaWR0aCAvIDIsIHBvcy55ICsgbm9kZUhlaWdodCAvIDIgKyAyLjUpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjQgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgJiYgX2l0ZXJhdG9yNC5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3I0LnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNCkge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2lnbWFHcmFwaERhdGFGcm9tUmVuZGVyR3JhcGgodmlkZW9Db250ZXh0KSB7XG4gICAgZnVuY3Rpb24gaWRGb3JOb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKHZpZGVvQ29udGV4dC5fc291cmNlTm9kZXMuaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBfaWQyID0gXCJzb3VyY2UgXCIgKyBub2RlLmRpc3BsYXlOYW1lICsgXCIgXCIgKyB2aWRlb0NvbnRleHQuX3NvdXJjZU5vZGVzLmluZGV4T2Yobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gX2lkMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWQgPSBcInByb2Nlc3NvciBcIiArIG5vZGUuZGlzcGxheU5hbWUgKyBcIiBcIiArIHZpZGVvQ29udGV4dC5fcHJvY2Vzc2luZ05vZGVzLmluZGV4T2Yobm9kZSk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICB2YXIgZ3JhcGggPSB7XG4gICAgICAgIG5vZGVzOiBbe1xuICAgICAgICAgICAgaWQ6IGlkRm9yTm9kZSh2aWRlb0NvbnRleHQuZGVzdGluYXRpb24pLFxuICAgICAgICAgICAgbGFiZWw6IFwiRGVzdGluYXRpb24gTm9kZVwiLFxuICAgICAgICAgICAgeDogMi41LFxuICAgICAgICAgICAgeTogMC41LFxuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIG5vZGU6IHZpZGVvQ29udGV4dC5kZXN0aW5hdGlvblxuICAgICAgICB9XSxcbiAgICAgICAgZWRnZXM6IFtdXG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlkZW9Db250ZXh0Ll9zb3VyY2VOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlTm9kZSA9IHZpZGVvQ29udGV4dC5fc291cmNlTm9kZXNbaV07XG4gICAgICAgIHZhciB5ID0gaSAqICgxLjAgLyB2aWRlb0NvbnRleHQuX3NvdXJjZU5vZGVzLmxlbmd0aCk7XG4gICAgICAgIGdyYXBoLm5vZGVzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IGlkRm9yTm9kZShzb3VyY2VOb2RlKSxcbiAgICAgICAgICAgIGxhYmVsOiBcIlNvdXJjZSBcIiArIGkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIGNvbG9yOiBcIiM1NzJBNzJcIixcbiAgICAgICAgICAgIG5vZGU6IHNvdXJjZU5vZGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB2aWRlb0NvbnRleHQuX3Byb2Nlc3NpbmdOb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHByb2Nlc3NpbmdOb2RlID0gdmlkZW9Db250ZXh0Ll9wcm9jZXNzaW5nTm9kZXNbX2ldO1xuICAgICAgICBncmFwaC5ub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBpZEZvck5vZGUocHJvY2Vzc2luZ05vZGUpLFxuICAgICAgICAgICAgeDogTWF0aC5yYW5kb20oKSAqIDIuNSxcbiAgICAgICAgICAgIHk6IE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgbm9kZTogcHJvY2Vzc2luZ05vZGVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdmlkZW9Db250ZXh0Ll9yZW5kZXJHcmFwaC5jb25uZWN0aW9ucy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBjb25uID0gdmlkZW9Db250ZXh0Ll9yZW5kZXJHcmFwaC5jb25uZWN0aW9uc1tfaTJdO1xuICAgICAgICBncmFwaC5lZGdlcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBcImVcIiArIF9pMi50b1N0cmluZygpLFxuICAgICAgICAgICAgc291cmNlOiBpZEZvck5vZGUoY29ubi5zb3VyY2UpLFxuICAgICAgICAgICAgdGFyZ2V0OiBpZEZvck5vZGUoY29ubi5kZXN0aW5hdGlvbilcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyYXBoO1xufVxuXG5mdW5jdGlvbiBpbXBvcnRTaW1wbGVFREwoY3R4LCBwbGF5bGlzdCkge1xuICAgIC8vIENyZWF0ZSBhIFwidHJhY2tcIiBub2RlIHRvIGNvbm5lY3QgYWxsIHRoZSBjbGlwcyB0by5cbiAgICB2YXIgdHJhY2tOb2RlID0gY3R4LmNvbXBvc2l0b3IoX2RlZmluaXRpb25zMi5kZWZhdWx0LkNPTUJJTkUpO1xuXG4gICAgLy8gQ3JlYXRlIGEgc291cmNlIG5vZGUgZm9yIGVhY2ggb2YgdGhlIGNsaXBzLlxuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvcjUgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I1ID0gcGxheWxpc3RbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDU7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSAoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBjbGlwID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChjbGlwLnR5cGUgPT09IFwidmlkZW9cIikge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBjdHgudmlkZW8oY2xpcC5zcmMsIGNsaXAuc291cmNlU3RhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGlwLnR5cGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBjdHguaW1hZ2UoY2xpcC5zcmMsIGNsaXAuc291cmNlU3RhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiQ2xpcCB0eXBlIFwiICsgY2xpcC50eXBlICsgXCIgbm90IHJlY29nbmlzZWQsIHNraXBwaW5nLlwiKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuc3RhcnRBdChjbGlwLnN0YXJ0KTtcbiAgICAgICAgICAgIG5vZGUuc3RvcEF0KGNsaXAuc3RhcnQgKyBjbGlwLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIG5vZGUuY29ubmVjdCh0cmFja05vZGUpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yNSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSAmJiBfaXRlcmF0b3I1LnJldHVybikge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYWNrTm9kZTtcbn1cblxuZnVuY3Rpb24gdmlzdWFsaXNlVmlkZW9Db250ZXh0VGltZWxpbmUodmlkZW9Db250ZXh0LCBjYW52YXMsIGN1cnJlbnRUaW1lKSB7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgdmFyIHcgPSBjYW52YXMud2lkdGg7XG4gICAgdmFyIGggPSBjYW52YXMuaGVpZ2h0O1xuICAgIHZhciB0cmFja0hlaWdodCA9IGggLyB2aWRlb0NvbnRleHQuX3NvdXJjZU5vZGVzLmxlbmd0aDtcbiAgICB2YXIgcGxheWxpc3REdXJhdGlvbiA9IHZpZGVvQ29udGV4dC5kdXJhdGlvbjtcblxuICAgIGlmIChjdXJyZW50VGltZSA+IHBsYXlsaXN0RHVyYXRpb24gJiYgIXZpZGVvQ29udGV4dC5lbmRPbkxhc3RTb3VyY2VFbmQpIHBsYXlsaXN0RHVyYXRpb24gPSBjdXJyZW50VGltZTtcblxuICAgIGlmICh2aWRlb0NvbnRleHQuZHVyYXRpb24gPT09IEluZmluaXR5KSB7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlkZW9Db250ZXh0Ll9zb3VyY2VOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZU5vZGUgPSB2aWRlb0NvbnRleHQuX3NvdXJjZU5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHNvdXJjZU5vZGUuX3N0b3BUaW1lICE9PSBJbmZpbml0eSkgdG90YWwgKz0gc291cmNlTm9kZS5fc3RvcFRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG90YWwgPiB2aWRlb0NvbnRleHQuY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgIHBsYXlsaXN0RHVyYXRpb24gPSB0b3RhbCArIDU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwbGF5bGlzdER1cmF0aW9uID0gdmlkZW9Db250ZXh0LmN1cnJlbnRUaW1lICsgNTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcGl4ZWxzUGVyU2Vjb25kID0gdyAvIHBsYXlsaXN0RHVyYXRpb247XG4gICAgdmFyIG1lZGlhU291cmNlU3R5bGUgPSB7XG4gICAgICAgIHZpZGVvOiBbXCIjNTcyQTcyXCIsIFwiIzNDMTI1NVwiXSxcbiAgICAgICAgaW1hZ2U6IFtcIiM3RDlGMzVcIiwgXCIjNTc3NzE0XCJdLFxuICAgICAgICBjYW52YXM6IFtcIiNBQTk2MzlcIiwgXCIjODA2RDE1XCJdXG4gICAgfTtcblxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IFwiIzk5OVwiO1xuXG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZTtcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yNiA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjYgPSB2aWRlb0NvbnRleHQuX3Byb2Nlc3NpbmdOb2Rlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IChfc3RlcDYgPSBfaXRlcmF0b3I2Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBfc3RlcDYudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmRpc3BsYXlOYW1lICE9PSBfdHJhbnNpdGlvbm5vZGUuVFJBTlNJVElPTlRZUEUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIG5vZGUuX3RyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I3ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjcgPSBub2RlLl90cmFuc2l0aW9uc1twcm9wZXJ0eU5hbWVdW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA3OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gKF9zdGVwNyA9IF9pdGVyYXRvcjcubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IF9zdGVwNy52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRXID0gKHRyYW5zaXRpb24uZW5kIC0gdHJhbnNpdGlvbi5zdGFydCkgKiBwaXhlbHNQZXJTZWNvbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdEggPSBoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRYID0gdHJhbnNpdGlvbi5zdGFydCAqIHBpeGVsc1BlclNlY29uZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0WSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsMCwwLCAwLjMpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QodFgsIHRZLCB0VywgdEgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjcgPSBlcnI7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgJiYgX2l0ZXJhdG9yNy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3I3LnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjYgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjYgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgJiYgX2l0ZXJhdG9yNi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3I2LnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHZpZGVvQ29udGV4dC5fc291cmNlTm9kZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICB2YXIgX3NvdXJjZU5vZGUgPSB2aWRlb0NvbnRleHQuX3NvdXJjZU5vZGVzW19pM107XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IF9zb3VyY2VOb2RlLl9zdG9wVGltZSAtIF9zb3VyY2VOb2RlLl9zdGFydFRpbWU7XG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gSW5maW5pdHkpIGR1cmF0aW9uID0gdmlkZW9Db250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgc3RhcnQgPSBfc291cmNlTm9kZS5fc3RhcnRUaW1lO1xuXG4gICAgICAgIHZhciBtc1cgPSBkdXJhdGlvbiAqIHBpeGVsc1BlclNlY29uZDtcbiAgICAgICAgdmFyIG1zSCA9IHRyYWNrSGVpZ2h0O1xuICAgICAgICB2YXIgbXNYID0gc3RhcnQgKiBwaXhlbHNQZXJTZWNvbmQ7XG4gICAgICAgIHZhciBtc1kgPSB0cmFja0hlaWdodCAqIF9pMztcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG1lZGlhU291cmNlU3R5bGUudmlkZW9bX2kzICUgbWVkaWFTb3VyY2VTdHlsZS52aWRlby5sZW5ndGhdO1xuXG4gICAgICAgIGN0eC5maWxsUmVjdChtc1gsIG1zWSwgbXNXLCBtc0gpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50VGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiMwMDBcIjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGN1cnJlbnRUaW1lICogcGl4ZWxzUGVyU2Vjb25kLCAwLCAxLCBoKTtcbiAgICB9XG59XG5cbnZhciBVcGRhdGVhYmxlc01hbmFnZXIgPSBleHBvcnRzLlVwZGF0ZWFibGVzTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcGRhdGVhYmxlc01hbmFnZXIoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVcGRhdGVhYmxlc01hbmFnZXIpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZWFibGVzID0gW107XG4gICAgICAgIHRoaXMuX3VzZVdlYndvcmtlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNSQUZUaW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9wcmV2aW91c1dvcmtlclRpbWUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy5fd2ViV29ya2VyU3RyaW5nID0gXCJcXFxuICAgICAgICAgICAgdmFyIHJ1bm5pbmcgPSBmYWxzZTtcXFxuICAgICAgICAgICAgZnVuY3Rpb24gdGljaygpe1xcXG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoRGF0ZS5ub3coKSk7XFxcbiAgICAgICAgICAgICAgICBpZiAocnVubmluZyl7XFxcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCh0aWNrLCAxMDAwLzIwKTtcXFxuICAgICAgICAgICAgICAgIH1cXFxuICAgICAgICAgICAgfVxcXG4gICAgICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLGZ1bmN0aW9uKG1zZyl7XFxcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG1zZy5kYXRhO1xcXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09ICdzdGFydCcpe1xcXG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSB0cnVlO1xcXG4gICAgICAgICAgICAgICAgICAgIHRpY2soKTtcXFxuICAgICAgICAgICAgICAgIH1cXFxuICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSAnc3RvcCcpIHJ1bm5pbmcgPSBmYWxzZTtcXFxuICAgICAgICAgICAgfSk7XCI7XG4gICAgICAgIHRoaXMuX3dlYldvcmtlciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVXBkYXRlYWJsZXNNYW5hZ2VyLCBbe1xuICAgICAgICBrZXk6IFwiX2luaXRXZWJXb3JrZXJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0V2ViV29ya2VyKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgd2luZG93LlVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcbiAgICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW3RoaXMuX3dlYldvcmtlclN0cmluZ10sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl93ZWJXb3JrZXIgPSBuZXcgV29ya2VyKFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYikpO1xuICAgICAgICAgICAgdGhpcy5fd2ViV29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZSA9IG1zZy5kYXRhO1xuICAgICAgICAgICAgICAgIF90aGlzLl91cGRhdGVXb3JrZXJUaW1lKHRpbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9sb3N0VmlzaWJpbGl0eVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvc3RWaXNpYmlsaXR5KCkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNXb3JrZXJUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMuX3VzZVdlYndvcmtlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlYldvcmtlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRXZWJXb3JrZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3dlYldvcmtlci5wb3N0TWVzc2FnZShcInN0YXJ0XCIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiX2dhaW5lZFZpc2liaWxpdHlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nYWluZWRWaXNpYmlsaXR5KCkge1xuICAgICAgICAgICAgdGhpcy5fdXNlV2Vid29ya2VyID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1JBRlRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fd2ViV29ya2VyKSB0aGlzLl93ZWJXb3JrZXIucG9zdE1lc3NhZ2UoXCJzdG9wXCIpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3VwZGF0ZVJBRlRpbWUuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfaW5pdFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKCF3aW5kb3cuV29ya2VyKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vSWYgcGFnZSB2aXNpYmlsaXR5IEFQSSBub3QgcHJlc2VudCBmYWxsYmFjayB0byB1c2luZyBcImZvY3VzXCIgYW5kIFwiYmx1clwiIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuaGlkZGVuID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9nYWluZWRWaXNpYmlsaXR5LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9sb3N0VmlzaWJpbGl0eS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL090aGVyd2lzZSB3ZSBjYW4gdXNlIHRoZSB2aXNpYmlsaXR5IEFQSSB0byBkbyB0aGUgbG9vc2UvZ2FpbiBmb2N1cyBwcm9wZXJseVxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLl9sb3N0VmlzaWJpbGl0eSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi5fZ2FpbmVkVmlzaWJpbGl0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3VwZGF0ZVJBRlRpbWUuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfdXBkYXRlV29ya2VyVGltZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVdvcmtlclRpbWUodGltZSkge1xuICAgICAgICAgICAgdmFyIGR0ID0gKHRpbWUgLSB0aGlzLl9wcmV2aW91c1dvcmtlclRpbWUpIC8gMTAwMDtcbiAgICAgICAgICAgIGlmIChkdCAhPT0gMCkgdGhpcy5fdXBkYXRlKGR0KTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzV29ya2VyVGltZSA9IHRpbWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfdXBkYXRlUkFGVGltZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVJBRlRpbWUodGltZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzUkFGVGltZSA9PT0gdW5kZWZpbmVkKSB0aGlzLl9wcmV2aW91c1JBRlRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgdmFyIGR0ID0gKHRpbWUgLSB0aGlzLl9wcmV2aW91c1JBRlRpbWUpIC8gMTAwMDtcbiAgICAgICAgICAgIGlmIChkdCAhPT0gMCkgdGhpcy5fdXBkYXRlKGR0KTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzUkFGVGltZSA9IHRpbWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3VzZVdlYndvcmtlcikgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3VwZGF0ZVJBRlRpbWUuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKGR0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3VwZGF0ZWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlYWJsZXNbaV0uX3VwZGF0ZShwYXJzZUZsb2F0KGR0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJyZWdpc3RlclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIodXBkYXRlYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlYWJsZXMucHVzaCh1cGRhdGVhYmxlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVXBkYXRlYWJsZXNNYW5hZ2VyO1xufSgpO1xuXG5mdW5jdGlvbiBtZWRpYUVsZW1lbnRIYXNTb3VyY2UoX3JlZikge1xuICAgIHZhciBzcmMgPSBfcmVmLnNyYyxcbiAgICAgICAgc3JjT2JqZWN0ID0gX3JlZi5zcmNPYmplY3Q7XG5cbiAgICByZXR1cm4gISgoc3JjID09PSBcIlwiIHx8IHNyYyA9PT0gdW5kZWZpbmVkKSAmJiBzcmNPYmplY3QgPT0gbnVsbCk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3ZpZGVvY29udGV4dC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdmlkZW9jb250ZXh0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7IC8vTWF0dGhldyBTaG90dG9uLCBSJkQgVXNlciBFeHBlcmllbmNlLMKpIEJCQyAyMDE1XG5cblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMuanMgKi8gXCIuL3NyYy91dGlscy5qc1wiKTtcblxudmFyIF9ub2RlcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vU291cmNlTm9kZXMvbm9kZXMuanMgKi8gXCIuL3NyYy9Tb3VyY2VOb2Rlcy9ub2Rlcy5qc1wiKTtcblxudmFyIF9ub2RlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2Rlcyk7XG5cbnZhciBfdmlkZW9ub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Tb3VyY2VOb2Rlcy92aWRlb25vZGUuanMgKi8gXCIuL3NyYy9Tb3VyY2VOb2Rlcy92aWRlb25vZGUuanNcIik7XG5cbnZhciBfdmlkZW9ub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvbm9kZSk7XG5cbnZhciBfYXVkaW9ub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Tb3VyY2VOb2Rlcy9hdWRpb25vZGUuanMgKi8gXCIuL3NyYy9Tb3VyY2VOb2Rlcy9hdWRpb25vZGUuanNcIik7XG5cbnZhciBfYXVkaW9ub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F1ZGlvbm9kZSk7XG5cbnZhciBfaW1hZ2Vub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Tb3VyY2VOb2Rlcy9pbWFnZW5vZGUuanMgKi8gXCIuL3NyYy9Tb3VyY2VOb2Rlcy9pbWFnZW5vZGUuanNcIik7XG5cbnZhciBfaW1hZ2Vub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ltYWdlbm9kZSk7XG5cbnZhciBfY2FudmFzbm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vU291cmNlTm9kZXMvY2FudmFzbm9kZS5qcyAqLyBcIi4vc3JjL1NvdXJjZU5vZGVzL2NhbnZhc25vZGUuanNcIik7XG5cbnZhciBfY2FudmFzbm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYW52YXNub2RlKTtcblxudmFyIF9zb3VyY2Vub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Tb3VyY2VOb2Rlcy9zb3VyY2Vub2RlLmpzICovIFwiLi9zcmMvU291cmNlTm9kZXMvc291cmNlbm9kZS5qc1wiKTtcblxudmFyIF9jb21wb3NpdGluZ25vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1Byb2Nlc3NpbmdOb2Rlcy9jb21wb3NpdGluZ25vZGUuanMgKi8gXCIuL3NyYy9Qcm9jZXNzaW5nTm9kZXMvY29tcG9zaXRpbmdub2RlLmpzXCIpO1xuXG52YXIgX2NvbXBvc2l0aW5nbm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NpdGluZ25vZGUpO1xuXG52YXIgX2Rlc3RpbmF0aW9ubm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vRGVzdGluYXRpb25Ob2RlL2Rlc3RpbmF0aW9ubm9kZS5qcyAqLyBcIi4vc3JjL0Rlc3RpbmF0aW9uTm9kZS9kZXN0aW5hdGlvbm5vZGUuanNcIik7XG5cbnZhciBfZGVzdGluYXRpb25ub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rlc3RpbmF0aW9ubm9kZSk7XG5cbnZhciBfZWZmZWN0bm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vUHJvY2Vzc2luZ05vZGVzL2VmZmVjdG5vZGUuanMgKi8gXCIuL3NyYy9Qcm9jZXNzaW5nTm9kZXMvZWZmZWN0bm9kZS5qc1wiKTtcblxudmFyIF9lZmZlY3Rub2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VmZmVjdG5vZGUpO1xuXG52YXIgX3RyYW5zaXRpb25ub2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Qcm9jZXNzaW5nTm9kZXMvdHJhbnNpdGlvbm5vZGUuanMgKi8gXCIuL3NyYy9Qcm9jZXNzaW5nTm9kZXMvdHJhbnNpdGlvbm5vZGUuanNcIik7XG5cbnZhciBfdHJhbnNpdGlvbm5vZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJhbnNpdGlvbm5vZGUpO1xuXG52YXIgX3JlbmRlcmdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZW5kZXJncmFwaC5qcyAqLyBcIi4vc3JjL3JlbmRlcmdyYXBoLmpzXCIpO1xuXG52YXIgX3JlbmRlcmdyYXBoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbmRlcmdyYXBoKTtcblxudmFyIF92aWRlb2VsZW1lbnRjYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdmlkZW9lbGVtZW50Y2FjaGUuanMgKi8gXCIuL3NyYy92aWRlb2VsZW1lbnRjYWNoZS5qc1wiKTtcblxudmFyIF92aWRlb2VsZW1lbnRjYWNoZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aWRlb2VsZW1lbnRjYWNoZSk7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0RlZmluaXRpb25zL2RlZmluaXRpb25zLmpzICovIFwiLi9zcmMvRGVmaW5pdGlvbnMvZGVmaW5pdGlvbnMuanNcIik7XG5cbnZhciBfZGVmaW5pdGlvbnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5pdGlvbnMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgdXBkYXRlYWJsZXNNYW5hZ2VyID0gbmV3IF91dGlscy5VcGRhdGVhYmxlc01hbmFnZXIoKTtcblxuLyoqXG4gKiBWaWRlb0NvbnRleHQuXG4gKiBAbW9kdWxlIFZpZGVvQ29udGV4dFxuICovXG5cbnZhciBWaWRlb0NvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSB0aGUgVmlkZW9Db250ZXh0IGFuZCByZW5kZXIgdG8gdGhlIHNwZWNpZmljIGNhbnZhcy4gQSAybmQgcGFyYW1ldGVyIGNhbiBiZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIHdoaWNoIGlzIGEgZnVuY3Rpb24gdGhhdCBnZXQncyBjYWxsZWQgaWYgdGhlIFZpZGVvQ29udGV4dCBmYWlscyB0byBpbml0aWFsaXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhcyAtIHRoZSBjYW52YXMgZWxlbWVudCB0byByZW5kZXIgdGhlIG91dHB1dCB0by5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaW5pdEVycm9yQ2FsbGJhY2tdIC0gYSBjYWxsYmFjayBmb3IgaWYgaW5pdGlhbGlzaW5nIHRoZSBjYW52YXMgZmFpbGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBhIG51bWJlciBvZiBjdXN0b20gb3B0aW9ucyB3aGljaCBjYW4gYmUgc2V0IG9uIHRoZSBWaWRlb0NvbnRleHQsIGdlbmVyYWxseSBiZXN0IGxlZnQgYXMgZGVmYXVsdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm1hbnVhbFVwZGF0ZT1mYWxzZV0gLSBNYWtlIFZpZGVvIENvbnRleHQgbm90IHVzZSB0aGUgdXBkYXRhYmxlIG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuZE9uTGFzdFNvdXJjZUVuZD10cnVlXSAtIFRyaWdnZXIgYW4gYGVuZGVkYCBldmVudCB3aGVuIHRoZSBjdXJyZW50IHRpbWUgZ29lcyBhYm92ZSB0aGUgZHVyYXRpb24gb2YgdGhlIGNvbXBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VWaWRlb0VsZW1lbnRDYWNoZT10cnVlXSAtIENyZWF0ZXMgYSBwb29sIG9mIHZpZGVvIGVsZW1lbnQgdGhhdCB3aWxsIGJlIGFsbCBpbml0aWFsaXNlZCBhdCB0aGUgc2FtZSB0aW1lLiBJbXBvcnRhbnQgZm9yIG1vYmlsZSBzdXBwb3J0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnZpZGVvRWxlbWVudENhY2hlU2l6ZT02XSAtIE51bWJlciBvZiB2aWRlbyBlbGVtZW50IGluIHRoZSBwb29sXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLndlYmdsQ29udGV4dEF0dHJpYnV0ZXNdIC0gQSBzZXQgb2YgYXR0cmlidXRlcyB1c2VkIHdoZW4gZ2V0dGluZyB0aGUgR0wgY29udGV4dC4gQWxwaGEgd2lsbCBhbHdheXMgYmUgYHRydWVgLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzXCIpO1xuICAgICAqIHZhciBjdHggPSBuZXcgVmlkZW9Db250ZXh0KGNhbnZhc0VsZW1lbnQsICgpID0+IGNvbnNvbGUuZXJyb3IoXCJTb3JyeSwgeW91ciBicm93c2VyIGRvc2VuXFwndCBzdXBwb3J0IFdlYkdMXCIpKTtcbiAgICAgKiB2YXIgdmlkZW9Ob2RlID0gY3R4LnZpZGVvKFwidmlkZW8ubXA0XCIpO1xuICAgICAqIHZpZGVvTm9kZS5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XG4gICAgICogdmlkZW9Ob2RlLnN0YXJ0KDApO1xuICAgICAqIHZpZGVvTm9kZS5zdG9wKDEwKTtcbiAgICAgKiBjdHgucGxheSgpO1xuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlkZW9Db250ZXh0KGNhbnZhcywgaW5pdEVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICAgICAgICBfcmVmJG1hbnVhbFVwZGF0ZSA9IF9yZWYubWFudWFsVXBkYXRlLFxuICAgICAgICAgICAgbWFudWFsVXBkYXRlID0gX3JlZiRtYW51YWxVcGRhdGUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRtYW51YWxVcGRhdGUsXG4gICAgICAgICAgICBfcmVmJGVuZE9uTGFzdFNvdXJjZUUgPSBfcmVmLmVuZE9uTGFzdFNvdXJjZUVuZCxcbiAgICAgICAgICAgIGVuZE9uTGFzdFNvdXJjZUVuZCA9IF9yZWYkZW5kT25MYXN0U291cmNlRSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkZW5kT25MYXN0U291cmNlRSxcbiAgICAgICAgICAgIF9yZWYkdXNlVmlkZW9FbGVtZW50QyA9IF9yZWYudXNlVmlkZW9FbGVtZW50Q2FjaGUsXG4gICAgICAgICAgICB1c2VWaWRlb0VsZW1lbnRDYWNoZSA9IF9yZWYkdXNlVmlkZW9FbGVtZW50QyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkdXNlVmlkZW9FbGVtZW50QyxcbiAgICAgICAgICAgIF9yZWYkdmlkZW9FbGVtZW50Q2FjaCA9IF9yZWYudmlkZW9FbGVtZW50Q2FjaGVTaXplLFxuICAgICAgICAgICAgdmlkZW9FbGVtZW50Q2FjaGVTaXplID0gX3JlZiR2aWRlb0VsZW1lbnRDYWNoID09PSB1bmRlZmluZWQgPyA2IDogX3JlZiR2aWRlb0VsZW1lbnRDYWNoLFxuICAgICAgICAgICAgX3JlZiR3ZWJnbENvbnRleHRBdHRyID0gX3JlZi53ZWJnbENvbnRleHRBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgd2ViZ2xDb250ZXh0QXR0cmlidXRlcyA9IF9yZWYkd2ViZ2xDb250ZXh0QXR0ciA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmJHdlYmdsQ29udGV4dEF0dHI7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvQ29udGV4dCk7XG5cbiAgICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLl9lbmRPbkxhc3RTb3VyY2VFbmQgPSBlbmRPbkxhc3RTb3VyY2VFbmQ7XG5cbiAgICAgICAgdGhpcy5fZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBPYmplY3QuYXNzaWduKHsgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlIH0sIC8vIGNhbiBiZSBvdmVycmlkZW5cbiAgICAgICAgd2ViZ2xDb250ZXh0QXR0cmlidXRlcywgeyBhbHBoYTogZmFsc2UgLy8gQ2FuJ3QgYmUgb3ZlcnJpZGVuIGJlY2F1c2UgaXQgaXMgY29waWVkIGxhc3RcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAodGhpcy5fZ2wgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gaW50aWFsaXNlIFdlYkdMLlwiKTtcbiAgICAgICAgICAgIGlmIChpbml0RXJyb3JDYWxsYmFjaykgaW5pdEVycm9yQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpc2UgdGhlIHZpZGVvIGVsZW1lbnQgY2FjaGVcbiAgICAgICAgdGhpcy5fdXNlVmlkZW9FbGVtZW50Q2FjaGUgPSB1c2VWaWRlb0VsZW1lbnRDYWNoZTtcbiAgICAgICAgaWYgKHRoaXMuX3VzZVZpZGVvRWxlbWVudENhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl92aWRlb0VsZW1lbnRDYWNoZSA9IG5ldyBfdmlkZW9lbGVtZW50Y2FjaGUyLmRlZmF1bHQodmlkZW9FbGVtZW50Q2FjaGVTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhpcyBWaWRlb0NvbnRleHQgd2hpY2ggY2FuIGJlIHVzZWQgaW4gdGhlIGRlYnVnZ2VyLlxuICAgICAgICBpZiAodGhpcy5fY2FudmFzLmlkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NhbnZhcy5pZCA9PT0gXCJzdHJpbmdcIiB8fCB0aGlzLl9jYW52YXMuaWQgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZCA9IGNhbnZhcy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faWQgPT09IHVuZGVmaW5lZCkgdGhpcy5faWQgPSAoMCwgX3V0aWxzLmdlbmVyYXRlUmFuZG9tSWQpKCk7XG4gICAgICAgIGlmICh3aW5kb3cuX19WSURFT0NPTlRFWFRfUkVGU19fID09PSB1bmRlZmluZWQpIHdpbmRvdy5fX1ZJREVPQ09OVEVYVF9SRUZTX18gPSB7fTtcbiAgICAgICAgd2luZG93Ll9fVklERU9DT05URVhUX1JFRlNfX1t0aGlzLl9pZF0gPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlckdyYXBoID0gbmV3IF9yZW5kZXJncmFwaDIuZGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9zb3VyY2VOb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcm9jZXNzaW5nTm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fdGltZWxpbmUgPSBbXTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IFZpZGVvQ29udGV4dC5TVEFURS5QQVVTRUQ7XG4gICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IDEuMDtcbiAgICAgICAgdGhpcy5fdm9sdW1lID0gMS4wO1xuICAgICAgICB0aGlzLl9zb3VyY2VzUGxheWluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZGVzdGluYXRpb25Ob2RlID0gbmV3IF9kZXN0aW5hdGlvbm5vZGUyLmRlZmF1bHQodGhpcy5fZ2wsIHRoaXMuX3JlbmRlckdyYXBoKTtcblxuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKFZpZGVvQ29udGV4dC5FVkVOVFMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY2FsbGJhY2tzLnNldChWaWRlb0NvbnRleHQuRVZFTlRTW25hbWVdLCBbXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lQ2FsbGJhY2tzID0gW107XG5cbiAgICAgICAgaWYgKCFtYW51YWxVcGRhdGUpIHtcbiAgICAgICAgICAgIHVwZGF0ZWFibGVzTWFuYWdlci5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gSUQgYXNzaWduZWQgdG8gdGhlIFZpZGVvQ29udGV4dCBpbnN0YW5jZS4gVGhpcyB3aWxsIGVpdGhlciBiZSB0aGUgc2FtZSBpZCBhcyB0aGUgdW5kZXJseWluZyBjYW52YXMgZWxlbWVudCxcbiAgICAgKiBvciBhIHVuaXF1ZWx5IGdlbmVyYXRlZCBvbmUuXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhWaWRlb0NvbnRleHQsIFt7XG4gICAgICAgIGtleTogXCJyZWdpc3RlclRpbWVsaW5lQ2FsbGJhY2tcIixcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGhhcHBlbiBhdCBhIHNwZWNpZmljIHBvaW50IGluIHRpbWUuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIC0gdGhlIHRpbWUgYXQgd2hpY2ggdG8gdHJpZ2dlciB0aGUgY2FsbGJhY2suXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSB0aGUgY2FsbGJhY2sgdG8gcmVnaXN0ZXIuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcmRlcmluZyAtIHRoZSBvcmRlciBpbiB3aGljaCB0byBjYWxsIHRoZSBjYWxsYmFjayBpZiBtb3JlIHRoYW4gb25lIGlzIHJlZ2lzdGVyZWQgZm9yIHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJUaW1lbGluZUNhbGxiYWNrKHRpbWUsIGZ1bmMpIHtcbiAgICAgICAgICAgIHZhciBvcmRlcmluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVDYWxsYmFja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgICAgICAgICBmdW5jOiBmdW5jLFxuICAgICAgICAgICAgICAgIG9yZGVyaW5nOiBvcmRlcmluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlciBhIGNhbGxiYWNrIHdoaWNoIGhhcHBlbnMgYXQgYSBzcGVjaWZpYyBwb2ludCBpbiB0aW1lLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gdGhlIGNhbGxiYWNrIHRvIHVucmVnaXN0ZXIuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwidW5yZWdpc3RlclRpbWVsaW5lQ2FsbGJhY2tcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVucmVnaXN0ZXJUaW1lbGluZUNhbGxiYWNrKGZ1bmMpIHtcbiAgICAgICAgICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5fdGltZWxpbmVDYWxsYmFja3NbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5mdW5jID09PSBmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JlbW92ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0b1JlbW92ZVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2NhbGxiYWNrID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3RpbWVsaW5lQ2FsbGJhY2tzLmluZGV4T2YoX2NhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVDYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGxpc3RlbiB0byBvbmUgb2YgdGhlIGV2ZW50cyBkZWZpbmVkIGluIGBWaWRlb0NvbnRleHQuRVZFTlRTYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIHRoZSBldmVudCB0byByZWdpc3RlciBhZ2FpbnN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gdGhlIGNhbGxiYWNrIHRvIHJlZ2lzdGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzXCIpO1xuICAgICAgICAgKiB2YXIgY3R4ID0gbmV3IFZpZGVvQ29udGV4dChjYW52YXNFbGVtZW50KTtcbiAgICAgICAgICogY3R4LnJlZ2lzdGVyQ2FsbGJhY2soVmlkZW9Db250ZXh0LkVWRU5UUy5TVEFMTEVELCAoKSA9PiBjb25zb2xlLmxvZyhcIlBsYXliYWNrIHN0YWxsZWRcIikpO1xuICAgICAgICAgKiBjdHgucmVnaXN0ZXJDYWxsYmFjayhWaWRlb0NvbnRleHQuRVZFTlRTLlVQREFURSwgKCkgPT4gY29uc29sZS5sb2coXCJuZXcgZnJhbWVcIikpO1xuICAgICAgICAgKiBjdHgucmVnaXN0ZXJDYWxsYmFjayhWaWRlb0NvbnRleHQuRVZFTlRTLkVOREVELCAoKSA9PiBjb25zb2xlLmxvZyhcIlBsYXliYWNrIGVuZGVkXCIpKTtcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJyZWdpc3RlckNhbGxiYWNrXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlckNhbGxiYWNrKHR5cGUsIGZ1bmMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzLmhhcyh0eXBlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmdldCh0eXBlKS5wdXNoKGZ1bmMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBjYWxsYmFja1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gdGhlIGNhbGxiYWNrIHRvIHJlbW92ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbnZhc1wiKTtcbiAgICAgICAgICogdmFyIGN0eCA9IG5ldyBWaWRlb0NvbnRleHQoY2FudmFzRWxlbWVudCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vdGhlIGNhbGxiYWNrXG4gICAgICAgICAqIHZhciB1cGRhdGVDYWxsYmFjayA9ICgpID0+IGNvbnNvbGUubG9nKFwibmV3IGZyYW1lXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvL3JlZ2lzdGVyIHRoZSBjYWxsYmFja1xuICAgICAgICAgKiBjdHgucmVnaXN0ZXJDYWxsYmFjayhWaWRlb0NvbnRleHQuRVZFTlRTLlVQREFURSwgdXBkYXRlQ2FsbGJhY2spO1xuICAgICAgICAgKiAvL3RoZW4gdW5yZWdpc3RlciBpdFxuICAgICAgICAgKiBjdHgudW5yZWdpc3RlckNhbGxiYWNrKHVwZGF0ZUNhbGxiYWNrKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJ1bnJlZ2lzdGVyQ2FsbGJhY2tcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVucmVnaXN0ZXJDYWxsYmFjayhmdW5jKSB7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gdGhpcy5fY2FsbGJhY2tzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jQXJyYXkgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZnVuY0FycmF5LmluZGV4T2YoZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmNBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiX2NhbGxDYWxsYmFja3NcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxsQ2FsbGJhY2tzKHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBmdW5jQXJyYXkgPSB0aGlzLl9jYWxsYmFja3MuZ2V0KHR5cGUpO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IGZ1bmNBcnJheVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IF9zdGVwNC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBmdW5jKHRoaXMuX2N1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNhbnZhcyB0aGF0IHRoZSBWaWRlb0NvbnRleHQgaXMgdXNpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBUaGUgY2FudmFzIHRoYXQgdGhlIFZpZGVvQ29udGV4dCBpcyB1c2luZy5cbiAgICAgICAgICpcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJwbGF5XCIsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnQgdGhlIFZpZGVvQ29udGV4dCBwbGF5aW5nXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW52YXNcIik7XG4gICAgICAgICAqIHZhciBjdHggPSBuZXcgVmlkZW9Db250ZXh0KGNhbnZhc0VsZW1lbnQpO1xuICAgICAgICAgKiB2YXIgdmlkZW9Ob2RlID0gY3R4LnZpZGVvKFwidmlkZW8ubXA0XCIpO1xuICAgICAgICAgKiB2aWRlb05vZGUuY29ubmVjdChjdHguZGVzdGluYXRpb24pO1xuICAgICAgICAgKiB2aWRlb05vZGUuc3RhcnQoMCk7XG4gICAgICAgICAqIHZpZGVvTm9kZS5zdG9wKDEwKTtcbiAgICAgICAgICogY3R4LnBsYXkoKTtcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIlZpZGVvQ29udGV4dCAtIHBsYXlpbmdcIik7XG4gICAgICAgICAgICAvL0luaXRpYWxpc2UgdGhlIHZpZGVvIGVsZW1lbnQgY2FjaGVcbiAgICAgICAgICAgIGlmICh0aGlzLl92aWRlb0VsZW1lbnRDYWNoZSkgdGhpcy5fdmlkZW9FbGVtZW50Q2FjaGUuaW5pdCgpO1xuICAgICAgICAgICAgLy8gc2V0IHRoZSBzdGF0ZS5cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gVmlkZW9Db250ZXh0LlNUQVRFLlBMQVlJTkc7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXVzZSBwbGF5YmFjayBvZiB0aGUgVmlkZW9Db250ZXh0XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW52YXNcIik7XG4gICAgICAgICAqIHZhciBjdHggPSBuZXcgVmlkZW9Db250ZXh0KGNhbnZhc0VsZW1lbnQpO1xuICAgICAgICAgKiB2YXIgdmlkZW9Ob2RlID0gY3R4LnZpZGVvKFwidmlkZW8ubXA0XCIpO1xuICAgICAgICAgKiB2aWRlb05vZGUuY29ubmVjdChjdHguZGVzdGluYXRpb24pO1xuICAgICAgICAgKiB2aWRlb05vZGUuc3RhcnQoMCk7XG4gICAgICAgICAqIHZpZGVvTm9kZS5zdG9wKDIwKTtcbiAgICAgICAgICogY3R4LmN1cnJlbnRUaW1lID0gMTA7IC8vIHNlZWsgMTAgc2Vjb25kcyBpblxuICAgICAgICAgKiBjdHgucGxheSgpO1xuICAgICAgICAgKiBzZXRUaW1lb3V0KCgpID0+IGN0eC5wYXVzZSgpLCAxMDAwKTsgLy9wYXVzZSBwbGF5YmFjayBhZnRlciByb3VnaGx5IG9uZSBzZWNvbmQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicGF1c2VcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIlZpZGVvQ29udGV4dCAtIHBhdXNpbmdcIik7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFZpZGVvQ29udGV4dC5TVEFURS5QQVVTRUQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZSByZXByZXNlbnRpbmcgYSB2aWRlbyBzb3VyY2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTFZpZGVvRWxlbWVudHxNZWRpYVN0cmVhbX0gLSBUaGUgVVJMIG9yIHZpZGVvIGVsZW1lbnQgdG8gY3JlYXRlIHRoZSB2aWRlbyBmcm9tLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NvdXJjZU9mZnNldD0wXSAtIE9mZnNldCBpbnRvIHRoZSBzdGFydCBvZiB0aGUgc291cmNlIHZpZGVvIHRvIHN0YXJ0IHBsYXlpbmcgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVsb2FkVGltZT00XSAtIEhvdyBtYW55IHNlY29uZHMgYmVmb3JlIHRoZSB2aWRlbyBpcyB0byBiZSBwbGF5ZWQgdG8gc3RhcnQgbG9hZGluZyBpdC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFt2aWRlb0VsZW1lbnRBdHRyaWJ1dGVzXSAtIEEgZGljdGlvbmFyeSBvZiBhdHRyaWJ1dGVzIHRvIG1hcCBvbnRvIHRoZSB1bmRlcmx5aW5nIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqIEByZXR1cm4ge1ZpZGVvTm9kZX0gQSBuZXcgdmlkZW8gbm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbnZhc1wiKTtcbiAgICAgICAgICogdmFyIGN0eCA9IG5ldyBWaWRlb0NvbnRleHQoY2FudmFzRWxlbWVudCk7XG4gICAgICAgICAqIHZhciB2aWRlb05vZGUgPSBjdHgudmlkZW8oXCJiaWdidWNrYnVubnkubXA0XCIpO1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInZpZGVvXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlbyhzcmMpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICAgICAgICB2YXIgcHJlbG9hZFRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDQ7XG4gICAgICAgICAgICB2YXIgdmlkZW9FbGVtZW50QXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgICAgICAgIHZhciB2aWRlb05vZGUgPSBuZXcgX3ZpZGVvbm9kZTIuZGVmYXVsdChzcmMsIHRoaXMuX2dsLCB0aGlzLl9yZW5kZXJHcmFwaCwgdGhpcy5fY3VycmVudFRpbWUsIHRoaXMuX3BsYXliYWNrUmF0ZSwgc291cmNlT2Zmc2V0LCBwcmVsb2FkVGltZSwgdGhpcy5fdmlkZW9FbGVtZW50Q2FjaGUsIHZpZGVvRWxlbWVudEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgdGhpcy5fc291cmNlTm9kZXMucHVzaCh2aWRlb05vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvTm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZSByZXByZXNlbnRpbmcgYW4gYXVkaW8gc291cmNlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxBdWRpb0VsZW1lbnR8TWVkaWFTdHJlYW19IHNyYyAtIFRoZSB1cmwgb3IgYXVkaW8gZWxlbWVudCB0byBjcmVhdGUgdGhlIGF1ZGlvIG5vZGUgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzb3VyY2VPZmZzZXQ9MF0gLSBPZmZzZXQgaW50byB0aGUgc3RhcnQgb2YgdGhlIHNvdXJjZSBhdWRpbyB0byBzdGFydCBwbGF5aW5nIGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlbG9hZFRpbWU9NF0gLSBIb3cgbG9uZyBiZWZvcmUgYSBub2RlIGlzIHRvIGJlIGRpc3BsYXllZCB0byBhdHRtZXB0IHRvIGxvYWQgaXQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbaW1hZ2VFbGVtZW50QXR0cmlidXRlc10gLSBBbnkgYXR0cmlidXRlcyB0byBiZSBnaXZlbiB0byB0aGUgdW5kZXJseWluZyBpbWFnZSBlbGVtZW50LlxuICAgICAgICAgKiBAcmV0dXJuIHtBdWRpb05vZGV9IEEgbmV3IGF1ZGlvIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW52YXNcIik7XG4gICAgICAgICAqIHZhciBjdHggPSBuZXcgVmlkZW9Db250ZXh0KGNhbnZhc0VsZW1lbnQpO1xuICAgICAgICAgKiB2YXIgYXVkaW9Ob2RlID0gY3R4LmF1ZGlvKFwiemlnZ3lzdGFyZHVzdC5tcDNcIik7XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYXVkaW9cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF1ZGlvKHNyYykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZU9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgICAgICAgIHZhciBwcmVsb2FkVGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogNDtcbiAgICAgICAgICAgIHZhciBhdWRpb0VsZW1lbnRBdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgICAgICAgdmFyIGF1ZGlvTm9kZSA9IG5ldyBfYXVkaW9ub2RlMi5kZWZhdWx0KHNyYywgdGhpcy5fZ2wsIHRoaXMuX3JlbmRlckdyYXBoLCB0aGlzLl9jdXJyZW50VGltZSwgdGhpcy5fcGxheWJhY2tSYXRlLCBzb3VyY2VPZmZzZXQsIHByZWxvYWRUaW1lLCB0aGlzLl9hdWRpb0VsZW1lbnRDYWNoZSwgYXVkaW9FbGVtZW50QXR0cmlidXRlcyk7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VOb2Rlcy5wdXNoKGF1ZGlvTm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gYXVkaW9Ob2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY3JlYXRlVmlkZW9Tb3VyY2VOb2RlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVWaWRlb1NvdXJjZU5vZGUoc3JjKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICAgICAgdmFyIHByZWxvYWRUaW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA0O1xuICAgICAgICAgICAgdmFyIHZpZGVvRWxlbWVudEF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICAgICAgICB0aGlzLl9kZXByZWNhdGUoXCJXYXJuaW5nOiBjcmVhdGVWaWRlb1NvdXJjZU5vZGUgd2lsbCBiZSBkZXByZWNhdGVkIGluIHYxLjAsIHBsZWFzZSBzd2l0Y2ggdG8gdXNpbmcgVmlkZW9Db250ZXh0LnZpZGVvKClcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWRlbyhzcmMsIHNvdXJjZU9mZnNldCwgcHJlbG9hZFRpbWUsIHZpZGVvRWxlbWVudEF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBub2RlIHJlcHJlc2VudGluZyBhbiBpbWFnZSBzb3VyY2VcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8SW1hZ2V8SW1hZ2VCaXRtYXB9IHNyYyAtIFRoZSB1cmwgb3IgaW1hZ2UgZWxlbWVudCB0byBjcmVhdGUgdGhlIGltYWdlIG5vZGUgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVsb2FkVGltZT00XSAtIEhvdyBsb25nIGJlZm9yZSBhIG5vZGUgaXMgdG8gYmUgZGlzcGxheWVkIHRvIGF0dG1lcHQgdG8gbG9hZCBpdC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtpbWFnZUVsZW1lbnRBdHRyaWJ1dGVzXSAtIEFueSBhdHRyaWJ1dGVzIHRvIGJlIGdpdmVuIHRvIHRoZSB1bmRlcmx5aW5nIGltYWdlIGVsZW1lbnQuXG4gICAgICAgICAqIEByZXR1cm4ge0ltYWdlTm9kZX0gQSBuZXcgaW1hZ2Ugbm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbnZhc1wiKTtcbiAgICAgICAgICogdmFyIGN0eCA9IG5ldyBWaWRlb0NvbnRleHQoY2FudmFzRWxlbWVudCk7XG4gICAgICAgICAqIHZhciBpbWFnZU5vZGUgPSBjdHguaW1hZ2UoXCJpbWFnZS5wbmdcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW52YXNcIik7XG4gICAgICAgICAqIHZhciBpbWFnZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImltYWdlXCIpO1xuICAgICAgICAgKiB2YXIgY3R4ID0gbmV3IFZpZGVvQ29udGV4dChjYW52YXNFbGVtZW50KTtcbiAgICAgICAgICogdmFyIGltYWdlTm9kZSA9IGN0eC5pbWFnZShpbWFnZUVsZW1lbnQpO1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImltYWdlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbWFnZShzcmMpIHtcbiAgICAgICAgICAgIHZhciBwcmVsb2FkVGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogNDtcbiAgICAgICAgICAgIHZhciBpbWFnZUVsZW1lbnRBdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgICAgICAgdmFyIGltYWdlTm9kZSA9IG5ldyBfaW1hZ2Vub2RlMi5kZWZhdWx0KHNyYywgdGhpcy5fZ2wsIHRoaXMuX3JlbmRlckdyYXBoLCB0aGlzLl9jdXJyZW50VGltZSwgcHJlbG9hZFRpbWUsIGltYWdlRWxlbWVudEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgdGhpcy5fc291cmNlTm9kZXMucHVzaChpbWFnZU5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlTm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNyZWF0ZUltYWdlU291cmNlTm9kZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlSW1hZ2VTb3VyY2VOb2RlKHNyYykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZU9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgICAgICAgIHZhciBwcmVsb2FkVGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogNDtcbiAgICAgICAgICAgIHZhciBpbWFnZUVsZW1lbnRBdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgICAgICAgdGhpcy5fZGVwcmVjYXRlKFwiV2FybmluZzogY3JlYXRlSW1hZ2VTb3VyY2VOb2RlIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB2MS4wLCBwbGVhc2Ugc3dpdGNoIHRvIHVzaW5nIFZpZGVvQ29udGV4dC5pbWFnZSgpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2Uoc3JjLCBzb3VyY2VPZmZzZXQsIHByZWxvYWRUaW1lLCBpbWFnZUVsZW1lbnRBdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZSByZXByZXNlbnRpbmcgYSBjYW52YXMgc291cmNlXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzfSBzcmMgLSBUaGUgY2FudmFzIGVsZW1lbnQgdG8gY3JlYXRlIHRoZSBjYW52YXMgbm9kZSBmcm9tLlxuICAgICAgICAgKiBAcmV0dXJuIHtDYW52YXNOb2RlfSBBIG5ldyBjYW52YXMgbm9kZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJjYW52YXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbnZhcyhfY2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzTm9kZSA9IG5ldyBfY2FudmFzbm9kZTIuZGVmYXVsdChfY2FudmFzLCB0aGlzLl9nbCwgdGhpcy5fcmVuZGVyR3JhcGgsIHRoaXMuX2N1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZU5vZGVzLnB1c2goY2FudmFzTm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzTm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNyZWF0ZUNhbnZhc1NvdXJjZU5vZGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhc1NvdXJjZU5vZGUoY2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICAgICAgdmFyIHByZWxvYWRUaW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA0O1xuXG4gICAgICAgICAgICB0aGlzLl9kZXByZWNhdGUoXCJXYXJuaW5nOiBjcmVhdGVDYW52YXNTb3VyY2VOb2RlIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB2MS4wLCBwbGVhc2Ugc3dpdGNoIHRvIHVzaW5nIFZpZGVvQ29udGV4dC5jYW52YXMoKVwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcyhjYW52YXMsIHNvdXJjZU9mZnNldCwgcHJlbG9hZFRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBlZmZlY3Qgbm9kZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRlZmluaXRpb24gLSB0aGlzIGlzIGFuIG9iamVjdCBkZWZpbmluZyB0aGUgc2hhZGVycywgaW5wdXRzLCBhbmQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9zaXRpbmcgbm9kZSB0byBjcmVhdGUuIEJ1aWx0aW4gZGVmaW5pdGlvbnMgY2FuIGJlIGZvdW5kIGJ5IGFjY2Vzc2luZyBWaWRlb0NvbnRleHQuREVGSU5JVElPTlMuXG4gICAgICAgICAqIEByZXR1cm4ge0VmZmVjdE5vZGV9IEEgbmV3IGVmZmVjdCBub2RlIGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGRlZmluaXRpb25cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlZmZlY3RcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVmZmVjdChkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZWZmZWN0Tm9kZSA9IG5ldyBfZWZmZWN0bm9kZTIuZGVmYXVsdCh0aGlzLl9nbCwgdGhpcy5fcmVuZGVyR3JhcGgsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc2luZ05vZGVzLnB1c2goZWZmZWN0Tm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gZWZmZWN0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNyZWF0ZUVmZmVjdE5vZGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUVmZmVjdE5vZGUoZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fZGVwcmVjYXRlKFwiV2FybmluZzogY3JlYXRlRWZmZWN0Tm9kZSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdjEuMCwgcGxlYXNlIHN3aXRjaCB0byB1c2luZyBWaWRlb0NvbnRleHQuZWZmZWN0KClcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lZmZlY3QoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGNvbXBvc2l0aWluZyBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb21wb3NpdGluZyBub2RlcyBhcmUgdXNlZCBmb3Igb3BlcmF0aW9ucyBzdWNoIGFzIGNvbWJpbmluZyBtdWx0aXBsZSB2aWRlbyBzb3VyY2VzIGludG8gYSBzaW5nbGUgdHJhY2svY29ubmVjdGlvbiBmb3IgZnVydGhlciBwcm9jZXNzaW5nIGluIHRoZSBncmFwaC5cbiAgICAgICAgICpcbiAgICAgICAgICogQSBjb21wb3NpdGluZyBub2RlIGlzIHNsaWdodGx5IGRpZmZlcmVudCB0byBvdGhlciBwcm9jZXNzaW5nIG5vZGVzIGluIHRoYXQgaXQgb25seSBoYXMgb25lIGlucHV0IGluIGl0J3MgZGVmaW5pdGlvbiBidXQgY2FuIGhhdmUgdW5saW1pdGVkIGNvbm5lY3Rpb25zIG1hZGUgdG8gaXQuXG4gICAgICAgICAqIFRoZSBzaGFkZXIgaW4gdGhlIGRlZmluaXRpb24gaXMgcnVuIGZvciBlYWNoIGlucHV0IGluIHR1cm4sIGRyYXdpbmcgdGhlbSB0byB0aGUgb3V0cHV0IGJ1ZmZlci4gVGhpcyBtZWFucyB0aGVyZSBjYW4gYmUgbm8gaW50ZXJhY3Rpb24gYmV0d2VlbiB0aGUgc3BlYXJ0ZSBpbnB1dHMgdG8gYSBjb21wb3NpdGluZyBub2RlLCBhcyB0aGV5IGFyZSBpbmRpdmlkdWFsbHkgcHJvY2Vzc2VkIGluIHNlcGVyYXRlIHNoYWRlciBwYXNzZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9uIC0gdGhpcyBpcyBhbiBvYmplY3QgZGVmaW5pbmcgdGhlIHNoYWRlcnMsIGlucHV0cywgYW5kIHByb3BlcnRpZXMgb2YgdGhlIGNvbXBvc2l0aW5nIG5vZGUgdG8gY3JlYXRlLiBCdWlsdGluIGRlZmluaXRpb25zIGNhbiBiZSBmb3VuZCBieSBhY2Nlc3NpbmcgVmlkZW9Db250ZXh0LkRFRklOSVRJT05TXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0NvbXBvc2l0aW5nTm9kZX0gQSBuZXcgY29tcG9zaXRpbmcgbm9kZSBjcmVhdGVkIGZyb20gdGhlIHBhc3NlZCBkZWZpbml0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzXCIpO1xuICAgICAgICAgKiB2YXIgY3R4ID0gbmV3IFZpZGVvQ29udGV4dChjYW52YXNFbGVtZW50KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy9BIHNpbXBsZSBjb21wb3NpdGluZyBub2RlIGRlZmluaXRpb24gd2hpY2gganVzdCByZW5kZXJzIGFsbCB0aGUgaW5wdXRzIHRvIHRoZSBvdXRwdXQgYnVmZmVyLlxuICAgICAgICAgKiB2YXIgY29tYmluZURlZmluaXRpb24gPSB7XG4gICAgICAgICAqICAgICB2ZXJ0ZXhTaGFkZXIgOiBcIlxcXG4gICAgICAgICAqICAgICAgICAgYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXFxuICAgICAgICAgKiAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxcbiAgICAgICAgICogICAgICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXFxuICAgICAgICAgKiAgICAgICAgIHZvaWQgbWFpbigpIHtcXFxuICAgICAgICAgKiAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVjMigyLjAsMi4wKSp2ZWMyKDEuMCwgMS4wKSwgMC4wLCAxLjApO1xcXG4gICAgICAgICAqICAgICAgICAgICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xcXG4gICAgICAgICAqICAgICAgICAgfVwiLFxuICAgICAgICAgKiAgICAgZnJhZ21lbnRTaGFkZXIgOiBcIlxcXG4gICAgICAgICAqICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxcbiAgICAgICAgICogICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcXG4gICAgICAgICAqICAgICAgICAgdW5pZm9ybSBmbG9hdCBhO1xcXG4gICAgICAgICAqICAgICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxcbiAgICAgICAgICogICAgICAgICB2YXJ5aW5nIGZsb2F0IHZfcHJvZ3Jlc3M7XFxcbiAgICAgICAgICogICAgICAgICB2b2lkIG1haW4oKXtcXFxuICAgICAgICAgKiAgICAgICAgICAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcXG4gICAgICAgICAqICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcXG4gICAgICAgICAqICAgICAgICAgfVwiLFxuICAgICAgICAgKiAgICAgcHJvcGVydGllczp7XG4gICAgICAgICAqICAgICAgICAgXCJhXCI6e3R5cGU6XCJ1bmlmb3JtXCIsIHZhbHVlOjAuMH0sXG4gICAgICAgICAqICAgICB9LFxuICAgICAgICAgKiAgICAgaW5wdXRzOltcInVfaW1hZ2VcIl1cbiAgICAgICAgICogfTtcbiAgICAgICAgICogLy9DcmVhdGUgdGhlIG5vZGUsIHBhc3NpbmcgaW4gdGhlIGRlZmluaXRpb24uXG4gICAgICAgICAqIHZhciB0cmFja05vZGUgPSB2aWRlb0N0eC5jb21wb3NpdG9yKGNvbWJpbmVEZWZpbml0aW9uKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy9jcmVhdGUgdHdvIHZpZGVvcyB3aGljaCB3aWxsIHBsYXkgYXQgYmFjayB0byBiYWNrXG4gICAgICAgICAqIHZhciB2aWRlb05vZGUxID0gY3R4LnZpZGVvKFwidmlkZW8xLm1wNFwiKTtcbiAgICAgICAgICogdmlkZW9Ob2RlMS5wbGF5KDApO1xuICAgICAgICAgKiB2aWRlb05vZGUxLnN0b3AoMTApO1xuICAgICAgICAgKiB2YXIgdmlkZW9Ob2RlMiA9IGN0eC52aWRlbyhcInZpZGVvMi5tcDRcIik7XG4gICAgICAgICAqIHZpZGVvTm9kZTIucGxheSgxMCk7XG4gICAgICAgICAqIHZpZGVvTm9kZTIuc3RvcCgyMCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vQ29ubmVjdCB0aGUgbm9kZXMgdG8gdGhlIGNvbWJpbmUgbm9kZS4gVGhpcyB3aWxsIGdpdmUgYSBzaW5nbGUgY29ubmVjdGlvbiByZXByZXNlbnRpbmcgdGhlIHR3byB2aWRlb3Mgd2hpY2ggY2FuXG4gICAgICAgICAqIC8vYmUgY29ubmVjdGVkIHRvIG90aGVyIGVmZmVjdHMgc3VjaCBhcyBMVVRzLCBjaHJvbWFrZXllcnMsIGV0Yy5cbiAgICAgICAgICogdmlkZW9Ob2RlMS5jb25uZWN0KHRyYWNrTm9kZSk7XG4gICAgICAgICAqIHZpZGVvTm9kZTIuY29ubmVjdCh0cmFja05vZGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvL0Rvbid0IGRvIGFueXRoaW5nIGV4Y2l0aW5nLCBqdXN0IGNvbm5lY3QgaXQgdG8gdGhlIG91dHB1dC5cbiAgICAgICAgICogdHJhY2tOb2RlLmNvbm5lY3QoY3R4LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJjb21wb3NpdG9yXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb3NpdG9yKGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBjb21wb3NpdGluZ05vZGUgPSBuZXcgX2NvbXBvc2l0aW5nbm9kZTIuZGVmYXVsdCh0aGlzLl9nbCwgdGhpcy5fcmVuZGVyR3JhcGgsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc2luZ05vZGVzLnB1c2goY29tcG9zaXRpbmdOb2RlKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb3NpdGluZ05vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFuY2lhdGUgYSBjdXN0b20gYnVpbHQgc291cmNlIG5vZGVcbiAgICAgICAgICogQHBhcmFtIHtTb3VyY2VOb2RlfSBDdXN0b21Tb3VyY2VOb2RlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAgICAgICAgICogQHBhcmFtICB7Li4uYW55fSBvcHRpb25zXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY3VzdG9tU291cmNlTm9kZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3VzdG9tU291cmNlTm9kZShDdXN0b21Tb3VyY2VOb2RlLCBzcmMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvcHRpb25zID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VzdG9tU291cmNlTm9kZSA9IG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoQ3VzdG9tU291cmNlTm9kZSwgW251bGxdLmNvbmNhdChbc3JjLCB0aGlzLl9nbCwgdGhpcy5fcmVuZGVyR3JhcGgsIHRoaXMuX2N1cnJlbnRUaW1lXSwgb3B0aW9ucykpKSgpO1xuICAgICAgICAgICAgdGhpcy5fc291cmNlTm9kZXMucHVzaChjdXN0b21Tb3VyY2VOb2RlKTtcbiAgICAgICAgICAgIHJldHVybiBjdXN0b21Tb3VyY2VOb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByaWNhdGVkXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY3JlYXRlQ29tcG9zaXRpbmdOb2RlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDb21wb3NpdGluZ05vZGUoZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fZGVwcmVjYXRlKFwiV2FybmluZzogY3JlYXRlQ29tcG9zaXRpbmdOb2RlIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB2MS4wLCBwbGVhc2Ugc3dpdGNoIHRvIHVzaW5nIFZpZGVvQ29udGV4dC5jb21wb3NpdG9yKClcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb3NpdG9yKGRlZmluaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB0cmFuc2l0aW9uIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRyYW5zaXN0aW9uIG5vZGVzIGFyZSBhIHR5cGUgb2YgZWZmZWN0IG5vZGUgd2hpY2ggaGF2ZSBwYXJhbWV0ZXJzIHdoaWNoIGNhbiBiZSBjaGFuZ2VkIGFzIGV2ZW50cyBvbiB0aGUgdGltZWxpbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlIGEgdHJhbnNpdGlvbiBub2RlIHdoaWNoIGNyb3NzLWZhZGVzIGJldHdlZW4gdHdvIHZpZGVvcyBjb3VsZCBoYXZlIGEgXCJtaXhcIiBwcm9wZXJ0eSB3aGljaCBzZXRzIHRoZVxuICAgICAgICAgKiBwcm9ncmVzcyB0aHJvdWdoIHRoZSB0cmFuc2lzdGlvbi4gUmF0aGVyIHRoYW4gaGF2aW5nIHRvIHdyaXRlIHlvdXIgb3duIGNvZGUgdG8gYWRqdXN0IHRoaXMgcHJvcGVydHkgYXQgc3BlY2ZpY1xuICAgICAgICAgKiBwb2ludHMgaW4gdGltZSBhIHRyYW5zaXRpb24gbm9kZSBoYXMgYSBcInRyYW5zaXRpb25cIiBmdW5jdGlvbiB3aGljaCB0YWtlcyBhIHN0YXJ0VGltZSwgc3RvcFRpbWUsIHRhcmdldFZhbHVlLCBhbmQgYVxuICAgICAgICAgKiBwcm9wZXJ0eU5hbWUgKHdoaWNoIHdpbGwgYmUgXCJtaXhcIikuIFRoaXMgd2lsbCBsaW5lYXJseSBpbnRlcnBvbGF0ZSB0aGUgcHJvcGVydHkgZnJvbSB0aGUgY3VyZXJudCB2YWx1ZSB0b1xuICAgICAgICAgKiB0cmFnZXRWYWx1ZSBiZXR3ZWVuIHRoZSBzdGFydFRpbWUgYW5kIHN0b3BUaW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdGlvbiAtIHRoaXMgaXMgYW4gb2JqZWN0IGRlZmluaW5nIHRoZSBzaGFkZXJzLCBpbnB1dHMsIGFuZCBwcm9wZXJ0aWVzIG9mIHRoZSB0cmFuc2l0aW9uIG5vZGUgdG8gY3JlYXRlLlxuICAgICAgICAgKiBAcmV0dXJuIHtUcmFuc2l0aW9uTm9kZX0gQSBuZXcgdHJhbnNpdGlvbiBub2RlIGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGRlZmluaXRpb24uXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW52YXNcIik7XG4gICAgICAgICAqIHZhciBjdHggPSBuZXcgVmlkZW9Db250ZXh0KGNhbnZhc0VsZW1lbnQpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvL0Egc2ltcGxlIGNyb3NzLWZhZGUgbm9kZSBkZWZpbml0aW9uIHdoaWNoIGNyb3NzLWZhZGVzIGJldHdlZW4gdHdvIHZpZGVvcyBiYXNlZCBvbiB0aGUgbWl4IHByb3BlcnR5LlxuICAgICAgICAgKiB2YXIgY3Jvc3NmYWRlRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICogICAgIHZlcnRleFNoYWRlciA6IFwiXFxcbiAgICAgICAgICogICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxcbiAgICAgICAgICogICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxcbiAgICAgICAgICogICAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcXG4gICAgICAgICAqICAgICAgICB2b2lkIG1haW4oKSB7XFxcbiAgICAgICAgICogICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVjMigyLjAsMi4wKSphX3Bvc2l0aW9uLXZlYzIoMS4wLCAxLjApLCAwLjAsIDEuMCk7XFxcbiAgICAgICAgICogICAgICAgICAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcXFxuICAgICAgICAgKiAgICAgICAgIH1cIixcbiAgICAgICAgICogICAgIGZyYWdtZW50U2hhZGVyIDogXCJcXFxuICAgICAgICAgKiAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcXG4gICAgICAgICAqICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZV9hO1xcXG4gICAgICAgICAqICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZV9iO1xcXG4gICAgICAgICAqICAgICAgICAgdW5pZm9ybSBmbG9hdCBtaXg7XFxcbiAgICAgICAgICogICAgICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXFxuICAgICAgICAgKiAgICAgICAgIHZhcnlpbmcgZmxvYXQgdl9taXg7XFxcbiAgICAgICAgICogICAgICAgICB2b2lkIG1haW4oKXtcXFxuICAgICAgICAgKiAgICAgICAgICAgICB2ZWM0IGNvbG9yX2EgPSB0ZXh0dXJlMkQodV9pbWFnZV9hLCB2X3RleENvb3JkKTtcXFxuICAgICAgICAgKiAgICAgICAgICAgICB2ZWM0IGNvbG9yX2IgPSB0ZXh0dXJlMkQodV9pbWFnZV9iLCB2X3RleENvb3JkKTtcXFxuICAgICAgICAgKiAgICAgICAgICAgICBjb2xvcl9hWzBdICo9IG1peDtcXFxuICAgICAgICAgKiAgICAgICAgICAgICBjb2xvcl9hWzFdICo9IG1peDtcXFxuICAgICAgICAgKiAgICAgICAgICAgICBjb2xvcl9hWzJdICo9IG1peDtcXFxuICAgICAgICAgKiAgICAgICAgICAgICBjb2xvcl9hWzNdICo9IG1peDtcXFxuICAgICAgICAgKiAgICAgICAgICAgICBjb2xvcl9iWzBdICo9ICgxLjAgLSBtaXgpO1xcXG4gICAgICAgICAqICAgICAgICAgICAgIGNvbG9yX2JbMV0gKj0gKDEuMCAtIG1peCk7XFxcbiAgICAgICAgICogICAgICAgICAgICAgY29sb3JfYlsyXSAqPSAoMS4wIC0gbWl4KTtcXFxuICAgICAgICAgKiAgICAgICAgICAgICBjb2xvcl9iWzNdICo9ICgxLjAgLSBtaXgpO1xcXG4gICAgICAgICAqICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yX2EgKyBjb2xvcl9iO1xcXG4gICAgICAgICAqICAgICAgICAgfVwiLFxuICAgICAgICAgKiAgICAgcHJvcGVydGllczp7XG4gICAgICAgICAqICAgICAgICAgXCJtaXhcIjp7dHlwZTpcInVuaWZvcm1cIiwgdmFsdWU6MC4wfSxcbiAgICAgICAgICogICAgIH0sXG4gICAgICAgICAqICAgICBpbnB1dHM6W1widV9pbWFnZV9hXCIsXCJ1X2ltYWdlX2JcIl1cbiAgICAgICAgICogfTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy9DcmVhdGUgdGhlIG5vZGUsIHBhc3NpbmcgaW4gdGhlIGRlZmluaXRpb24uXG4gICAgICAgICAqIHZhciB0cmFuc2l0aW9uTm9kZSA9IHZpZGVvQ3R4LnRyYW5zaXRpb24oY3Jvc3NmYWRlRGVmaW5pdGlvbik7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vY3JlYXRlIHR3byB2aWRlb3Mgd2hpY2ggd2lsbCBvdmVybGFwIGJ5IHR3byBzZWNvbmRzXG4gICAgICAgICAqIHZhciB2aWRlb05vZGUxID0gY3R4LnZpZGVvKFwidmlkZW8xLm1wNFwiKTtcbiAgICAgICAgICogdmlkZW9Ob2RlMS5wbGF5KDApO1xuICAgICAgICAgKiB2aWRlb05vZGUxLnN0b3AoMTApO1xuICAgICAgICAgKiB2YXIgdmlkZW9Ob2RlMiA9IGN0eC52aWRlbyhcInZpZGVvMi5tcDRcIik7XG4gICAgICAgICAqIHZpZGVvTm9kZTIucGxheSg4KTtcbiAgICAgICAgICogdmlkZW9Ob2RlMi5zdG9wKDE4KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy9Db25uZWN0IHRoZSBub2RlcyB0byB0aGUgdHJhbnNpc3Rpb24gbm9kZS5cbiAgICAgICAgICogdmlkZW9Ob2RlMS5jb25uZWN0KHRyYW5zaXRpb25Ob2RlKTtcbiAgICAgICAgICogdmlkZW9Ob2RlMi5jb25uZWN0KHRyYW5zaXRpb25Ob2RlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy9TZXQtdXAgYSB0cmFuc2l0aW9uIHdoaWNoIGhhcHBlbnMgYXQgdGhlIGNyb3Nzb3ZlciBwb2ludCBvZiB0aGUgcGxheWJhY2sgb2YgdGhlIHR3byB2aWRlb3NcbiAgICAgICAgICogdHJhbnNpdGlvbk5vZGUudHJhbnNpdGlvbig4LDEwLDEuMCxcIm1peFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy9Db25uZWN0IHRoZSB0cmFuc2l0aW9uIG5vZGUgdG8gdGhlIG91dHB1dFxuICAgICAgICAgKiB0cmFuc2l0aW9uTm9kZS5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vc3RhcnQgcGxheWJhY2tcbiAgICAgICAgICogY3R4LnBsYXkoKTtcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJ0cmFuc2l0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2l0aW9uKGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uTm9kZSA9IG5ldyBfdHJhbnNpdGlvbm5vZGUyLmRlZmF1bHQodGhpcy5fZ2wsIHRoaXMuX3JlbmRlckdyYXBoLCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NpbmdOb2Rlcy5wdXNoKHRyYW5zaXRpb25Ob2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9uTm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNyZWF0ZVRyYW5zaXRpb25Ob2RlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTm9kZShkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXByZWNhdGUoXCJXYXJuaW5nOiBjcmVhdGVUcmFuc2l0aW9uTm9kZSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdjEuMCwgcGxlYXNlIHN3aXRjaCB0byB1c2luZyBWaWRlb0NvbnRleHQudHJhbnNpdGlvbigpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbihkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9pc1N0YWxsZWRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1N0YWxsZWQoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NvdXJjZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZU5vZGUgPSB0aGlzLl9zb3VyY2VOb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZU5vZGUuX2lzUmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBhbGxvd3MgbWFudWFsIGNhbGxpbmcgb2YgdGhlIHVwZGF0ZSBsb29wIG9mIHRoZSB2aWRlb0NvbnRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkdCAtIFRoZSBkaWZmZXJlbmNlIGluIHNlY29uZHMgYmV0d2VlbiB0aGlzIGFuZCB0aGUgcHJldmlvdXMgY2FsbGluZyBvZiB1cGRhdGUuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW52YXNcIik7XG4gICAgICAgICAqIHZhciBjdHggPSBuZXcgVmlkZW9Db250ZXh0KGNhbnZhc0VsZW1lbnQsIHVuZGVmaW5lZCwge1wibWFudWFsVXBkYXRlXCIgOiB0cnVlfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBwcmV2aW91c1RpbWU7XG4gICAgICAgICAqIGZ1bmN0aW9uIHVwZGF0ZSh0aW1lKXtcbiAgICAgICAgICogICAgIGlmIChwcmV2aW91c1RpbWUgPT09IHVuZGVmaW5lZCkgcHJldmlvdXNUaW1lID0gdGltZTtcbiAgICAgICAgICogICAgIHZhciBkdCA9ICh0aW1lIC0gcHJldmlvdXNUaW1lKS8xMDAwO1xuICAgICAgICAgKiAgICAgY3R4LnVwZGF0ZShkdCk7XG4gICAgICAgICAqICAgICBwcmV2aW91c1RpbWUgPSB0aW1lO1xuICAgICAgICAgKiAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogdXBkYXRlKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoZHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZShkdCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKGR0KSB7XG4gICAgICAgICAgICAvL1JlbW92ZSBhbnkgZGVzdHJveWVkIG5vZGVzXG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VOb2RlcyA9IHRoaXMuX3NvdXJjZU5vZGVzLmZpbHRlcihmdW5jdGlvbiAoc291cmNlTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICghc291cmNlTm9kZS5kZXN0cm95ZWQpIHJldHVybiBzb3VyY2VOb2RlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NpbmdOb2RlcyA9IHRoaXMuX3Byb2Nlc3NpbmdOb2Rlcy5maWx0ZXIoZnVuY3Rpb24gKHByb2Nlc3NpbmdOb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzaW5nTm9kZS5kZXN0cm95ZWQpIHJldHVybiBwcm9jZXNzaW5nTm9kZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFZpZGVvQ29udGV4dC5TVEFURS5QTEFZSU5HIHx8IHRoaXMuX3N0YXRlID09PSBWaWRlb0NvbnRleHQuU1RBVEUuU1RBTExFRCB8fCB0aGlzLl9zdGF0ZSA9PT0gVmlkZW9Db250ZXh0LlNUQVRFLlBBVVNFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxDYWxsYmFja3MoVmlkZW9Db250ZXh0LkVWRU5UUy5VUERBVEUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBWaWRlb0NvbnRleHQuU1RBVEUuUEFVU0VEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1N0YWxsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbENhbGxiYWNrcyhWaWRlb0NvbnRleHQuRVZFTlRTLlNUQUxMRUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBWaWRlb0NvbnRleHQuU1RBVEUuU1RBTExFRDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gVmlkZW9Db250ZXh0LlNUQVRFLlBMQVlJTkc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFZpZGVvQ29udGV4dC5TVEFURS5QTEFZSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vSGFuZGxlIHRpbWVsaW5lIGNhbGxiYWNrcy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGl2ZUNhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I1ID0gdGhpcy5fdGltZWxpbmVDYWxsYmFja3NbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDU7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSAoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfc3RlcDUudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sudGltZSA+PSB0aGlzLmN1cnJlbnRUaW1lICYmIGNhbGxiYWNrLnRpbWUgPCB0aGlzLl9jdXJyZW50VGltZSArIGR0ICogdGhpcy5fcGxheWJhY2tSYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ3JvdXAgdGhlIGNhbGxiYWNrcyBieSB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWN0aXZlQ2FsbGJhY2tzLmhhcyhjYWxsYmFjay50aW1lKSkgYWN0aXZlQ2FsbGJhY2tzLnNldChjYWxsYmFjay50aW1lLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNhbGxiYWNrcy5nZXQoY2FsbGJhY2sudGltZSkucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1NvcnQgdGhlIGdyb3VwcyBvZiBjYWxsYmFja3MgYnkgdGhlIHRpbWVzIG9mIHRoZSBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3I1ID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZUludGVydmFscyA9IEFycmF5LmZyb20oYWN0aXZlQ2FsbGJhY2tzLmtleXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVJbnRlcnZhbHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjYgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjYgPSB0aW1lSW50ZXJ2YWxzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA2OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gKF9zdGVwNiA9IF9pdGVyYXRvcjYubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBfc3RlcDYudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gYWN0aXZlQ2FsbGJhY2tzLmdldCh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5vcmRlcmluZyAtIGIub3JkZXJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I3ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjcgPSBjYWxsYmFja3NbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDc7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSAoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfY2FsbGJhY2syID0gX3N0ZXA3LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2syLmZ1bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjcgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgJiYgX2l0ZXJhdG9yNy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3I3LnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3I2ID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ICYmIF9pdGVyYXRvcjYucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjYucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBkdCAqIHRoaXMuX3BsYXliYWNrUmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUaW1lID4gdGhpcy5kdXJhdGlvbiAmJiB0aGlzLl9lbmRPbkxhc3RTb3VyY2VFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vRG8gYW4gdXBkYXRlIG9kIHRoZSBzb3VyY2Vub2RlcyBpbiBjYXNlIGFueXRoaW5nIGluIHRoZSBcImVuZGVkXCIgY2FsbGJhY2tzIG1vZGlmZXMgY3VycmVudFRpbWUgYW5kIHNvdXJjZXMgaGF2ZW4ndCBoYWQgYSBjaGFuY2UgdG8gc3RvcC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc291cmNlTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VOb2Rlc1tpXS5fdXBkYXRlKHRoaXMuX2N1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gVmlkZW9Db250ZXh0LlNUQVRFLkVOREVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbENhbGxiYWNrcyhWaWRlb0NvbnRleHQuRVZFTlRTLkVOREVEKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VzUGxheWluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuX3NvdXJjZU5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlTm9kZSA9IHRoaXMuX3NvdXJjZU5vZGVzW19pXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFZpZGVvQ29udGV4dC5TVEFURS5TVEFMTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlTm9kZS5faXNSZWFkeSgpICYmIHNvdXJjZU5vZGUuX3N0YXRlID09PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUucGxheWluZykgc291cmNlTm9kZS5fcGF1c2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFZpZGVvQ29udGV4dC5TVEFURS5QQVVTRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU5vZGUuX3BhdXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBWaWRlb0NvbnRleHQuU1RBVEUuUExBWUlORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTm9kZS5fcGxheSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZU5vZGUuX3VwZGF0ZSh0aGlzLl9jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VOb2RlLl9zdGF0ZSA9PT0gX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFLnBhdXNlZCB8fCBzb3VyY2VOb2RlLl9zdGF0ZSA9PT0gX3NvdXJjZW5vZGUuU09VUkNFTk9ERVNUQVRFLnBsYXlpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VzUGxheWluZyAhPT0gdGhpcy5fc291cmNlc1BsYXlpbmcgJiYgdGhpcy5fc3RhdGUgPT09IFZpZGVvQ29udGV4dC5TVEFURS5QTEFZSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VzUGxheWluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbENhbGxiYWNrcyhWaWRlb0NvbnRleHQuRVZFTlRTLkNPTlRFTlQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbENhbGxiYWNrcyhWaWRlb0NvbnRleHQuRVZFTlRTLk5PQ09OVEVOVCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlc1BsYXlpbmcgPSBzb3VyY2VzUGxheWluZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIEl0dGVyYXRlIHRoZSBkaXJlY3RlZCBhY3ljbGljIGdyYXBoIHVzaW5nIEtoYW4ncyBhbGdvcml0aG0gKEtIQUFBQUFOISkuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBUaGlzIGhhcyBoaWdobGlnaHRlZCBhIGJ1bmNoIG9mIGluZWZmZW5jaWVzIGluIHRoZSByZW5kZXJncmFwaCBjbGFzcyBhYm91dCBob3cgaXRzIHN0b3JlcyBjb25uZWN0aW9ucy5cbiAgICAgICAgICAgICAgICAgKiBNYWlubHkgdGhlIGZhY3QgdGhhdCB0byBnZXQgaW5wdXRzIGZvciBhIG5vZGUgeW91IGhhdmUgdG8gaXRlcmF0ZSB0aGUgZnVsbCBsaXN0IG9mIGNvbm5lY3Rpb25zIHJhdGhlciB0aGFuXG4gICAgICAgICAgICAgICAgICogYSBub2RlIG93bmluZyBpdCdzIGNvbm5lY3Rpb25zLlxuICAgICAgICAgICAgICAgICAqIFRoZSB0cmFkZSBvZmYgd2l0aCBjaGFuZ2luZyB0aGlzIGlzIG1ha2luZy9yZW1vdmluZyBjb25uZWN0aW9ucyBiZWNvbWVzIG1vcmUgY29zdGx5IHBlcmZvcm1hbmNlIHdpc2UsIGJ1dFxuICAgICAgICAgICAgICAgICAqIHRoaXMgaXMgZGVmaW5pdGVseSB3b3J0aCB3aGlsZSBiZWNhdXNlIGdldHRpbmcgdGhlIGNvbm5uZWN0aW9ucyBpcyBhIG11Y2ggbW9yZSBjb21tb24gb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogVEw7RFIgRnV0dXJlIG1hdHQgLSByZWZhY3RvciB0aGlzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHNvcnRlZE5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25zID0gdGhpcy5fcmVuZGVyR3JhcGguY29ubmVjdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBfcmVuZGVyZ3JhcGgyLmRlZmF1bHQuZ2V0SW5wdXRsZXNzTm9kZXMoY29ubmVjdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yOCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I4ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I4ID0gX3JlbmRlcmdyYXBoMi5kZWZhdWx0Lm91dHB1dEVkZ2VzRm9yKG5vZGUsIGNvbm5lY3Rpb25zKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwODsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IChfc3RlcDggPSBfaXRlcmF0b3I4Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGdlID0gX3N0ZXA4LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gY29ubmVjdGlvbnMuaW5kZXhPZihlZGdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkgY29ubmVjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3JlbmRlcmdyYXBoMi5kZWZhdWx0LmlucHV0RWRnZXNGb3IoZWRnZS5kZXN0aW5hdGlvbiwgY29ubmVjdGlvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGVkZ2UuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3I4ID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ICYmIF9pdGVyYXRvcjgucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjgucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yOSA9IHNvcnRlZE5vZGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA5OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gKF9zdGVwOSA9IF9pdGVyYXRvcjkubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjkgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX25vZGUgPSBfc3RlcDkudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VOb2Rlcy5pbmRleE9mKF9ub2RlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbm9kZS5fdXBkYXRlKHRoaXMuX2N1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbm9kZS5fcmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3I5ID0gZXJyO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ICYmIF9pdGVyYXRvcjkucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yOS5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveSBhbGwgbm9kZXMgaW4gdGhlIGdyYXBoIGFuZCByZXNldCB0aGUgdGltZWxpbmUuIEFmdGVyIGNhbGxpbmcgdGhpcyBhbnkgY3JlYXRlZCBub2RlcyB3aWxsIGJlIHVudXNhYmxlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInJlc2V0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjEwID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IxMCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMCA9IHRoaXMuX2NhbGxiYWNrc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwID0gKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IF9zdGVwMTAudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMTAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMTAgPSBlcnI7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwICYmIF9pdGVyYXRvcjEwLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMTAucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxMSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMTEgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTEgPSB0aGlzLl9zb3VyY2VOb2Rlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTE7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjExID0gKF9zdGVwMTEgPSBfaXRlcmF0b3IxMS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gX3N0ZXAxMS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjExID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjExID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSAmJiBfaXRlcmF0b3IxMS5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjExLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTIgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMTIgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjEyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjEyID0gdGhpcy5fcHJvY2Vzc2luZ05vZGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTIgPSAoX3N0ZXAxMiA9IF9pdGVyYXRvcjEyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9ub2RlMiA9IF9zdGVwMTIudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgX25vZGUyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjEyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjEyID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMiAmJiBfaXRlcmF0b3IxMi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjEyLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgwKTtcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZU5vZGVzID0gW107XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzaW5nTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gW107XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFZpZGVvQ29udGV4dC5TVEFURS5QQVVTRUQ7XG4gICAgICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSAxLjA7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VzUGxheWluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKFZpZGVvQ29udGV4dC5FVkVOVFMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9jYWxsYmFja3Muc2V0KFZpZGVvQ29udGV4dC5FVkVOVFNbbmFtZV0sIFtdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9kZXByZWNhdGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXByZWNhdGUobXNnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwic25hcHNob3RcIixcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBKUyBPYmplY3QgY29udGFpbmluZyB0aGUgc3RhdGUgb2YgdGhlIFZpZGVvQ29udGV4dCBpbnN0YW5jZSBhbmQgYWxsIHRoZSBjcmVhdGVkIG5vZGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNuYXBzaG90KCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMuc25hcHNob3QpKHRoaXMpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiaWRcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBJRCBvZiB0aGUgVmlkZW9Db250ZXh0IGluc3RhbmNlLiBUaGlzIHNob3VsZCBiZSB1bmlxdWUuXG4gICAgICAgICAqL1xuICAgICAgICAsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0lEKSB7XG4gICAgICAgICAgICBkZWxldGUgd2luZG93Ll9fVklERU9DT05URVhUX1JFRlNfX1t0aGlzLl9pZF07XG4gICAgICAgICAgICBpZiAod2luZG93Ll9fVklERU9DT05URVhUX1JFRlNfX1tuZXdJRF0gIT09IHVuZGVmaW5lZCkgY29uc29sZS53YXJuKFwiV2FybmluZzsgc2V0dGluZyBpZCB0byB0aGF0IG9mIGFuIGV4aXN0aW5nIFZpZGVvQ29udGV4dCBpbnN0YW5jZS5cIik7XG4gICAgICAgICAgICB3aW5kb3cuX19WSURFT0NPTlRFWFRfUkVGU19fW25ld0lEXSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9pZCA9IG5ld0lEO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZWxlbWVudFwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgICAgKiBAcmV0dXJuIHtTVEFURX0gVGhlIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInN0YXRlXCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgcHJvZ3Jlc3MgdGhyb3VnaCB0aGUgaW50ZXJuYWwgdGltZWxpbmUuXG4gICAgICAgICAqIFNldHRpbmcgdGhpcyBjYW4gYmUgdXNlZCBhcyBhIHdheSB0byBpbXBsZW1lbnQgYSBzY3J1YmJhYmxlIHRpbWVsaW5lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFRpbWUgLSB0aGlzIGlzIHRoZSBjdXJyZW50VGltZSB0byBzZXQgaW4gc2Vjb25kcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbnZhc1wiKTtcbiAgICAgICAgICogdmFyIGN0eCA9IG5ldyBWaWRlb0NvbnRleHQoY2FudmFzRWxlbWVudCk7XG4gICAgICAgICAqIHZhciB2aWRlb05vZGUgPSBjdHgudmlkZW8oXCJ2aWRlby5tcDRcIik7XG4gICAgICAgICAqIHZpZGVvTm9kZS5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAqIHZpZGVvTm9kZS5zdGFydCgwKTtcbiAgICAgICAgICogdmlkZW9Ob2RlLnN0b3AoMjApO1xuICAgICAgICAgKiBjdHguY3VycmVudFRpbWUgPSAxMDsgLy8gc2VlayAxMCBzZWNvbmRzIGluXG4gICAgICAgICAqIGN0eC5wbGF5KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY3VycmVudFRpbWVcIixcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA8IHRoaXMuZHVyYXRpb24gJiYgdGhpcy5fc3RhdGUgPT09IFZpZGVvQ29udGV4dC5TVEFURS5FTkRFRCkgdGhpcy5fc3RhdGUgPSBWaWRlb0NvbnRleHQuU1RBVEUuUEFVU0VEO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRUaW1lID09PSBcInN0cmluZ1wiIHx8IGN1cnJlbnRUaW1lIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRpbWUgPSBwYXJzZUZsb2F0KGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zb3VyY2VOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZU5vZGVzW2ldLl9zZWVrKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHRoaXMuX3Byb2Nlc3NpbmdOb2Rlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc2luZ05vZGVzW19pMl0uX3NlZWsoY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgaG93IGZhciB0aHJvdWdoIHRoZSBpbnRlcm5hbCB0aW1lbGluZSBoYXMgYmVlbiBwbGF5ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEdldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGdpdmUgdGhlIGN1cnJlbnQgcGxheWhlYWQgcG9zaXRpb24uIENhbiBiZSB1c2VkIGZvciB1cGRhdGluZyB0aW1lbGluZXMuXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRpbWUgaW4gc2Vjb25kcyB0aHJvdWdoIHRoZSBjdXJyZW50IHBsYXlsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzXCIpO1xuICAgICAgICAgKiB2YXIgY3R4ID0gbmV3IFZpZGVvQ29udGV4dChjYW52YXNFbGVtZW50KTtcbiAgICAgICAgICogdmFyIHZpZGVvTm9kZSA9IGN0eC52aWRlbyhcInZpZGVvLm1wNFwiKTtcbiAgICAgICAgICogdmlkZW9Ob2RlLmNvbm5lY3QoY3R4LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICogdmlkZW9Ob2RlLnN0YXJ0KDApO1xuICAgICAgICAgKiB2aWRlb05vZGUuc3RvcCgxMCk7XG4gICAgICAgICAqIGN0eC5wbGF5KCk7XG4gICAgICAgICAqIHNldFRpbWVvdXQoKCkgPT4gY29uc29sZS5sb2coY3R4LmN1cnJlbnRUaW1lKSwxMDAwKTsgLy9zaG91bGQgcHJpbnQgcm91Z2hseSAxLjBcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB0aW1lIGF0IHdoaWNoIHRoZSBsYXN0IG5vZGUgaW4gdGhlIGN1cnJlbnQgaW50ZXJuYWwgdGltZWxpbmUgZmluaXNoZXMgcGxheWluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgZW5kIHRpbWUgaW4gc2Vjb25kcyBvZiB0aGUgbGFzdCB2aWRlbyBub2RlIHRvIGZpbmlzaCBwbGF5aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzXCIpO1xuICAgICAgICAgKiB2YXIgY3R4ID0gbmV3IFZpZGVvQ29udGV4dChjYW52YXNFbGVtZW50KTtcbiAgICAgICAgICogY29uc29sZS5sb2coY3R4LmR1cmF0aW9uKTsgLy9wcmludHMgMFxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgdmlkZW9Ob2RlID0gY3R4LnZpZGVvKFwidmlkZW8ubXA0XCIpO1xuICAgICAgICAgKiB2aWRlb05vZGUuY29ubmVjdChjdHguZGVzdGluYXRpb24pO1xuICAgICAgICAgKiB2aWRlb05vZGUuc3RhcnQoMCk7XG4gICAgICAgICAqIHZpZGVvTm9kZS5zdG9wKDEwKTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2coY3R4LmR1cmF0aW9uKTsgLy9wcmludHMgMTBcbiAgICAgICAgICpcbiAgICAgICAgICogY3R4LnBsYXkoKTtcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHZhciBtYXhUaW1lID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc291cmNlTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlTm9kZXNbaV0uc3RhdGUgIT09IF9zb3VyY2Vub2RlLlNPVVJDRU5PREVTVEFURS53YWl0aW5nICYmIHRoaXMuX3NvdXJjZU5vZGVzW2ldLl9zdG9wVGltZSA+IG1heFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4VGltZSA9IHRoaXMuX3NvdXJjZU5vZGVzW2ldLl9zdG9wVGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF4VGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGZpbmFsIG5vZGUgaW4gdGhlIHJlbmRlciBncmFwaCB3aGljaCByZXByZXNlbnRzIHRoZSBjYW52YXMgdG8gZGlzcGxheSBjb250ZW50IG9uIHRvLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHByb3ByZXR5IGlzIHJlYWQtb25seSBhbmQgdGhlcmUgY2FuIG9ubHkgZXZlciBiZSBvbmUgZGVzdGluYXRpb24gbm9kZS4gT3RoZXIgbm9kZXMgY2FuIGNvbm5lY3QgdG8gdGhpcyBidXQgeW91IGNhbm5vdCBjb25uZWN0IHRoaXMgbm9kZSB0byBhbnl0aGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7RGVzdGluYXRpb25Ob2RlfSBBIGdyYXBoIG5vZGUgcmVwcmVzZW50aW5nIHRoZSBjYW52YXMgdG8gZGlzcGxheSB0aGUgY29udGVudCBvbi5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbnZhc1wiKTtcbiAgICAgICAgICogdmFyIGN0eCA9IG5ldyBWaWRlb0NvbnRleHQoY2FudmFzRWxlbWVudCk7XG4gICAgICAgICAqIHZhciB2aWRlb05vZGUgPSBjdHgudmlkZW8oXCJ2aWRlby5tcDRcIik7XG4gICAgICAgICAqIHZpZGVvTm9kZS5zdGFydCgwKTtcbiAgICAgICAgICogdmlkZW9Ob2RlLnN0b3AoMTApO1xuICAgICAgICAgKiB2aWRlb05vZGUuY29ubmVjdChjdHguZGVzdGluYXRpb24pO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlc3RpbmF0aW9uXCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc3RpbmF0aW9uTm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHBsYXliYWNrIHJhdGUgb2YgdGhlIFZpZGVvQ29udGV4dCBpbnN0YW5jZS5cbiAgICAgICAgICogVGhpcyB3aWxsIGFsdGVyIHRoZSBwbGF5YmFjayBzcGVlZCBvZiBhbGwgbWVkaWEgZWxlbWVudHMgcGxheWVkIHRocm91Z2ggdGhlIFZpZGVvQ29udGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGUgLSB0aGlzIGlzIHRoZSBwbGF5YmFjayByYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzXCIpO1xuICAgICAgICAgKiB2YXIgY3R4ID0gbmV3IFZpZGVvQ29udGV4dChjYW52YXNFbGVtZW50KTtcbiAgICAgICAgICogdmFyIHZpZGVvTm9kZSA9IGN0eC52aWRlbyhcInZpZGVvLm1wNFwiKTtcbiAgICAgICAgICogdmlkZW9Ob2RlLnN0YXJ0KDApO1xuICAgICAgICAgKiB2aWRlb05vZGUuc3RvcCgxMCk7XG4gICAgICAgICAqIHZpZGVvTm9kZS5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAqIGN0eC5wbGF5YmFja1JhdGUgPSAyO1xuICAgICAgICAgKiBjdHgucGxheSgpOyAvLyBEb3VibGUgcGxheWJhY2sgcmF0ZSBtZWFucyB0aGlzIHdpbGwgZmluaXNoIHBsYXlpbmcgaW4gNSBzZWNvbmRzLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInBsYXliYWNrUmF0ZVwiLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChyYXRlKSB7XG4gICAgICAgICAgICBpZiAocmF0ZSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJwbGF5YmFja1JhdGUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMTMgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjEzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjEzID0gdGhpcy5fc291cmNlTm9kZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDEzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMyA9IChfc3RlcDEzID0gX2l0ZXJhdG9yMTMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEzID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IF9zdGVwMTMudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY29uc3RydWN0b3IubmFtZSA9PT0gX3ZpZGVvbm9kZS5WSURFT1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuX2dsb2JhbFBsYXliYWNrUmF0ZSA9IHJhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLl9wbGF5YmFja1JhdGVVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMTMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMTMgPSBlcnI7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEzICYmIF9pdGVyYXRvcjEzLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMTMucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fcGxheWJhY2tSYXRlID0gcmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgUmV0dXJuIHRoZSBjdXJyZW50IHBsYXliYWNrUmF0ZSBvZiB0aGUgdmlkZW8gY29udGV4dC5cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBBIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgcGxheWJhY2tSYXRlLiAxLjAgYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgdm9sdW1lIG9mIGFsbCBNZWRpYU5vZGUgY3JlYXRlZCBpbiB0aGUgVmlkZW9Db250ZXh0LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIC0gdGhlIHZvbHVtZSB0byBhcHBseSB0byB0aGUgdmlkZW8gbm9kZXMuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwidm9sdW1lXCIsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZvbCkge1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xNCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxNCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMTQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTQgPSB0aGlzLl9zb3VyY2VOb2Rlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjE0ID0gKF9zdGVwMTQgPSBfaXRlcmF0b3IxNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTQgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gX3N0ZXAxNC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIF92aWRlb25vZGUyLmRlZmF1bHQgfHwgbm9kZSBpbnN0YW5jZW9mIF9hdWRpb25vZGUyLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudm9sdW1lID0gdm9sO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IxNCA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IxNCA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTQgJiYgX2l0ZXJhdG9yMTQucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IxNC5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjE0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjE0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl92b2x1bWUgPSB2b2w7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgdmlkZW8gY29udGV4dC5cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBBIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgdm9sdW1lLiAxLjAgYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdm9sdW1lO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogXCJERUZJTklUSU9OU1wiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfZGVmaW5pdGlvbnMyLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJOT0RFU1wiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfbm9kZXMyLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVmlkZW9Db250ZXh0O1xufSgpO1xuXG4vKipcbiAqIFZpZGVvIENvbnRleHQgU3RhdGVzXG4gKiBAcmVhZG9ubHlcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNUQVRFXG4gKiBAcHJvcGVydHkge251bWJlcn0gU1RBVEUuUExBWUlORyAtIEFsbCBzb3VyY2VzIGFyZSBhY3RpdmVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVEFURS5QQVVTRUQgLSBBbGwgc291cmNlcyBhcmUgcGF1c2VkXG4gKiBAcHJvcGVydHkge251bWJlcn0gU1RBVEUuU1RBTExFRCAtIE9uZSBvciBtb3JlIHNvdXJjZXMgaXMgdW5hYmxlIHRvIHBsYXlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVEFURS5FTkRFRCAtIEFsbCBzb3VyY2VzIGhhdmUgZmluaXNoZWQgcGxheWluZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFNUQVRFLkJST0tFTiAtIFRoZSByZW5kZXIgZ3JhcGggaXMgaW4gYSBicm9rZW4gc3RhdGVcbiAqL1xuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IFZpZGVvQ29udGV4dDtcbnZhciBTVEFURSA9IE9iamVjdC5mcmVlemUoe1xuICAgIFBMQVlJTkc6IDAsXG4gICAgUEFVU0VEOiAxLFxuICAgIFNUQUxMRUQ6IDIsXG4gICAgRU5ERUQ6IDMsXG4gICAgQlJPS0VOOiA0XG59KTtcblZpZGVvQ29udGV4dC5TVEFURSA9IFNUQVRFO1xuXG4vKipcbiAqIFZpZGVvIENvbnRleHQgRXZlbnRzXG4gKiBAcmVhZG9ubHlcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNUQVRFXG4gKiBAcHJvcGVydHkge3N0cmluZ30gU1RBVEUuVVBEQVRFIC0gQ2FsbGVkIGFueSB0aW1lIGEgZnJhbWUgaXMgcmVuZGVyZWQgdG8gdGhlIHNjcmVlbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBTVEFURS5TVEFMTEVEIC0gaGFwcGVucyBhbnl0aW1lIHRoZSBwbGF5YmFjayBpcyBzdG9wcGVkIGR1ZSB0byBidWZmZXIgc3RhcnZhdGlvbiBmb3IgcGxheWluZyBhc3NldHMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gU1RBVEUuRU5ERUQgLSBDYWxsZWQgb25jZSBwbGFja2JhY2sgaGFzIGZpbmlzaGVkIChpLmUgY3R4LmN1cnJlbnRUaW1lID09IGN0eC5kdXJhdGlvbikuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gU1RBVEUuQ09OVEVOVCAtIENhbGxlZCBhdCB0aGUgc3RhcnQgb2YgYSB0aW1lIHJlZ2lvbiB3aGVyZSB0aGVyZSBpcyBjb250ZW50IHBsYXlpbmcgb3V0IG9mIG9uZSBvciBtb3JlIHNvdXJjZU5vZGVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFNUQVRFLk5PQ09OVEVOVCAtIENhbGxlZCBhdCB0aGUgc3RhcnQgb2YgYW55IHRpbWUgcmVnaW9uIHdoZXJlIHRoZSBWaWRlb0NvbnRleHQgaXMgc3RpbGwgcGxheWluZywgYnV0IHRoZXJlIGFyZSBjdXJyZW50bHkgbm8gYWN0aXZlIHBsYXlpbmcgc291cmNlcy5cbiAqL1xudmFyIEVWRU5UUyA9IE9iamVjdC5mcmVlemUoe1xuICAgIFVQREFURTogXCJ1cGRhdGVcIixcbiAgICBTVEFMTEVEOiBcInN0YWxsZWRcIixcbiAgICBFTkRFRDogXCJlbmRlZFwiLFxuICAgIENPTlRFTlQ6IFwiY29udGVudFwiLFxuICAgIE5PQ09OVEVOVDogXCJub2NvbnRlbnRcIlxufSk7XG5WaWRlb0NvbnRleHQuRVZFTlRTID0gRVZFTlRTO1xuXG5WaWRlb0NvbnRleHQudmlzdWFsaXNlVmlkZW9Db250ZXh0VGltZWxpbmUgPSBfdXRpbHMudmlzdWFsaXNlVmlkZW9Db250ZXh0VGltZWxpbmU7XG5WaWRlb0NvbnRleHQudmlzdWFsaXNlVmlkZW9Db250ZXh0R3JhcGggPSBfdXRpbHMudmlzdWFsaXNlVmlkZW9Db250ZXh0R3JhcGg7XG5WaWRlb0NvbnRleHQuY3JlYXRlQ29udHJvbEZvcm1Gb3JOb2RlID0gX3V0aWxzLmNyZWF0ZUNvbnRyb2xGb3JtRm9yTm9kZTtcblZpZGVvQ29udGV4dC5jcmVhdGVTaWdtYUdyYXBoRGF0YUZyb21SZW5kZXJHcmFwaCA9IF91dGlscy5jcmVhdGVTaWdtYUdyYXBoRGF0YUZyb21SZW5kZXJHcmFwaDtcblZpZGVvQ29udGV4dC5leHBvcnRUb0pTT04gPSBfdXRpbHMuZXhwb3J0VG9KU09OO1xuVmlkZW9Db250ZXh0LnVwZGF0ZWFibGVzTWFuYWdlciA9IHVwZGF0ZWFibGVzTWFuYWdlcjtcblZpZGVvQ29udGV4dC5pbXBvcnRTaW1wbGVFREwgPSBfdXRpbHMuaW1wb3J0U2ltcGxlRURMO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3ZpZGVvZWxlbWVudGNhY2hlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3ZpZGVvZWxlbWVudGNhY2hlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF92aWRlb2VsZW1lbnRjYWNoZWl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ZpZGVvZWxlbWVudGNhY2hlaXRlbSAqLyBcIi4vc3JjL3ZpZGVvZWxlbWVudGNhY2hlaXRlbS5qc1wiKTtcblxudmFyIF92aWRlb2VsZW1lbnRjYWNoZWl0ZW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlkZW9lbGVtZW50Y2FjaGVpdGVtKTtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMgKi8gXCIuL3NyYy91dGlscy5qc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFZpZGVvRWxlbWVudENhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZGVvRWxlbWVudENhY2hlKCkge1xuICAgICAgICB2YXIgY2FjaGVfc2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMztcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlkZW9FbGVtZW50Q2FjaGUpO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlSXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5fY2FjaGVJdGVtc0luaXRpYWxpc2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVfc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB2aWRlbyBlbGVtZW50IGFuZCBjYWNoZVxuICAgICAgICAgICAgdGhpcy5fY2FjaGVJdGVtcy5wdXNoKG5ldyBfdmlkZW9lbGVtZW50Y2FjaGVpdGVtMi5kZWZhdWx0KCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFZpZGVvRWxlbWVudENhY2hlLCBbe1xuICAgICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FjaGVJdGVtc0luaXRpYWxpc2VkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoY2FjaGVJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUl0ZW0uZWxlbWVudC5wbGF5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGF1c2UgYW55IGVsZW1lbnRzIG5vdCBpbiB0aGUgXCJwbGF5aW5nXCIgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhY2hlSXRlbS5pc1BsYXlpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUl0ZW0uZWxlbWVudC5wYXVzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUubmFtZSAhPT0gXCJOb3RTdXBwb3J0ZWRFcnJvclwiKSB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5fY2FjaGVJdGVtc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZUl0ZW0gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3AoY2FjaGVJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2FjaGVJdGVtc0luaXRpYWxpc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIGFuZCByZXR1cm4gYW4gZW1wdHkgaW5pdGlhbGlzZWQgZWxlbWVudCBvciwgaWYgdGhlIGNhY2hlIGlzXG4gICAgICAgICAqIGVtcHR5LCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbWVkaWFOb2RlIEEgYE1lZGlhTm9kZWAgaW5zdGFuY2VcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRFbGVtZW50QW5kTGlua1RvTm9kZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudEFuZExpbmtUb05vZGUobWVkaWFOb2RlKSB7XG4gICAgICAgICAgICAvLyBUcnkgYW5kIGdldCBhbiBhbHJlYWR5IGludGlhbGlzZWQgZWxlbWVudC5cbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0aGlzLl9jYWNoZUl0ZW1zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfY2FjaGVJdGVtID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiBhbiB1bmluaXRpYWxpc2VkIHZpZGVvRWxlbWVudCBoYXMgaXRzIHNyIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIHdpbmRvd3MgaHJlZi4gSGVuY2UgdGhlIGJlbG93IGNoZWNrLlxuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfdXRpbHMubWVkaWFFbGVtZW50SGFzU291cmNlKShfY2FjaGVJdGVtLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdHRhY2ggbm9kZSB0byB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgX2NhY2hlSXRlbS5saW5rTm9kZShtZWRpYU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jYWNoZUl0ZW0uZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBjcmVhdGluZyBhIG5ldyBlbGVtZW50IGlmIG5vbmUgZXhpc3Qgb3IgYXJlIGF2YWlsYWJsZVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJObyBhdmFpbGFibGUgdmlkZW8gZWxlbWVudCBpbiB0aGUgY2FjaGUsIGNyZWF0aW5nIGEgbmV3IG9uZS4gVGhpcyBtYXkgYnJlYWsgbW9iaWxlLCBtYWtlIHlvdXIgaW5pdGlhbCBjYWNoZSBsYXJnZXIuXCIpO1xuICAgICAgICAgICAgdmFyIGNhY2hlSXRlbSA9IG5ldyBfdmlkZW9lbGVtZW50Y2FjaGVpdGVtMi5kZWZhdWx0KG1lZGlhTm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUl0ZW1zLnB1c2goY2FjaGVJdGVtKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlSXRlbXNJbml0aWFsaXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlSXRlbS5lbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVubGluayBhbnkgbWVkaWEgbm9kZSBjdXJyZW50bHkgbGlua2VkIHRvIGEgY2FjaGVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7VmlkZW9FbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHVubGluayBmcm9tIGFueSBtZWRpYSBub2Rlc1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInVubGlua05vZGVGcm9tRWxlbWVudFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdW5saW5rTm9kZUZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSB0aGlzLl9jYWNoZUl0ZW1zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZUl0ZW0gPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVW5saW5rIHRoZSBub2RlIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IGNhY2hlSXRlbS5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVJdGVtLnVubGlua05vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlSXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwidW51c2VkXCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSB0aGlzLl9jYWNoZUl0ZW1zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA0OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gKF9zdGVwNCA9IF9pdGVyYXRvcjQubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZUl0ZW0gPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uIGFuIHVuaW5pdGlhbGlzZWQgdmlkZW9FbGVtZW50IGhhcyBpdHMgc3IgYXR0cmlidXRlIHNldCB0byB0aGUgd2luZG93cyBocmVmLiBIZW5jZSB0aGUgYmVsb3cgY2hlY2suXG4gICAgICAgICAgICAgICAgICAgIGlmICghKDAsIF91dGlscy5tZWRpYUVsZW1lbnRIYXNTb3VyY2UpKGNhY2hlSXRlbS5lbGVtZW50KSkgY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFZpZGVvRWxlbWVudENhY2hlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBWaWRlb0VsZW1lbnRDYWNoZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy92aWRlb2VsZW1lbnRjYWNoZWl0ZW0uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3ZpZGVvZWxlbWVudGNhY2hlaXRlbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3NvdXJjZW5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1NvdXJjZU5vZGVzL3NvdXJjZW5vZGUgKi8gXCIuL3NyYy9Tb3VyY2VOb2Rlcy9zb3VyY2Vub2RlLmpzXCIpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEEgdmlkZW8gZWxlbWVudCBpdGVtIGNyZWF0ZWQgYW5kIG1hbmFnZWQgYnkgdGhlIGBWaWRlb0VsZW1lbnRDYWNoZWAuXG4gKlxuICogVGhpcyBjcmVhdGVzIGFuZCBzdG9yZXMgYSBgPHZpZGVvIC8+YCBlbGVtZW50LCB3aGljaCBpcyBhc3NpZ25lZFxuICogdG8gYSBgTWVkaWFOb2RlYCBieSB0aGUgYFZpZGVvRWxlbWVudENhY2hlYCBmb3IgcGxheWJhY2suIE9uY2VcbiAqIHBsYXliYWNrIGhhcyBjb21wbGV0ZWQgdGhlIGBNZWRpYU5vZGVgIGFzc29jaWF0aW9uIHdpbGwgYmUgcmVtb3ZlZFxuICogYW5kIHBvdGVudGlhbGx5IHJlcGxhY2VkIHdpdGggYW5vdGhlci5cbiAqL1xudmFyIFZpZGVvRWxlbWVudENhY2hlSXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWRlb0VsZW1lbnRDYWNoZUl0ZW0oKSB7XG4gICAgICAgIHZhciBub2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWRlb0VsZW1lbnRDYWNoZUl0ZW0pO1xuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhWaWRlb0VsZW1lbnRDYWNoZUl0ZW0sIFt7XG4gICAgICAgIGtleTogXCJfY3JlYXRlRWxlbWVudFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQoKSB7XG4gICAgICAgICAgICB2YXIgdmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZShcImNyb3Nzb3JpZ2luXCIsIFwiYW5vbnltb3VzXCIpO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZShcIndlYmtpdC1wbGF5c2lubGluZVwiLCBcIlwiKTtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwbGF5c2lubGluZVwiLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiB2aWRlb0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJsaW5rTm9kZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGlua05vZGUobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJ1bmxpbmtOb2RlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bmxpbmtOb2RlKCkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJpc1BsYXlpbmdcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzUGxheWluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUuX3N0YXRlID09PSBfc291cmNlbm9kZS5TT1VSQ0VOT0RFU1RBVEUucGxheWluZztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVsZW1lbnRcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVmlkZW9FbGVtZW50Q2FjaGVJdGVtO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBWaWRlb0VsZW1lbnRDYWNoZUl0ZW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZGVvY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/videocontext/dist/videocontext.js\n");

/***/ }),

/***/ "./src/assets/js/app.js":
/*!******************************!*\
  !*** ./src/assets/js/app.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var videocontext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! videocontext */ \"./node_modules/videocontext/dist/videocontext.js\");\n/* harmony import */ var videocontext__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(videocontext__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nwindow.addEventListener('load', () => {\r\n  const date = new Date(Date.now() + 96400e5).toUTCString();\r\n  const VideoContainer = document.querySelector('.video');\r\n  const VideoStart = document.querySelector('.video__item');\r\n  const VideoAudio = document.querySelector('.video__audio');\r\n  const GetLink = document.querySelectorAll('.home-btn .btn.lock');\r\n  const VideoHover = document.querySelector('.home__hover');\r\n  const Preloader = document.querySelector('.preloader');\r\n  const PreloaderAnswer = document.querySelector('.preloader__answer');\r\n  const Play = document.querySelector('#play');\r\n  const Width = window.innerWidth;\r\n  const VideoSkip = document.querySelector('.video__skip');\r\n  const Subscribe = document.querySelector('#subscribe');\r\n  const body = document.querySelector('body');\r\n  const home = document.querySelector('.home');\r\n\r\n  // Прогресс бар\r\n  setTimeout(() => {\r\n    Play.disabled = false;\r\n    Play.classList.add('show');\r\n  }, 3000);\r\n\r\n  // Пути видео\r\n  if (Width > 1600) {\r\n    VideoStart.src = '../assets/video/1920_track_convert.mp4';\r\n  } else if (Width <= 1600 && Width >= 1200) {\r\n    VideoStart.src = '../assets/video/1440_track_convert.mp4';\r\n  } else if (Width <= 1200 && Width >= 1024) {\r\n    VideoStart.src = '../assets/video/1024_track_convert.mp4';\r\n  } else {\r\n    VideoStart.src = '../assets/video/1284_track_convert.mp4';\r\n  }\r\n\r\n  // Запуск видео\r\n  // window.playClick = function () {\r\n  //   if (get_cookie('visited')) {\r\n  //     VideoSkip.classList.add('show');\r\n  //   }\r\n  //   document.cookie = 'visited=true; expires=' + date;\r\n  //   Preloader.classList.add('hide');\r\n  //   Play.classList.add('hide');\r\n  //   VideoStart.play();\r\n  // };\r\n\r\n  // Скип видео\r\n  function Skip() {\r\n    VideoStart.pause();\r\n    VideoContainer.remove();\r\n    if (Width < 1024) {\r\n      body.style.overflow = 'auto';\r\n      body.style.height = 'auto';\r\n      home.style.height = 'auto';\r\n      window.scrollBy(0, 0);\r\n    }\r\n  }\r\n\r\n  VideoSkip.addEventListener('click', () => {\r\n    Skip()\r\n  });\r\n\r\n  VideoStart.addEventListener('ended', () => {\r\n    Skip()\r\n  });\r\n\r\nwindow.playClick = function () {\r\n  if (get_cookie('visited')) {\r\n    VideoSkip.classList.add('show');\r\n  }\r\n  document.cookie = 'visited=true; expires=' + date;\r\n  Preloader.classList.add('hide');\r\n  Play.classList.add('hide');\r\n\r\n  const audio = new Audio();\r\n  audio.autoplay = true;\r\n  audio.src = 'data:audio/mpeg;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY29tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGFTb25vdGhlcXVlLm9yZwBURU5DAAAAHQAAA1N3aXRjaCBQbHVzIMKpIE5DSCBTb2Z0d2FyZQBUSVQyAAAABgAAAzIyMzUAVFNTRQAAAA8AAANMYXZmNTcuODMuMTAwAAAAAAAAAAAAAAD/80DEAAAAA0gAAAAATEFNRTMuMTAwVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/zQsRbAAADSAAAAABVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/zQMSkAAADSAAAAABVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';\r\n\r\n  setTimeout(() => {\r\n    const canvas = document.getElementById('canvas');\r\n    let srcVideo = '';\r\n    canvas.style.width = '100%';\r\n    canvas.style.height = '100%';\r\n\r\n    if (Width > 1600) {\r\n      srcVideo = '../assets/video/1920_track.mp4';\r\n      canvas.width = 1920;\r\n      canvas.height = 1080;\r\n    } else if (Width <= 1600 && Width >= 1200) {\r\n      srcVideo = '../assets/video/1440_track.mp4';\r\n      canvas.width = 1440;\r\n      canvas.height = 900;\r\n    } else if (Width <= 1200 && Width >= 1024) {\r\n      srcVideo = '../assets/video/1024_track.mp4';\r\n      canvas.width = 1024;\r\n      canvas.height = 1366;\r\n    } else {\r\n      srcVideo = '../assets/video/1284_track.mp4';\r\n      canvas.width = 1284;\r\n      canvas.height = 2778;\r\n    }\r\n\r\n    const videoCtx = new (videocontext__WEBPACK_IMPORTED_MODULE_0___default())(canvas);\r\n    const videoNode = videoCtx.video(srcVideo, 0, 2, {\r\n      volume: 0\r\n    });\r\n    // videoNode.volume(0);\r\n    // const audioNode = videoCtx.audio('../assets/video/audio.mp3');\r\n    // audioNode.connect(videoCtx.destination);\r\n    // audioNode.start(0);\r\n    videoNode.connect(videoCtx.destination);\r\n    videoNode.start(0);\r\n\r\n    //audio context\r\n    // const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\r\n\r\n    // const source= audioCtx.createMediaElementSource(audio);\r\n    // source.connect(audioCtx.destination);\r\n    // audio.play();\r\n    videoCtx.play();\r\n    // VideoAudio.play()\r\n    videoCtx.registerCallback((videocontext__WEBPACK_IMPORTED_MODULE_0___default().EVENTS.CONTENT), () => {\r\n      audio.src = './assets/video/audio.mp3';\r\n    });\r\n\r\n    videoCtx.registerCallback((videocontext__WEBPACK_IMPORTED_MODULE_0___default().EVENTS.ENDED), () => {\r\n      VideoContainer.remove();\r\n      audio.pause();\r\n      if (Width < 1024) {\r\n        body.style.overflow = 'auto';\r\n        body.style.height = 'auto';\r\n        home.style.height = 'auto';\r\n        window.scrollBy(0, 0);\r\n      }\r\n    });\r\n\r\n    VideoSkip.addEventListener('click', () => {\r\n      videoCtx.pause();\r\n      audio.pause();\r\n      canvas.remove();\r\n      VideoContainer.remove();\r\n      if (Width < 1024) {\r\n        body.style.overflow = 'auto';\r\n        body.style.height = 'auto';\r\n        home.style.height = 'auto';\r\n        window.scrollBy(0, 0);\r\n      }\r\n    });\r\n  }, 1500);\r\n};\r\n\r\n  // Чистка hover видео\r\n  VideoHover.addEventListener('contextmenu', function (e) {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n  }, false);\r\n  if (VideoHover.hasAttribute('controls')) {\r\n    VideoHover.removeAttribute('controls');\r\n  }\r\n\r\n  // Hover видео\r\n  GetLink.forEach(item => {\r\n    item.addEventListener(('click'), (e) => {\r\n      e.preventDefault();\r\n    });\r\n\r\n    const startHover = () => {\r\n      item.textContent = 'coming soon';\r\n      item.classList.add('white');\r\n      VideoHover.play();\r\n      VideoHover.classList.add('play');\r\n      VideoHover.addEventListener('ended', function () {\r\n        VideoHover.currentTime = 0;\r\n        VideoHover.play();\r\n      });\r\n    };\r\n\r\n    const removeHover = () => {\r\n      item.textContent = 'get started';\r\n      item.classList.remove('white');\r\n      VideoHover.classList.remove('play');\r\n      VideoHover.pause();\r\n    };\r\n\r\n    if (Width > 1023.98) {\r\n      item.addEventListener('mouseover', () => {\r\n        startHover();\r\n      });\r\n      item.addEventListener('mouseout', () => {\r\n        removeHover();\r\n      });\r\n    } else {\r\n      item.addEventListener('click', (e) => {\r\n        startHover();\r\n        setTimeout(() => {\r\n          removeHover();\r\n        }, 3000);\r\n      });\r\n    }\r\n  });\r\n\r\n  // Модальное окно\r\n  const Modal = document.querySelector('.modal');\r\n  const ModalClose = document.querySelector('.modal__close');\r\n  Subscribe.addEventListener('click', (e) => {\r\n    e.preventDefault();\r\n    Modal.classList.add('show');\r\n  });\r\n  ModalClose.addEventListener('click', () => {\r\n    Modal.classList.remove('show');\r\n  });\r\n\r\n  // cookie\r\n  function get_cookie (cookie_name) {\r\n    const results = document.cookie.match('(^|;) ?' + cookie_name + '=([^;]*)(;|$)');\r\n\r\n    if (results)\r\n      return (unescape(results[2]));\r\n    else\r\n      return null;\r\n  }\r\n\r\n  // reality? yes/no toggle\r\n  (function () {\r\n    setInterval(() => {\r\n      setTimeout(() => {\r\n        PreloaderAnswer.innerHTML = 'No';\r\n      }, 150);\r\n      setTimeout(() => {\r\n        PreloaderAnswer.innerHTML = 'Yes';\r\n      }, 300);\r\n    }, 300);\r\n  })();\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXNzZXRzL2pzL2FwcC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBWTtBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvRUFBMkI7QUFDekQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4QkFBOEIsa0VBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywyQkFBMkIsS0FBSztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haXItc3RhcnQvLi9zcmMvYXNzZXRzL2pzL2FwcC5qcz9lYzc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWaWRlb0NvbnRleHQgZnJvbSAndmlkZW9jb250ZXh0JztcclxuXHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xyXG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgOTY0MDBlNSkudG9VVENTdHJpbmcoKTtcclxuICBjb25zdCBWaWRlb0NvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy52aWRlbycpO1xyXG4gIGNvbnN0IFZpZGVvU3RhcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudmlkZW9fX2l0ZW0nKTtcclxuICBjb25zdCBWaWRlb0F1ZGlvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnZpZGVvX19hdWRpbycpO1xyXG4gIGNvbnN0IEdldExpbmsgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaG9tZS1idG4gLmJ0bi5sb2NrJyk7XHJcbiAgY29uc3QgVmlkZW9Ib3ZlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ob21lX19ob3ZlcicpO1xyXG4gIGNvbnN0IFByZWxvYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wcmVsb2FkZXInKTtcclxuICBjb25zdCBQcmVsb2FkZXJBbnN3ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucHJlbG9hZGVyX19hbnN3ZXInKTtcclxuICBjb25zdCBQbGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3BsYXknKTtcclxuICBjb25zdCBXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gIGNvbnN0IFZpZGVvU2tpcCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy52aWRlb19fc2tpcCcpO1xyXG4gIGNvbnN0IFN1YnNjcmliZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzdWJzY3JpYmUnKTtcclxuICBjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xyXG4gIGNvbnN0IGhvbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaG9tZScpO1xyXG5cclxuICAvLyDQn9GA0L7Qs9GA0LXRgdGBINCx0LDRgFxyXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgUGxheS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgUGxheS5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XHJcbiAgfSwgMzAwMCk7XHJcblxyXG4gIC8vINCf0YPRgtC4INCy0LjQtNC10L5cclxuICBpZiAoV2lkdGggPiAxNjAwKSB7XHJcbiAgICBWaWRlb1N0YXJ0LnNyYyA9ICcuLi9hc3NldHMvdmlkZW8vMTkyMF90cmFja19jb252ZXJ0Lm1wNCc7XHJcbiAgfSBlbHNlIGlmIChXaWR0aCA8PSAxNjAwICYmIFdpZHRoID49IDEyMDApIHtcclxuICAgIFZpZGVvU3RhcnQuc3JjID0gJy4uL2Fzc2V0cy92aWRlby8xNDQwX3RyYWNrX2NvbnZlcnQubXA0JztcclxuICB9IGVsc2UgaWYgKFdpZHRoIDw9IDEyMDAgJiYgV2lkdGggPj0gMTAyNCkge1xyXG4gICAgVmlkZW9TdGFydC5zcmMgPSAnLi4vYXNzZXRzL3ZpZGVvLzEwMjRfdHJhY2tfY29udmVydC5tcDQnO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBWaWRlb1N0YXJ0LnNyYyA9ICcuLi9hc3NldHMvdmlkZW8vMTI4NF90cmFja19jb252ZXJ0Lm1wNCc7XHJcbiAgfVxyXG5cclxuICAvLyDQl9Cw0L/Rg9GB0Log0LLQuNC00LXQvlxyXG4gIC8vIHdpbmRvdy5wbGF5Q2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgLy8gICBpZiAoZ2V0X2Nvb2tpZSgndmlzaXRlZCcpKSB7XHJcbiAgLy8gICAgIFZpZGVvU2tpcC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XHJcbiAgLy8gICB9XHJcbiAgLy8gICBkb2N1bWVudC5jb29raWUgPSAndmlzaXRlZD10cnVlOyBleHBpcmVzPScgKyBkYXRlO1xyXG4gIC8vICAgUHJlbG9hZGVyLmNsYXNzTGlzdC5hZGQoJ2hpZGUnKTtcclxuICAvLyAgIFBsYXkuY2xhc3NMaXN0LmFkZCgnaGlkZScpO1xyXG4gIC8vICAgVmlkZW9TdGFydC5wbGF5KCk7XHJcbiAgLy8gfTtcclxuXHJcbiAgLy8g0KHQutC40L8g0LLQuNC00LXQvlxyXG4gIGZ1bmN0aW9uIFNraXAoKSB7XHJcbiAgICBWaWRlb1N0YXJ0LnBhdXNlKCk7XHJcbiAgICBWaWRlb0NvbnRhaW5lci5yZW1vdmUoKTtcclxuICAgIGlmIChXaWR0aCA8IDEwMjQpIHtcclxuICAgICAgYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcclxuICAgICAgYm9keS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XHJcbiAgICAgIGhvbWUuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xyXG4gICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBWaWRlb1NraXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICBTa2lwKClcclxuICB9KTtcclxuXHJcbiAgVmlkZW9TdGFydC5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsICgpID0+IHtcclxuICAgIFNraXAoKVxyXG4gIH0pO1xyXG5cclxud2luZG93LnBsYXlDbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAoZ2V0X2Nvb2tpZSgndmlzaXRlZCcpKSB7XHJcbiAgICBWaWRlb1NraXAuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xyXG4gIH1cclxuICBkb2N1bWVudC5jb29raWUgPSAndmlzaXRlZD10cnVlOyBleHBpcmVzPScgKyBkYXRlO1xyXG4gIFByZWxvYWRlci5jbGFzc0xpc3QuYWRkKCdoaWRlJyk7XHJcbiAgUGxheS5jbGFzc0xpc3QuYWRkKCdoaWRlJyk7XHJcblxyXG4gIGNvbnN0IGF1ZGlvID0gbmV3IEF1ZGlvKCk7XHJcbiAgYXVkaW8uYXV0b3BsYXkgPSB0cnVlO1xyXG4gIGF1ZGlvLnNyYyA9ICdkYXRhOmF1ZGlvL21wZWc7YmFzZTY0LFNVUXpCQUFBQUFBQkVWUllXRmdBQUFBdEFBQURZMjl0YldWdWRBQkNhV2RUYjNWdVpFSmhibXN1WTI5dElDOGdUR0ZUYjI1dmRHaGxjWFZsTG05eVp3QlVSVTVEQUFBQUhRQUFBMU4zYVhSamFDQlFiSFZ6SU1LcElFNURTQ0JUYjJaMGQyRnlaUUJVU1ZReUFBQUFCZ0FBQXpJeU16VUFWRk5UUlFBQUFBOEFBQU5NWVhabU5UY3VPRE11TVRBd0FBQUFBQUFBQUFBQUFBRC84MERFQUFBQUEwZ0FBQUFBVEVGTlJUTXVNVEF3VlZWVlZWVlZWVlZWVlV4QlRVVXpMakV3TUZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVmYvelFzUmJBQUFEU0FBQUFBQlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWZi96UU1Ta0FBQURTQUFBQUFCVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVic7XHJcblxyXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpO1xyXG4gICAgbGV0IHNyY1ZpZGVvID0gJyc7XHJcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xyXG5cclxuICAgIGlmIChXaWR0aCA+IDE2MDApIHtcclxuICAgICAgc3JjVmlkZW8gPSAnLi4vYXNzZXRzL3ZpZGVvLzE5MjBfdHJhY2subXA0JztcclxuICAgICAgY2FudmFzLndpZHRoID0gMTkyMDtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IDEwODA7XHJcbiAgICB9IGVsc2UgaWYgKFdpZHRoIDw9IDE2MDAgJiYgV2lkdGggPj0gMTIwMCkge1xyXG4gICAgICBzcmNWaWRlbyA9ICcuLi9hc3NldHMvdmlkZW8vMTQ0MF90cmFjay5tcDQnO1xyXG4gICAgICBjYW52YXMud2lkdGggPSAxNDQwO1xyXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gOTAwO1xyXG4gICAgfSBlbHNlIGlmIChXaWR0aCA8PSAxMjAwICYmIFdpZHRoID49IDEwMjQpIHtcclxuICAgICAgc3JjVmlkZW8gPSAnLi4vYXNzZXRzL3ZpZGVvLzEwMjRfdHJhY2subXA0JztcclxuICAgICAgY2FudmFzLndpZHRoID0gMTAyNDtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IDEzNjY7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzcmNWaWRlbyA9ICcuLi9hc3NldHMvdmlkZW8vMTI4NF90cmFjay5tcDQnO1xyXG4gICAgICBjYW52YXMud2lkdGggPSAxMjg0O1xyXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gMjc3ODtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB2aWRlb0N0eCA9IG5ldyBWaWRlb0NvbnRleHQoY2FudmFzKTtcclxuICAgIGNvbnN0IHZpZGVvTm9kZSA9IHZpZGVvQ3R4LnZpZGVvKHNyY1ZpZGVvLCAwLCAyLCB7XHJcbiAgICAgIHZvbHVtZTogMFxyXG4gICAgfSk7XHJcbiAgICAvLyB2aWRlb05vZGUudm9sdW1lKDApO1xyXG4gICAgLy8gY29uc3QgYXVkaW9Ob2RlID0gdmlkZW9DdHguYXVkaW8oJy4uL2Fzc2V0cy92aWRlby9hdWRpby5tcDMnKTtcclxuICAgIC8vIGF1ZGlvTm9kZS5jb25uZWN0KHZpZGVvQ3R4LmRlc3RpbmF0aW9uKTtcclxuICAgIC8vIGF1ZGlvTm9kZS5zdGFydCgwKTtcclxuICAgIHZpZGVvTm9kZS5jb25uZWN0KHZpZGVvQ3R4LmRlc3RpbmF0aW9uKTtcclxuICAgIHZpZGVvTm9kZS5zdGFydCgwKTtcclxuXHJcbiAgICAvL2F1ZGlvIGNvbnRleHRcclxuICAgIC8vIGNvbnN0IGF1ZGlvQ3R4ID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpKCk7XHJcblxyXG4gICAgLy8gY29uc3Qgc291cmNlPSBhdWRpb0N0eC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UoYXVkaW8pO1xyXG4gICAgLy8gc291cmNlLmNvbm5lY3QoYXVkaW9DdHguZGVzdGluYXRpb24pO1xyXG4gICAgLy8gYXVkaW8ucGxheSgpO1xyXG4gICAgdmlkZW9DdHgucGxheSgpO1xyXG4gICAgLy8gVmlkZW9BdWRpby5wbGF5KClcclxuICAgIHZpZGVvQ3R4LnJlZ2lzdGVyQ2FsbGJhY2soVmlkZW9Db250ZXh0LkVWRU5UUy5DT05URU5ULCAoKSA9PiB7XHJcbiAgICAgIGF1ZGlvLnNyYyA9ICcuL2Fzc2V0cy92aWRlby9hdWRpby5tcDMnO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmlkZW9DdHgucmVnaXN0ZXJDYWxsYmFjayhWaWRlb0NvbnRleHQuRVZFTlRTLkVOREVELCAoKSA9PiB7XHJcbiAgICAgIFZpZGVvQ29udGFpbmVyLnJlbW92ZSgpO1xyXG4gICAgICBhdWRpby5wYXVzZSgpO1xyXG4gICAgICBpZiAoV2lkdGggPCAxMDI0KSB7XHJcbiAgICAgICAgYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcclxuICAgICAgICBib2R5LnN0eWxlLmhlaWdodCA9ICdhdXRvJztcclxuICAgICAgICBob21lLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcclxuICAgICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgMCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIFZpZGVvU2tpcC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgdmlkZW9DdHgucGF1c2UoKTtcclxuICAgICAgYXVkaW8ucGF1c2UoKTtcclxuICAgICAgY2FudmFzLnJlbW92ZSgpO1xyXG4gICAgICBWaWRlb0NvbnRhaW5lci5yZW1vdmUoKTtcclxuICAgICAgaWYgKFdpZHRoIDwgMTAyNCkge1xyXG4gICAgICAgIGJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XHJcbiAgICAgICAgYm9keS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XHJcbiAgICAgICAgaG9tZS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XHJcbiAgICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIDApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LCAxNTAwKTtcclxufTtcclxuXHJcbiAgLy8g0KfQuNGB0YLQutCwIGhvdmVyINCy0LjQtNC10L5cclxuICBWaWRlb0hvdmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGUpIHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgfSwgZmFsc2UpO1xyXG4gIGlmIChWaWRlb0hvdmVyLmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSkge1xyXG4gICAgVmlkZW9Ib3Zlci5yZW1vdmVBdHRyaWJ1dGUoJ2NvbnRyb2xzJyk7XHJcbiAgfVxyXG5cclxuICAvLyBIb3ZlciDQstC40LTQtdC+XHJcbiAgR2V0TGluay5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgaXRlbS5hZGRFdmVudExpc3RlbmVyKCgnY2xpY2snKSwgKGUpID0+IHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgc3RhcnRIb3ZlciA9ICgpID0+IHtcclxuICAgICAgaXRlbS50ZXh0Q29udGVudCA9ICdjb21pbmcgc29vbic7XHJcbiAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgnd2hpdGUnKTtcclxuICAgICAgVmlkZW9Ib3Zlci5wbGF5KCk7XHJcbiAgICAgIFZpZGVvSG92ZXIuY2xhc3NMaXN0LmFkZCgncGxheScpO1xyXG4gICAgICBWaWRlb0hvdmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFZpZGVvSG92ZXIuY3VycmVudFRpbWUgPSAwO1xyXG4gICAgICAgIFZpZGVvSG92ZXIucGxheSgpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcmVtb3ZlSG92ZXIgPSAoKSA9PiB7XHJcbiAgICAgIGl0ZW0udGV4dENvbnRlbnQgPSAnZ2V0IHN0YXJ0ZWQnO1xyXG4gICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ3doaXRlJyk7XHJcbiAgICAgIFZpZGVvSG92ZXIuY2xhc3NMaXN0LnJlbW92ZSgncGxheScpO1xyXG4gICAgICBWaWRlb0hvdmVyLnBhdXNlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChXaWR0aCA+IDEwMjMuOTgpIHtcclxuICAgICAgaXRlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCAoKSA9PiB7XHJcbiAgICAgICAgc3RhcnRIb3ZlcigpO1xyXG4gICAgICB9KTtcclxuICAgICAgaXRlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsICgpID0+IHtcclxuICAgICAgICByZW1vdmVIb3ZlcigpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgIHN0YXJ0SG92ZXIoKTtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIHJlbW92ZUhvdmVyKCk7XHJcbiAgICAgICAgfSwgMzAwMCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyDQnNC+0LTQsNC70YzQvdC+0LUg0L7QutC90L5cclxuICBjb25zdCBNb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbCcpO1xyXG4gIGNvbnN0IE1vZGFsQ2xvc2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubW9kYWxfX2Nsb3NlJyk7XHJcbiAgU3Vic2NyaWJlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIE1vZGFsLmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcclxuICB9KTtcclxuICBNb2RhbENsb3NlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgTW9kYWwuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBjb29raWVcclxuICBmdW5jdGlvbiBnZXRfY29va2llIChjb29raWVfbmFtZSkge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaCgnKF58OykgPycgKyBjb29raWVfbmFtZSArICc9KFteO10qKSg7fCQpJyk7XHJcblxyXG4gICAgaWYgKHJlc3VsdHMpXHJcbiAgICAgIHJldHVybiAodW5lc2NhcGUocmVzdWx0c1syXSkpO1xyXG4gICAgZWxzZVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIHJlYWxpdHk/IHllcy9ubyB0b2dnbGVcclxuICAoZnVuY3Rpb24gKCkge1xyXG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBQcmVsb2FkZXJBbnN3ZXIuaW5uZXJIVE1MID0gJ05vJztcclxuICAgICAgfSwgMTUwKTtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgUHJlbG9hZGVyQW5zd2VyLmlubmVySFRNTCA9ICdZZXMnO1xyXG4gICAgICB9LCAzMDApO1xyXG4gICAgfSwgMzAwKTtcclxuICB9KSgpO1xyXG59KTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/assets/js/app.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/assets/js/app.js");
/******/ 	
/******/ })()
;